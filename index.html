
<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="โนนไทย">

    <meta name="theme-color" content="#2563eb">
    <title>โนนไทย</title>
    <link rel="manifest" href="manifest.json">
    <link rel="icon" href="static/icons/lb.ico" type="image/x-icon"> <!-- แก้เป็นพาธสัมพัทธ์ -->
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <!-- เพิ่มในส่วน <head> ของไฟล์ HTML -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        body, html { height: 100%; margin: 0; padding: 0; overflow: hidden; font-family: sans-serif; }
        #map { height: 100vh; width: 100vw; z-index: 0; }
        
        /* ข้อ 1: ปรับแต่งเป้าเล็งใหม่ (ใหญ่ขึ้น 20%, หนาขึ้น, สูงขึ้น 15%) */
        .crosshair {
            position: absolute;
            top: 35%; /* สูงขึ้นจากกึ่งกลาง (50% - 15%) */
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 1000;
        }
        .crosshair-center {
            width: 6px; height: 6px;
            background-color: #ef4444;
            border-radius: 50%;
            position: absolute;
            top: 50%; left: 50%; transform: translate(-50%, -50%);
        }
        .crosshair-circle {
            width: 60px; height: 60px; /* ใหญ่ขึ้นจาก 50px */
            border: 3px solid rgba(239, 68, 68, 0.9); /* เส้นหนาขึ้น */
            border-radius: 50%;
            position: relative;
        }
        .crosshair-line { position: absolute; background-color: rgba(239, 68, 68, 0.9); }
        .line-v { width: 3px; height: 18px; left: 50%; transform: translateX(-50%); }
        .line-h { height: 3px; width: 18px; top: 50%; transform: translateY(-50%); }
        .v-top { top: -20px; } .v-bottom { bottom: -20px; }
        .h-left { left: -20px; } .h-right { right: -20px; }

        /* สไตล์พิเศษสำหรับสีพื้นหลังช่องกรอกตามเงื่อนไข */
        .bg-custom-green { 
            background-color: rgba(187, 247, 208, 0.9) !important; 
        }
        .bg-custom-pink { 
            background-color: rgba(255, 249, 196, 0.9) !important; 
        }
        .bg-custom-check-status { 
            background-color: rgba(187, 247, 208, 0.9) !important; 
            font-weight: bold;
        }

        /* สไตล์สำหรับฟิลด์ที่อ่านอย่างเดียว */
        .form-input[readonly] {
            background-color: rgba(187, 247, 208, 0.9) !important;
            cursor: not-allowed !important;
            opacity: 0.85;
            border-color: #9ca3af !important;
        }
        .form-input[readonly]:hover {
            border-color: #6b7280 !important;
        }

        /* สีเขียวสำหรับกลุ่มแรก */
        .form-input.green-bg {
            background-color: rgba(187, 247, 208, 0.9) !important;
        }

        /* สีชมพูอ่อนสำหรับกลุ่มสอง */
        .form-input.pink-bg {
            background-color: rgba(255, 204, 204, 0.3) !important; /* ชมพูอ่อน */
        }

        /* สีเขียวสำหรับช่อง "สถานะการตรวจสอบ" */
        .form-input.check-status {
            background-color: rgba(187, 247, 208, 0.9) !important;
            font-weight: bold;
        }

        /* แก้ไขสีพื้นหลังสถานะ "ถ่ายรูปแล้ว" */
        .status-ถ่ายรูปแล้ว { 
            background: rgba(187, 247, 208, 0.9) !important; 
            color: #065f46; 
        }

        /* แก้ไขส่วน .side-panel ให้โปร่งใส */
        .side-panel { 
            transition: transform 0.3s ease-in-out; 
            transform: translateX(100%); 
            background: rgba(200, 200, 200, 1.0); /* โปร่งใส 95% */            
            z-index: 1010;
            box-shadow: -5px 0 25px rgba(0,0,0,0.15); /* เงาให้ดูดีขึ้น */
        }
        .form-label { 
            font-size: 0.85rem; /* ขนาดใหญ่ขึ้น */
            font-weight: 700; 
            color: #dc2626; /* สีแดง */
            margin-bottom: 0.2rem; /* เพิ่มระยะห่าง */
            display: block;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.8); /* เงาสีขาว */
        }
        .form-input { 
            width: 100%; 
            padding: 0.5rem 0.75rem; /* เพิ่ม padding */
            font-size: 0.9rem; /* ขนาดตัวหนังสือใหญ่ขึ้น */
            font-weight: 600; /* ตัวหนา */
            color: #2563eb; /* สีน้ำเงิน */
            background-color: rgba(255, 255, 255, 0.6); /* พื้นหลังโปร่งใส */
            border: 1.5px solid #d1d5db; /* เส้นหนาขึ้น */
            border-radius: 0.5rem; 
            outline: none;
            transition: border-color 0.2s ease;
        }
        .form-input:focus {
            border-color: #2563eb;
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2); /* เงาชัดเจนขึ้น */
        }
        .form-input::placeholder {
            color: #9ca3af; /* สีเทาอ่อนสำหรับ placeholder */
            font-style: italic;
        }
        .side-panel.open { transform: translateX(0); }
        
        .map-btn { background: white; border-radius: 10px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        .active-tool { background-color: #2563eb !important; color: white !important; border: 2px solid white; }
        .active-edit { background-color: #2563eb !important; color: white !important; border: 2px solid white !important; }

        /* ข้อ 2: ปุ่มยืนยันเหนือปุ่มบวก (ระยะห่าง = เส้นผ่าศูนย์กลางปุ่มบวก 70px) */
        .confirm-btn-overlay {
        position: absolute;
        bottom: calc(2.5rem + 4.375rem + 4.375rem); /* bottom-10 (40px) + ความสูงปุ่ม (70px) + ระยะห่าง (70px) */
        left: 50%;
        transform: translateX(-50%);
        z-index: 1005;
        }
        /* สไตล์สำหรับเมนูฟันเฟือง */
        #settings-menu button {
          opacity: 0;
          transform: translateY(-20px);
          transition: all 0.3s ease;
        }

        #settings-menu button:hover {
          transform: translateY(0) scale(1.05) !important;
        }
        /* ========== แอนิเมชันเลื่อนขึ้น/ลง + ศูนย์กลางสำหรับเป้าเล็งและปุ่มบวก ========== */
        #crosshair {
          transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275),
                      opacity 0.6s ease;
          transform: translate(-50%, -50%) translateY(100vh); /* รวมศูนย์กลาง + เลื่อนจากล่าง */
          opacity: 0;
          will-change: transform, opacity;
        }
        #crosshair.visible {
          transform: translate(-50%, -50%) translateY(0); /* ศูนย์กลาง + ตำแหน่งปกติ */
          opacity: 1;
        }

        #add-trigger-container {
          transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275),
                      opacity 0.6s ease;
          transform: translateX(-50%) translateY(100vh); /* รวมศูนย์กลาง + เลื่อนจากล่าง */
          opacity: 0;
          will-change: transform, opacity;
        }
        #add-trigger-container.visible {
          transform: translateX(-50%) translateY(0); /* ศูนย์กลาง + ตำแหน่งปกติ */
          opacity: 1;
        }
        /* เพิ่มการเร่งฮาร์ดแวร์สำหรับแผนที่ */
        #map {
          transform: translate3d(0, 0, 0);
          will-change: transform;
        }

        /* ปิดการเรนเดอร์ชั่วคราวเมื่อเลื่อนแผนที่ (เพิ่มความลื่น) */
        .leaflet-zoom-anim .circle-marker,
        .leaflet-zoom-anim .crosshair {
          display: none !important;
        }
        /* สำหรับมือถือ: ความเร็วแอนิเมชันปรับให้เหมาะสม */
        @media (max-width: 768px) {
          #crosshair,
          #add-trigger-container {
            transition-duration: 0.35s;
          }
        }
        /* แอนิเมชันสำหรับปุ่มฟันเฟือง */
        @keyframes spin {
          from { transform: rotate(0deg); }
          to { transform: rotate(360deg); }
        }
        .animate-spin {
          animation: spin 0.5s linear;
        }

        /* สไตล์สำหรับแกลเลอรี่รูปภาพ */
        #image-gallery-modal {
        }

        #gallery-grid::-webkit-scrollbar {
          width: 8px;
        }

        #gallery-grid::-webkit-scrollbar-track {
          background: #1f2937;
        }

        #gallery-grid::-webkit-scrollbar-thumb {
          background: #4b5563;
          border-radius: 4px;
        }

        #gallery-grid::-webkit-scrollbar-thumb:hover {
          background: #6b7280;
        }
        /* แอนิเมชันสำหรับ Modal */
        @keyframes scale-in {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }
        @keyframes scale-out {
            from { opacity: 1; transform: scale(1); }
            to { opacity: 0; transform: scale(0.9); }
        }
        .animate-scale-in { animation: scale-in 0.2s ease-out; }
        .animate-scale-out { animation: scale-out 0.2s ease-in; }

        /* แอนิเมชันสำหรับแจ้งเตือน */
        @keyframes fade-in {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes fade-out {
            from { opacity: 1; transform: translateY(0); }
            to { opacity: 0; transform: translateY(-20px); }
        }
        .animate-fade-in { animation: fade-in 0.3s ease-out; }
        .animate-fade-out { animation: fade-out 0.3s ease-in; }
        /* สถานะปุ่มรีโหลด */
        @keyframes flash-green {
            0%, 100% { background-color: white; }
            50% { background-color: #22c55e; color: white; }
        }
        .refresh-success { animation: flash-green 0.5s ease 3; }

        /* แอนิเมชันสำหรับแจ้งเตือน */
        @keyframes fade-in {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes fade-out {
            from { opacity: 1; transform: translateY(0); }
            to { opacity: 0; transform: translateY(-20px); }
        }
        .animate-fade-in { animation: fade-in 0.3s ease-out; }
        .animate-fade-out { animation: fade-out 0.3s ease-in; }

        .circle-marker {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            border: 2px solid white;
            cursor: pointer;
        }
        .circle-building { background-color: #f59e0b; }
        .circle-sign { background-color: #4ade80; }
        
        .user-location-dot {
            width: 14px; height: 14px;
            background-color: #2563eb;
            border: 2px solid white;
            border-radius: 50%;
        }
        
        /* สไตล์สำหรับตาราง */
        .data-table-panel {
            position: fixed;
            bottom: 5px;
            left: 5px;
            width: 90%;
            max-width: 900px;
            max-height: 45vh; /* ✅ เปลี่ยนจาก 60vh เป็น 47vh */
            height: 45vh; /* ✅ เพิ่มบรรทัดนี้เพื่อให้ความสูงคงที่ 47% */
            background: white;
            border-radius: 6px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            z-index: 1003;
            display: none;
            flex-direction: column;
            overflow: hidden;
            transform: translateY(100%);
            transition: transform 0.3s ease;
        }
        .data-table-panel.open {
            display: flex;
            transform: translateY(0);
        }
        .data-table-panel.open {
            display: flex;
            transform: translateY(0);
        }
        .table-header {
            background: linear-gradient(135deg, #667eea 0%, #db2777 100%);
            color: white;
            padding: 0.1rem 0.5rem;
            min-height: 20px;       /* กำหนดความสูงต่ำสุดให้เล็กลง */
            height: 44px;  
            gap: 0.25rem;    
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .table-tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }
        .table-tab {
            padding: 6px 6px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s;
        }
        .table-tab.active {
            background: white;
            color: #667eea;
        }
        .table-tab:hover:not(.active) {
            background: rgba(255,255,255,0.2);
        }
        .table-content {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }
        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }
        .data-table th {
            background: #f3f4f6;
            padding: 6px 8px;
            text-align: left;
            font-weight: 700;
            color: #374151;
            border-bottom: 2px solid #e5e7eb;
            position: sticky;
            top: 0;
            z-index: 1;
        }
        .data-table td {
            padding: 4px;
            border-bottom: 1px solid #e5e7eb;
            vertical-align: middle;
        }
        .data-table tr:hover {
            background: #f9fafb;
        }
        .data-table tr:nth-child(even) {
            background: #f9fafb;
        }
        /* แก้ไข: บังคับให้คลาส text-center ทำงานได้ */
        .data-table th.text-center,
        .data-table td.text-center {
            text-align: center !important; /* ✅ ใช้ !important เพื่อทับกฎเดิม */
        }
        .status-badge {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
        }
        .status-ยังไม่สำรวจ { background: #fef3c7; color: #92400e; }
        .status-ถ่ายรูปแล้ว { background: #d1fae5; color: #065f46; }
        .status-ตรวจสอบแล้ว { background: #fee2e2; color: #991b1b; }
        .zoom-btn {
            padding: 4px 10px;
            background: #2563eb;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 600;
            transition: all 0.2s;
        }
        .zoom-btn:hover {
            background: #1d4ed8;
            transform: scale(1.05);
        }
        .marker-icon {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid white;
        }
        .marker-building { background-color: #f97316; }
        .marker-sign { background-color: #22c55e; }
    </style>
</head>
<!-- Custom Modal Dialogs -->
<!-- Modal ยืนยันการลบ -->
<div id="confirm-delete-modal" class="fixed inset-0 bg-black/50 backdrop-blur-sm z-[2000] hidden items-center justify-center p-4">
    <div class="bg-white rounded-2xl shadow-2xl max-w-md w-full animate-scale-in">
        <div class="p-6">
            <div class="flex items-center justify-center w-16 h-16 bg-red-100 rounded-full mx-auto mb-4">
                <i data-lucide="trash-2" class="w-8 h-8 text-red-600"></i>
            </div>
            <h3 id="delete-modal-title" class="text-xl font-bold text-center text-gray-900 mb-2">ยืนยันการลบ</h3>
            <p id="delete-modal-message" class="text-center text-gray-600 mb-6">คุณแน่ใจว่าต้องการลบสิ่งปลูกสร้างนี้?</p>
            
            <div class="flex gap-3">
                <button onclick="cancelDelete()" class="flex-1 py-3 px-6 bg-gray-200 text-gray-700 rounded-lg font-semibold hover:bg-gray-300 transition-all active:scale-95">
                    ยกเลิก
                </button>
                <button onclick="confirmDeleteAction()" class="flex-1 py-3 px-6 bg-red-600 text-white rounded-lg font-semibold hover:bg-red-700 transition-all active:scale-95 flex items-center justify-center gap-2">
                    <i data-lucide="trash-2" class="w-4 h-4"></i>
                    ลบ
                </button>
            </div>
        </div>
    </div>
</div>
<!-- Modal โหมดแก้ไข -->
<div id="edit-mode-modal" class="fixed inset-0 bg-black/30 backdrop-blur-sm z-[2000] hidden items-center justify-center p-4">
    <div class="bg-white rounded-2xl shadow-2xl max-w-md w-full animate-scale-in">
        <div class="p-6">
            <div class="flex items-center justify-center w-16 h-16 bg-blue-100 rounded-full mx-auto mb-4">
                <i data-lucide="move" class="w-8 h-8 text-blue-600"></i>
            </div>
            <h3 class="text-xl font-bold text-center text-gray-900 mb-2">โหมดแก้ไขตำแหน่ง</h3>
            <p class="text-center text-gray-600 mb-6">คลิกและลากหมุดเพื่อย้ายตำแหน่ง</p>
            
            <div class="flex justify-center">
                <button onclick="closeEditModeModal()" class="py-3 px-8 bg-blue-600 text-white rounded-lg font-semibold hover:bg-blue-700 transition-all active:scale-95">
                    ตกลง
                </button>
            </div>
        </div>
    </div>
</div>
<body class="bg-gray-100">

    <div id="map"></div>

    <!-- เป้าเล็ง -->
    <div id="crosshair" class="crosshair hidden">
        <div class="crosshair-circle">
            <div class="crosshair-line line-v v-top"></div>
            <div class="crosshair-line line-v v-bottom"></div>
            <div class="crosshair-line line-h h-left"></div>
            <div class="crosshair-line line-h h-right"></div>
        </div>
        <div class="crosshair-center"></div>
    </div>

    <!-- ปุ่มคอนเฟิร์ม (ข้อ 2) -->
    <div id="confirm-overlay" class="confirm-btn-overlay hidden">
        <button id="btn-confirm-action" onclick="confirmCapture()" class="flex items-center gap-2 px-6 py-4 rounded-full text-white font-bold shadow-2xl active:scale-95 transition-all text-lg border-4 border-white">
            <i data-lucide="check-circle" class="w-6 h-6"></i>
            <span id="confirm-text">ยืนยันการเพิ่มจุด</span>
        </button>
    </div>

        <!-- ปุ่มฟันเฟืองและรีเฟรช (ด้านบนซ้าย) -->
        <div class="absolute top-4 left-4 z-[1001]">
          <!-- ปุ่มฟันเฟือง (เมนูหลัก) -->
          <button id="btn-settings" onclick="toggleSettingsMenu()" class="map-btn p-3 text-gray-600 hover:text-blue-600 transition-all relative group mb-2">
            <i data-lucide="settings-2" id="settings-icon" class="w-6 h-6"></i>
            <!-- จุดแจ้งเตือน -->
            <span id="settings-badge" class="absolute top-0 right-0 w-2 h-2 bg-red-500 rounded-full hidden"></span>
          </button>
          
          <!-- ปุ่มรีเฟรช -->
          <button id="btn-refresh" onclick="refreshData()" class="map-btn p-3 text-blue-600 transition-all">
            <i data-lucide="refresh-cw" id="refresh-icon" class="w-6 h-6"></i>
          </button>
          
          <!-- ปุ่มย่อยที่เลื่อนลงมา -->
          <div id="settings-menu" class="mt-2 space-y-2 hidden">
            <!-- ปุ่ม 1: ดาวน์โหลดสิ่งปลูกสร้าง -->
            <button onclick="exportBuildingGeoJSON()" class="map-btn p-3 w-48 bg-gradient-to-r from-orange-400 to-orange-600 text-white hover:scale-105 transition-all shadow-lg flex items-center justify-start gap-2 text-left">
              <i data-lucide="home" class="w-5 h-5"></i>
              <span class="text-xs font-bold">ดาวน์โหลดสิ่งปลูกสร้าง</span>
            </button>
            <!-- ปุ่ม 2: ดาวน์โหลดป้าย -->
            <button onclick="exportSignGeoJSON()" class="map-btn p-3 w-48 bg-gradient-to-r from-green-400 to-green-600 text-white hover:scale-105 transition-all shadow-lg flex items-center justify-start gap-2 text-left">
              <i data-lucide="map-pin" class="w-5 h-5"></i>
              <span class="text-xs font-bold">ดาวน์โหลดป้าย</span>
            </button>
            <!-- ปุ่ม 3: ดาวน์โหลดรูปสิ่งปลูกสร้าง -->
            <button onclick="loadBuildingImages()" class="map-btn p-3 w-48 bg-gradient-to-r from-blue-400 to-blue-600 text-white hover:scale-105 transition-all shadow-lg flex items-center justify-start gap-2 text-left">
              <i data-lucide="image" class="w-5 h-5"></i>
              <span class="text-xs font-bold">ดาวน์โหลดรูปสิ่งปลูกสร้าง</span>
            </button>
            <!-- ปุ่ม 4: ดาวน์โหลดรูปป้าย -->
            <button onclick="loadSignImages()" class="map-btn p-3 w-48 bg-gradient-to-r from-purple-400 to-purple-600 text-white hover:scale-105 transition-all shadow-lg flex items-center justify-start gap-2 text-left">
              <i data-lucide="gallery-horizontal" class="w-5 h-5"></i>
              <span class="text-xs font-bold">ดาวน์โหลดรูปป้าย</span>
            </button>
          </div>
        </div>

    <!-- ปุ่มเลือกประเภทและแก้ไข -->
    <div class="absolute top-4 right-4 z-[1001] flex flex-row gap-2">
        <button id="btn-building" onclick="activateTool('building')" class="map-btn p-3" title="เพิ่มสิ่งปลูกสร้าง">
            <i data-lucide="home" class="w-6 h-6 text-orange-500"></i>
        </button>
        <button id="btn-sign" onclick="activateTool('sign')" class="map-btn p-3" title="เพิ่มป้าย">
            <i data-lucide="map-pin" class="w-6 h-6 text-green-500"></i>
        </button>
        <button id="btn-edit" onclick="toggleEditMode()" class="map-btn p-3" title="โหมดแก้ไขตำแหน่ง">
            <i data-lucide="move" class="w-6 h-6 text-red-600"></i>
        </button>
    </div>

    <!-- ปุ่มตำแหน่งปัจจุบัน -->
    <div class="absolute bottom-4 left-4 z-[1001]">
    <button onclick="locateUser()" class="map-btn p-3 shadow-lg border-2 border-blue-100">
    <div class="user-location-dot"></div>
    </button>
    </div>

    <!-- ปุ่มบวก (Add Trigger) -->
    <div id="add-trigger-container" class="absolute bottom-10 left-1/2 -translate-x-1/2 z-[1001] hidden">
        <button onclick="showConfirmButton()" class="p-4 bg-blue-600/50 text-white rounded-full shadow-xl border-[3px] border-white active:scale-90 transition-all">
            <i data-lucide="plus" class="w-8 h-8"></i>
        </button>
    </div>

    <!-- ปุ่มแสดงตาราง -->
    <div class="absolute bottom-4 right-4 z-[1002]">
        <button id="btn-show-table" onclick="toggleTable()" class="map-btn p-3 bg-white hover:bg-blue-50">
            <i data-lucide="table" id="table-icon" class="w-6 h-6 text-blue-600"></i>
        </button>
    </div>

    <!-- หน้าต่างตารางข้อมูล -->
    <div id="data-table-panel" class="data-table-panel">
        <div class="table-header">
            <div class="flex items-center gap-2">
                <div class="table-tabs">
                    <div class="table-tab active" onclick="switchTableTab('building')">สิ่งปลูกสร้าง</div>
                    <div class="table-tab" onclick="switchTableTab('sign')">ป้าย</div>
                </div>
            </div>
            <button onclick="toggleTable()" class="p-1.5 hover:bg-white/20 rounded-full">
                <i data-lucide="x" class="w-4 h-4"></i>
            </button>
        </div>
        <div class="table-content">
            <div id="building-table-container" class="table-tab-content">
                <table class="data-table" id="building-table">
                    <thead>
                        <tr>
                            <th style="width: 30px"><i data-lucide="map-pin" class="w-4 h-4"></i></th>
                            <th>รหัส</th>
                            <th>เจ้าของ</th>
                            <th>ที่อยู่</th>
                            <th>ประเภท</th>
                            <th>พื้นที่ (ตร.ม.)</th>
                            <th>ตรวจสอบ</th>
                            <th style="width: 60px">ซูม</th>
                        </tr>
                    </thead>
                    <tbody id="building-table-body">
                        <tr>
                            <td colspan="8" class="text-center py-8 text-gray-500">กำลังโหลดข้อมูล...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div id="sign-table-container" class="table-tab-content hidden">
                <table class="data-table" id="sign-table">
                    <thead>
                        <tr>
                            <th style="width: 30px"><i data-lucide="map-pin" class="w-4 h-4"></i></th>
                            <th>รหัส</th>
                            <th class="text-center">ลักษณะ</th>
                            <th class="text-center">กว้าง (ซ.ม.)</th>
                            <th class="text-center">ยาว (ซ.ม.)</th>
                            <th class="text-center">จำนวนด้าน</th>
                            <th>ข้อความ</th>
                            <th class="text-center">ตรวจสอบ</th>
                            <th style="width: 60px">ซูม</th>
                        </tr>
                    </thead>
                    <tbody id="sign-table-body">
                        <tr>
                            <td colspan="8" class="text-center py-8 text-gray-500">กำลังโหลดข้อมูล...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- หน้าต่างกรอกข้อมูล -->
    <div id="side-panel" class="side-panel fixed top-0 right-0 w-[44vw] sm:w-[280px] h-full z-[1002] shadow-2xl flex flex-col">
        <div class="p-4 border-b flex justify-between items-center bg-gray-50">
            <div>
                <h2 id="panel-title" class="font-bold text-blue-900">บันทึกข้อมูล</h2>
                <p id="latlng-display" class="text-[10px] text-gray-500 font-mono"></p>
            </div>
            <button onclick="closePanel()" class="p-2 hover:bg-gray-200 rounded-full"><i data-lucide="x" class="w-5 h-5"></i></button>
        </div>
        <form id="survey-form" class="flex-1 overflow-y-auto p-4 space-y-3"></form>
        <div class="p-4 bg-white border-t">
            <button type="button" onclick="saveSurveyData()" class="w-full bg-blue-600 text-white py-3 rounded-xl font-bold flex items-center justify-center gap-2">
                <i data-lucide="save" class="w-5 h-5"></i> บันทึก
            </button>
        </div>
    </div>

    <script>
        const CONFIG = {
            SCRIPT_URL: 'https://script.google.com/macros/s/AKfycbx_NlwFmiw31BxckLSYI_q0Bu24YXw4XFkwrqvUz1LYvT6W0DcYkdpSIQXoysJhq4gVCQ/exec'
        };

    // ✅ ประกาศตัวแปร Global ทั้งหมดไว้ที่นี่ที่เดียว
        let map;
        let activeTool = null;
        let isEditMode = false;
        let surveyLayers = L.layerGroup();
        let editingMarker = null;
        let markersBeingMoved = new Set(); // ✅ เพิ่มบรรทัดนี้ - เก็บ rowKey ของจุดที่กำลังถูกย้าย
        // ตัวแปรสำหรับเก็บข้อมูลและ Cache
        let allBuildings = []; 
        let allSigns = [];   
        let movingMarkerId = null; // ✅ เก็บ ID ของจุดที่กำลังถูกลากอยู่  
        
        // ตัวแปรสำหรับระบบอัปเดตอัตโนมัติ

        let autoUpdateInterval = null;
        let isUpdating = false;
        let isUploadingImage = false; // [cite: 71]

        function initMap() {
            // ✅ ใช้ Canvas Renderer เป็นค่าเริ่มต้น
            const canvasRenderer = L.canvas({ padding: 0.5 });
            
            const mapOptions = {
                zoomControl: false,
                attributionControl: false,
                preferCanvas: true,
                renderer: canvasRenderer, // ✅ สำคัญมาก!
                zoomSnap: isMobile() ? 0.5 : 1,
                wheelDebounceTime: 40,
                doubleClickZoom: false
            };

          map = L.map('map', {
            zoomControl: false,
            attributionControl: false,
            preferCanvas: true,
            // ✅ อนุญาตให้แผนที่แสดงล้นขอบจอได้
            padding: [50, 50], // เพิ่มพื้นที่ว่างรอบแผนที่ (บน, ล่าง, ซ้าย, ขวา)
            maxBoundsViscosity: 0.5, // ลดความหนืดของขอบเขต (ทำให้เลื่อนลื่นขึ้น)
            inertia: true, // เปิดใช้งานการเลื่อนแบบอินเนอร์เชีย
            inertiaDeceleration: 3000, // ความเร็วการชะลอตัว
            inertiaMaxSpeed: 1500, // ความเร็วสูงสุด
            // ไม่กำหนดขอบเขตแผนที่ (ให้แสดงล้นได้)
            // maxBounds: undefined
          }).setView([15.202, 102.068], 14);

          // Hardware Acceleration
          const container = map.getContainer();
          container.style.transform = 'translate3d(0, 0, 0)';
          
        // Google Hybrid Tile Options - ปรับเพิ่มประสิทธิภาพ
        const tileOptions = {
            subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],
            updateWhenIdle: false, // ✅ โหลดขณะเลื่อน (ไม่รอหยุด)
            updateWhenZooming: true, // ✅ อัปเดตขณะซูม
            keepBuffer: isMobile() ? 6 : 10, // ✅ เพิ่มบัฟเฟอร์ (มือถือ 4, คอม 8)
            maxNativeZoom: 19, // ป้องกันการโหลดไทล์ที่ไม่มี
            reuseTiles: true, // ✅ ใช้ไทล์เก่าซ้ำแทนโหลดใหม่
            className: 'map-tiles-optimized'
        };

        // Low Res / Background Layer
        const lowResLayer = L.tileLayer('https://{s}.google.com/vt/lyrs=y&x={x}&y={y}&z={z}', {
            ...tileOptions,
            maxZoom: 15,
            zIndex: 1
        });

        // High Res Layer
        const highResLayer = L.tileLayer('https://{s}.google.com/vt/lyrs=y&x={x}&y={y}&z={z}', {
            ...tileOptions,
            minZoom: 16,
            maxZoom: 22,
            zIndex: 2
        });

          lowResLayer.addTo(map);
          highResLayer.addTo(map);
          surveyLayers.addTo(map);
        }
        // ตรวจจับอุปกรณ์มือถือ
        function isMobile() {
          return /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        function activateTool(tool) {
          isEditMode = false;
          document.getElementById('btn-edit').classList.remove('active-edit');
          surveyLayers.eachLayer(l => l.dragging && l.dragging.disable());
          
          if (activeTool === tool) {
            // ยกเลิกการเพิ่มจุด - เลื่อนลง
            deactivateTools();
          } else {
            // เปิดใช้งานเครื่องมือใหม่
            activeTool = tool;
            document.getElementById('btn-building').classList.toggle('active-tool', tool === 'building');
            document.getElementById('btn-sign').classList.toggle('active-tool', tool === 'sign');
            
            // แสดงเป้าเล็งและปุ่มบวกด้วยแอนิเมชันเลื่อนขึ้น
            const crosshair = document.getElementById('crosshair');
            const addTrigger = document.getElementById('add-trigger-container');
            
            // ลบคลาส hidden และเพิ่มคลาส visible พร้อมแอนิเมชัน
            crosshair.classList.remove('hidden');
            addTrigger.classList.remove('hidden');
            
            // บังคับให้เบราว์เซอร์คำนวณใหม่ก่อนเริ่มแอนิเมชัน
            void crosshair.offsetWidth;
            void addTrigger.offsetWidth;
            
            // เริ่มแอนิเมชันเลื่อนขึ้น
            crosshair.classList.add('visible');
            addTrigger.classList.add('visible');
            
            // ซ่อนปุ่มคอนเฟิร์มหากมี
            document.getElementById('confirm-overlay').classList.add('hidden');
          }
        }

        // ระบบแคชแผนที่
        let mapCache = {};

        function cacheCurrentView() {
            const bounds = map.getBounds();
            const zoom = map.getZoom();
            
            // สร้างคีย์สำหรับแคช
            const cacheKey = `${bounds.getNorth()},${bounds.getEast()},${bounds.getSouth()},${bounds.getWest()}_${zoom}`;
            
            // บันทึกตำแหน่งปัจจุบันลงในแคช
            mapCache[cacheKey] = {
                timestamp: new Date().toISOString(),
                bounds: bounds,
                zoom: zoom
            };
            
            console.log(`แคชตำแหน่ง: ${cacheKey}`);
        }

        // โหลดแผนที่จากแคชเมื่อเปิดแอป
        function loadCachedMapViews() {
            // โหลดจาก localStorage
            const cached = localStorage.getItem('mapCache');
            if (cached) {
                mapCache = JSON.parse(cached);
                console.log('โหลดแคชแผนที่เรียบร้อย');
            }
        }

        // บันทึกแคชเมื่อปิดแอป
        window.addEventListener('beforeunload', () => {
            localStorage.setItem('mapCache', JSON.stringify(mapCache));
        });

        // เรียกใช้เมื่อเปิดแอป
        loadCachedMapViews();

        function deactivateTools() {
          activeTool = null;
          document.getElementById('btn-building').classList.remove('active-tool');
          document.getElementById('btn-sign').classList.remove('active-tool');
          
          const crosshair = document.getElementById('crosshair');
          const addTrigger = document.getElementById('add-trigger-container');
          
          // เริ่มแอนิเมชันเลื่อนลง
          crosshair.classList.remove('visible');
          addTrigger.classList.remove('visible');
          
          // หลังแอนิเมชันเสร็จ ซ่อนองค์ประกอบจริงๆ
          setTimeout(() => {
            crosshair.classList.add('hidden');
            addTrigger.classList.add('hidden');
            document.getElementById('confirm-overlay').classList.add('hidden');
          }, 400); // ตรงกับระยะเวลาแอนิเมชัน 0.4s
        }

        function toggleEditMode() {
            isEditMode = !isEditMode;
            
            const btnEdit = document.getElementById('btn-edit');
            
            if (isEditMode) {
                // ปิดเครื่องมือเพิ่มจุด
                activeTool = null;
                document.getElementById('btn-building').classList.remove('active-tool');
                document.getElementById('btn-sign').classList.remove('active-tool');
                
                // ✅ เพิ่มคลาส 'active-edit' ให้ปุ่ม "move" เป็นสีน้ำเงิน
                btnEdit.classList.add('active-edit');
                
                // ✅ เปิดใช้งานการลากมาร์กเกอร์ทั้งหมด
                surveyLayers.eachLayer(function(layer) {
                    if (layer._popupData && layer.dragging && layer.dragging.enable) {
                        layer.dragging.enable();
                        
                        // ผูกเหตุการณ์เมื่อลากเสร็จ
                        layer.off('dragend');
                        layer.on('dragend', async function(e) {
                            const newLatLng = e.target.getLatLng();
                            const marker = e.target;
                            const data = marker._popupData;
                            if (data) {
                                await updateMarkerPosition(marker, data, newLatLng);
                            }
                        });
                    }
                });
                
                showEditModeModal();
            } else {
                // ✅ ลบคลาส 'active-edit' ออกจากปุ่ม "move"
                btnEdit.classList.remove('active-edit');
                
                // ✅ ปิดการลากมาร์กเกอร์ทั้งหมด
                surveyLayers.eachLayer(function(layer) {
                    if (layer.dragging && layer.dragging.disable) {
                        layer.dragging.disable();
                    }
                });
            }
        }

        // ฟังก์ชันสำหรับปิด/เปิดการใช้งานปุ่มรีโหลด
        function disableRefreshButton() {
            const btn = document.getElementById('btn-refresh');
            btn.disabled = true;
            btn.style.opacity = '0.5';
            btn.style.cursor = 'not-allowed';
        }

        function enableRefreshButton() {
            const btn = document.getElementById('btn-refresh');
            btn.disabled = false;
            btn.style.opacity = '1';
            btn.style.cursor = 'pointer';
        }


        // ข้อ 2: แสดงปุ่มยืนยัน
        function showConfirmButton() {
            const overlay = document.getElementById('confirm-overlay');
            const btn = document.getElementById('btn-confirm-action');
            const text = document.getElementById('confirm-text');

            if (activeTool === 'building') {
                btn.style.backgroundColor = '#f97316'; 
                text.innerText = "เพิ่มสิ่งปลูกสร้าง";
            } else {
                btn.style.backgroundColor = '#22c55e';
                text.innerText = "ยืนยันเพิ่มป้าย";
            }
            overlay.classList.remove('hidden');
        }

        // ข้อ 2: ยืนยันและบันทึกเบื้องหลัง
        async function confirmCapture() {
            // คำนวณพิกัดตามตำแหน่งเป้า (สูงขึ้น 15%)
            const containerPoint = L.point(map.getSize().x / 2, map.getSize().y * 0.35);
            const latlng = map.containerPointToLatLng(containerPoint);

            document.getElementById('confirm-overlay').classList.add('hidden');
            
            const tempMarker = createCircleMarker(latlng, activeTool);
            tempMarker.addTo(surveyLayers);
            
            backgroundUpload(latlng, activeTool, tempMarker);
        }

        // แก้ไขฟังก์ชัน backgroundUpload
        async function backgroundUpload(latlng, type, marker) {
            const refreshBtn = document.getElementById('btn-refresh');
            const refreshIcon = document.getElementById('refresh-icon');
            
            disableRefreshButton();
            refreshIcon.classList.add('animate-spin');
            
            // สร้างข้อมูลพื้นฐาน
            const data = {
                lat_long: `${latlng.lat.toFixed(6)}, ${latlng.lng.toFixed(6)}`,
                date_added: new Date().toISOString(),
                tempMarker: true
            };
            
            // เพิ่มข้อมูลเริ่มต้น
            if (type === 'sign') {
                data.s_code = `05G032-S${Date.now().toString().slice(-4)}`;
                data.s_name = '';
                data.s_type = '';
                data.s_wide = '0';
                data.s_length = '0';
            } else {
                data.building_c = `B${Date.now().toString().slice(-5)}`;
                data.full_name = '';
                data.b_type = '';
                data.b_area = '0';
            }
            
            // ✅ ทำเครื่องหมายในมาร์กเกอร์ว่าเป็นชั่วคราว
            marker._popupData = { ...data, type: type, tempMarker: true };
            setupMarkerPopup(marker, marker._popupData, type);
            
            try {
                // ✅ สร้างคิวทุกกรณี ไม่ต้องตรวจสอบออนไลน์/ออฟไลน์
                const queueId = addToSyncQueue('quickAdd', type, data);
                marker._popupData = {
                    ...data,
                    type: type,
                    tempMarker: true,
                    queued: true,
                    queueId: queueId
                };
                setupMarkerPopup(marker, marker._popupData, type);
                
                // ✅ เรียกซิงค์ทันที
                await processSyncQueue();
                
                // ✅ รอให้รายการนี้สำเร็จ
                const maxWaitTime = 60000; // 30 วินาที
                const startTime = Date.now();
                let queueItem = syncQueue.find(q => q.id === queueId);
                
                while (queueItem && queueItem.status === 'ยังไม่สำรวจ' && (Date.now() - startTime) < maxWaitTime) {
                    await new Promise(resolve => setTimeout(resolve, 500)); // รอ 500 มิลลิวินาที
                    queueItem = syncQueue.find(q => q.id === queueId);
                }
                
                // ✅ โหลดข้อมูลใหม่ก่อน (เพื่อให้มีข้อมูลจริงแสดงบนแผนที่)
                await loadExistingData();
                
                // ✅ ลบจุดชั่วคราวหลังจากโหลดเสร็จ
                setTimeout(() => {
                    surveyLayers.eachLayer(layer => {
                        if (layer._popupData && layer._popupData.tempMarker) {
                            surveyLayers.removeLayer(layer);
                        }
                    });
                    refreshIcon.classList.remove('animate-spin');
                    refreshBtn.classList.add('refresh-success');
                    setTimeout(() => {
                        refreshBtn.classList.remove('refresh-success');
                        enableRefreshButton();
                    }, 2000);
                    
                    if (queueItem && queueItem.status === 'success') {
                        showNotificationLeft('เพิ่มจุดเรียบร้อยแล้ว!', 'success');
                    } else {
                        showNotificationLeft('เพิ่มจุดเรียบร้อยแล้ว (รอซิงค์)', 'warning');
                    }
                }, 300);
                
            } catch (err) {
                refreshIcon.classList.remove('animate-spin');
                enableRefreshButton();
                showNotificationLeft("การบันทึกล้มเหลว: " + err.message, 'error');
            }
        }

        // ============================================
        // ฟังก์ชันบันทึกข้อมูล (แก้ไขส่วนจัดการรูปภาพ)
        // ============================================
        async function saveSurveyData() {
            const form = document.getElementById('survey-form');
            const formData = new FormData(form);
            
            // ดึงค่าฟอร์ม
            const data = {};
            for (let [key, value] of formData.entries()) {
                // ✅ ข้ามฟิลด์ชั่วคราว (ไม่ส่งไปเซิร์ฟเวอร์)
                if (key.endsWith('_temp')) continue;
                
                const input = form.querySelector(`[name="${key}"]`);
                if (input && input.type === 'checkbox') {
                    data[key] = input.checked ? 'TRUE' : 'FALSE';
                } else if (input && input.type !== 'file') {
                    data[key] = value;
                }
            }
            
            // ดึงพิกัด
            data.lat_long = document.getElementById('latlng-display').innerText;
            
            // ✅ ประกาศตัวแปร
            const markerType = editingMarker._popupData.type;
            const rowKey = editingMarker._popupData.id || editingMarker._popupData._row_num;
            const existingQueueId = editingMarker._popupData.queueId;
            
            // ✅ ตรวจสอบ
            if (!rowKey && !existingQueueId) {
                alert("ไม่พบข้อมูลสำหรับอัปเดต");
                return;
            }
            
            // ============================================
            // จัดการรูปภาพ - ตั้งชื่อไฟล์อัตโนมัติ
            // ============================================
            let imageFilename = null;
            let imageBase64 = null;
            const fileInput = form.querySelector('input[type="file"]');

            if (fileInput && fileInput.files[0]) {
                const file = fileInput.files[0];
                const maxSize = markerType === 'building' ? 1500 : 2000;
                
                // ✅ ตั้งชื่อไฟล์อัตโนมัติจากข้อมูลในฟอร์ม
                const prefix = markerType === 'building' ? 'B' : 'S';
                const code = data.building_c || data.s_code || Date.now().toString().slice(-5);
                const extension = file.name.split('.').pop().toLowerCase();
                
                // ✅ ชื่อไฟล์แบบมาตรฐาน: B00854.jpg หรือ S12345.jpg
                imageFilename = `${prefix}${code}.${extension}`;
                
                // ฟังก์ชันปรับขนาดรูปภาพ (โค้ดเดิม)
                const resizeImage = (file, maxWidth = maxSize, maxHeight = maxSize) => {
                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            const img = new Image();
                            img.onload = () => {
                                let width = img.width;
                                let height = img.height;
                                
                                if (width > height) {
                                    if (width > maxWidth) {
                                        height = Math.round(height * maxWidth / width);
                                        width = maxWidth;
                                    }
                                } else {
                                    if (height > maxHeight) {
                                        width = Math.round(width * maxHeight / height);
                                        height = maxHeight;
                                    }
                                }
                                
                                const canvas = document.createElement('canvas');
                                canvas.width = width;
                                canvas.height = height;
                                const ctx = canvas.getContext('2d');
                                ctx.drawImage(img, 0, 0, width, height);
                                
                                resolve(canvas.toDataURL(file.type, 0.85));
                            };
                            img.onerror = reject;
                            img.src = e.target.result;
                        };
                        reader.onerror = reject;
                        reader.readAsDataURL(file);
                    });
                };
                
                try {
                    let imageDataUrl = await resizeImage(file, maxSize, maxSize);
                    const base64Data = imageDataUrl.split(',')[1];
                    imageBase64 = `${file.type};base64,${base64Data}`;
                    
                    // ✅ บันทึกรูปภาพลง IndexedDB
                    await saveImageToDB(imageBase64, imageFilename, rowKey, markerType);
                    console.log(`✅ รูปภาพบันทึกใน IndexedDB: ${imageFilename}`);
                } catch (err) {
                    console.error('Error resizing image:', err);
                    // Fallback: บันทึกโดยไม่ปรับขนาด
                    try {
                        const arrayBuffer = await file.arrayBuffer();
                        const bytes = [...new Uint8Array(arrayBuffer)];
                        const binary = bytes.map(b => String.fromCharCode(b)).join('');
                        imageBase64 = `${file.type};base64,${btoa(binary)}`;
                        
                        await saveImageToDB(imageBase64, imageFilename, rowKey, markerType);
                        console.log(`⚠️ รูปภาพบันทึกแบบไม่ปรับขนาด: ${imageFilename}`);
                    } catch (fallbackErr) {
                        console.error('Fallback failed:', fallbackErr);
                        showNotificationLeft('⚠️ ไม่สามารถบันทึกรูปภาพได้', 'warning');
                    }
                }
            }

            // เพิ่มข้อมูลรูปภาพลงในข้อมูลคิว
            if (imageFilename && imageBase64) {
                data.imageFilename = imageFilename; // ✅ ชื่อไฟล์ที่ตั้งไว้แล้ว
                data.hasImage = true;
            }
            
            // ✅ ตรวจสอบว่าเป็นจุดชั่วคราวหรือจุดจริง
            let finalQueueId;
            if (existingQueueId) {
                // ✅ เป็นจุดชั่วคราว - อัปเดตรายการเดิมในคิว
                const existingQueueItem = syncQueue.find(q => q.id === existingQueueId);
                if (existingQueueItem) {
                    // อัปเดตข้อมูลในคิวเดิม
                    existingQueueItem.data = { ...existingQueueItem.data, ...data };
                    existingQueueItem.timestamp = new Date().toISOString();
                    saveSyncQueueToStorage();
                    finalQueueId = existingQueueId;
                    console.log(`อัปเดตข้อมูลในคิวเดิม: ${existingQueueId}`);
                } else {
                    // ไม่พบคิวเดิม สร้างใหม่
                    finalQueueId = addToSyncQueue('update', markerType, data, rowKey);
                }
            } else {
                // ✅ เป็นจุดจริง - สร้างคิวใหม่ตามปกติ
                finalQueueId = addToSyncQueue('update', markerType, data, rowKey);
            }
            
            // อัปเดตข้อมูลในมาร์กเกอร์ทันที (แสดงผลทันที)
            editingMarker._popupData = {
                ...editingMarker._popupData,
                ...data,
                queued: true,
                queueId: finalQueueId
            };
            
            setupMarkerPopup(editingMarker, editingMarker._popupData, markerType);
            
            // ปิดหน้าต่าง
            closePanel();
            
            // แสดงแจ้งเตือน
            showNotificationLeft('บันทึกข้อมูลเรียบร้อยแล้ว! (รออัปโหลด)', 'success');
            
            // ✅ เริ่มกระบวนการซิงค์ทันที
            setTimeout(() => {
                console.log('🔄 เริ่มซิงค์คิวข้อมูล...');
                processSyncQueue();
            }, 500);
            
            return { queued: true, queueId: finalQueueId };
        }

        async function processDataSyncQueue() {
            console.log('🔄 เริ่มกระบวนการซิงค์ข้อมูล...');
            console.log('สถานะออนไลน์:', isOnline, 'navigator.onLine:', navigator.onLine);
            console.log('จำนวนรายการในคิวข้อมูล:', dataSyncQueue.length);
            
            if (!isOnline || !navigator.onLine) {
                console.log('❌ ออฟไลน์ - รอการเชื่อมต่อ...');
                return;
            }
            
            if (dataSyncQueue.length === 0) {
                console.log('ℹ️ คิวข้อมูลว่าง - ไม่มีข้อมูลให้อัปโหลด');
                return;
            }
            
            console.log(`📦 เริ่มกระบวนการซิงค์ข้อมูล (${dataSyncQueue.length} รายการ)`);
            console.log('CONFIG.SCRIPT_URL:', CONFIG.SCRIPT_URL);
            
            // ประมวลผลคิวทีละรายการ
            for (let i = 0; i < dataSyncQueue.length; i++) {
                const item = dataSyncQueue[i];
                
                if (item.status === 'success') {
                    console.log(`⏭️ รายการ ${i + 1}: สำเร็จแล้ว (ข้าม)`);
                    continue;
                }
                
                try {
                    console.log(`📤 กำลังประมวลผลรายการ ${i + 1}/${dataSyncQueue.length}: ${item.action}`);
                    console.log('ข้อมูล:', JSON.stringify(item, null, 2));
                    
                    let result;
                    
                    // ✅ แก้ไข: เปลี่ยน 'add' เป็น 'quickAdd'
                    switch (item.action) {
                        case 'add':
                        case 'quickAdd':
                            result = await sendDataWithRetry('quickAdd', item.type, item.data);
                            break;
                        case 'update':
                            result = await sendDataWithRetry('update', item.type, item.data, item.rowKey);
                            break;
                        case 'delete':
                            result = await sendDataWithRetry('delete', item.type, {}, item.rowKey);
                            break;
                        case 'updatePosition':
                            result = await sendDataWithRetry('updatePosition', item.type, item.data, item.rowKey);
                            break;
                        default:
                            console.warn(`⚠️ ไม่รู้จัก action: ${item.action}`);
                            continue;
                    }
                    
                    console.log(`📊 ผลลัพธ์รายการ ${i + 1}:`, result);
                    
                    // ✅ ตรวจสอบว่าเซิร์ฟเวอร์ตอบกลับสำเร็จจริงๆ
                    if (result && (result.success || (result.data && result.data.status === 200))) {
                        console.log(`✅ รายการ ${i + 1} สำเร็จ`);
                        
                        // อัปเดตสถานะในคิว
                        item.status = 'success';
                        item.syncedAt = new Date().toISOString();
                        
                        // บันทึกคิวลงใน localStorage
                        saveDataSyncQueueToStorage();
                        
                        // แสดงแจ้งเตือน
                        showNotificationLeft(`อัปโหลดข้อมูลสำเร็จ (${i + 1}/${dataSyncQueue.length})`, 'success');
                        
                    } else {
                        console.warn(`⚠️ รายการ ${i + 1} ล้มเหลว - รอลองใหม่`);
                        console.log('ผลลัพธ์:', result);
                        
                        item.retryCount = (item.retryCount || 0) + 1;
                        
                        if (item.retryCount >= 3) {
                            item.status = 'failed';
                            console.error(`❌ รายการ ${i + 1} ล้มเหลวเกิน 3 ครั้ง`);
                        }
                        
                        // บันทึกคิวลงใน localStorage
                        saveDataSyncQueueToStorage();
                        
                        // หยุดกระบวนการชั่วคราว
                        break;
                    }
                    
                    // รอ 500ms ระหว่างการอัปโหลดแต่ละรายการ
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                } catch (err) {
                    console.error(`❌ ข้อผิดพลาดในการประมวลผลรายการ ${i + 1}:`, err);
                    console.error('Stack trace:', err.stack);
                    
                    item.retryCount = (item.retryCount || 0) + 1;
                    
                    if (item.retryCount >= 3) {
                        item.status = 'failed';
                    }
                    
                    // บันทึกคิวลงใน localStorage
                    saveDataSyncQueueToStorage();
                    
                    // หยุดกระบวนการชั่วคราว
                    break;
                }
            }
            
            // ลบรายการที่สำเร็จแล้วออกจากคิว
            const successItems = dataSyncQueue.filter(item => item.status === 'success');
            for (const item of successItems) {
                removeFromDataSyncQueue(item.id);
            }
            
            // โหลดคิวใหม่จาก localStorage
            loadDataSyncQueueFromStorage();
            
            console.log(`✅ กระบวนการซิงค์ข้อมูลเสร็จสิ้น - คงเหลือ ${dataSyncQueue.length} รายการ`);
            
            // ถ้ายังมีรายการเหลืออยู่ ให้ลองซิงค์อีกครั้งหลังจาก 5 วินาที
            if (dataSyncQueue.length > 0) {
                console.log('⏳ มีรายการเหลืออยู่ - จะลองซิงค์อีกครั้งใน 5 วินาที');
                setTimeout(() => {
                    processDataSyncQueue();
                }, 5000);
            }
        }

        // แก้ไขฟังก์ชัน updateMarkerPosition
        async function updateMarkerPosition(marker, data, newLatLng) {
            const refreshBtn = document.getElementById('btn-refresh');
            const refreshIcon = document.getElementById('refresh-icon');
            
            disableRefreshButton();
            refreshIcon.classList.add('animate-spin');
            
            const oldLatLng = data.lat_long;
            const newLatLngStr = `${newLatLng.lat.toFixed(6)}, ${newLatLng.lng.toFixed(6)}`;
            const rowKey = data._row_num || data.id;
            const type = data.type || (data.building_c ? 'building' : 'sign');
            
            if (!rowKey) {
                alert("ไม่พบข้อมูลสำหรับอัปเดต");
                refreshIcon.classList.remove('animate-spin');
                enableRefreshButton();
                return;
            }
            
            // ✅ เพิ่มลงในรายการจุดที่กำลังถูกย้าย
            markersBeingMoved.add(rowKey);
            
            // แสดงจุดชั่วคราว
            const tempMarker = createCircleMarker(newLatLng, type);
            tempMarker._popupData = {
                ...data,
                lat_long: newLatLngStr,
                tempMarker: true,
                tempMarkerId: `temp_${rowKey}`
            };
            setupMarkerPopup(tempMarker, tempMarker._popupData, type);
            tempMarker.addTo(surveyLayers);
            
            // ✅ ซ่อนจุดจริงทั้งหมดที่มี _row_num เดียวกัน
            surveyLayers.eachLayer(layer => {
                if (layer._popupData) {
                    const layerId = layer._popupData._row_num || layer._popupData.id;
                    if (layerId === rowKey && !layer._popupData.tempMarker) {
                        surveyLayers.removeLayer(layer);
                    }
                }
            });
            
            // ตรวจสอบสถานะออนไลน์
            if (!isOnline || !navigator.onLine) {
                const queueId = addToSyncQueue('updatePosition', type, { lat_long: newLatLngStr }, rowKey);
                data.lat_long = newLatLngStr;
                if (marker) marker._popupData.lat_long = newLatLngStr;
                setupMarkerPopup(tempMarker, data, type);
                refreshIcon.classList.remove('animate-spin');
                enableRefreshButton();
                
                // ลบออกจากรายการ (เพราะยังไม่ได้อัปเดตจริง)
                markersBeingMoved.delete(rowKey);
                
                console.log(`อัปเดตตำแหน่งไว้ในมือถือ (รอซิงค์): ${queueId}`);
                return;
            }
            
            const body = new URLSearchParams();
            body.append('action', 'updatePosition');
            body.append('type', type);
            body.append('rowKey', rowKey);
            body.append('lat_long', newLatLngStr);
            
            try {
                const res = await fetch(CONFIG.SCRIPT_URL.trim(), { method: 'POST', body });
                
                if (res.ok) {
                    // ✅ โหลดข้อมูลใหม่ (จุดจริงจะถูกสร้างทันที พร้อมจุดชั่วคราว)
                    await loadExistingData();
                    
                    // ⏱️ รอ 1 วินาที ให้แน่ใจว่าจุดจริงเรนเดอร์เสร็จแล้ว
                    setTimeout(() => {
                        // ลบจุดชั่วคราว
                        surveyLayers.eachLayer(layer => {
                            if (layer._popupData && layer._popupData.tempMarkerId === `temp_${rowKey}`) {
                                surveyLayers.removeLayer(layer);
                            }
                        });
                        
                        markersBeingMoved.delete(rowKey);
                        
                        refreshIcon.classList.remove('animate-spin');
                        refreshBtn.classList.add('refresh-success');
                        setTimeout(() => {
                            refreshBtn.classList.remove('refresh-success');
                            enableRefreshButton();
                        }, 2000);
                        
                        showNotificationLeft('อัปเดตตำแหน่งสำเร็จ!', 'success');
                    }, 5000); // รอ 1 วินาที
                    
                } else {
                    throw new Error("อัปเดตตำแหน่งไม่สำเร็จ");
                }
            } catch (err) {
                // หากเกิดข้อผิดพลาด ให้คืนค่าจุดเดิม
                surveyLayers.removeLayer(tempMarker);
                if (marker) {
                    marker.setLatLng(L.latLng(oldLatLng.split(',').map(Number)));
                    marker.addTo(surveyLayers);
                }
                
                refreshIcon.classList.remove('animate-spin');
                enableRefreshButton();
                
                // ลบออกจากรายการ (เพราะล้มเหลว)
                markersBeingMoved.delete(rowKey);
                
                console.error("Error updating position:", err);
                
                // หากเกิดข้อผิดพลาด ให้เก็บข้อมูลไว้ในคิวแทน
                const queueId = addToSyncQueue('updatePosition', type, { lat_long: newLatLngStr }, rowKey);
                data.lat_long = newLatLngStr;
                if (marker) marker._popupData.lat_long = newLatLngStr;
                setupMarkerPopup(marker, data, type);
                console.log(`อัปเดตตำแหน่งไว้ในมือถือ (รอซิงค์): ${queueId}`);
            }
        }

        // ข้อ 3: ตั้งค่าป๊อปอัปเพื่อเปิดฟอร์ม (แก้ไขเพิ่มปุ่มลบ + แก้ไขป๊อบอัปไม่ปิดอัตโนมัติ)
        function setupMarkerPopup(marker, data, type) {
            const popupDiv = document.createElement('div');
            popupDiv.className = "p-1 min-w-[160px]";
            popupDiv.innerHTML = `
            <p class="font-bold text-sm text-blue-900">${type === 'building' ? 'สิ่งปลูกสร้าง' : 'ป้าย'}</p>
            <p class="text-[10px] text-gray-500">${data.lat_long}</p>
            <div class="mt-2 space-y-2">  <!-- เพิ่มระยะห่างระหว่างปุ่ม -->
                <button class="w-full bg-blue-600 text-white text-[11px] py-3 rounded font-bold shadow-sm active:bg-blue-700 hover:bg-blue-700 transition">แก้ข้อมูล</button>
                <button class="w-full bg-red-600 text-white text-[11px] py-3 rounded font-bold shadow-sm active:bg-red-700 hover:bg-red-700 transition">ลบจุด</button>
            </div>
          `;
          
          // ✅ แก้ไขหลัก: ปิด autoPan + ไม่แพนแผนที่อัตโนมัติ
          marker.bindPopup(popupDiv, {
            minWidth: 190,
            maxWidth: 220,
            autoPan: false, // ✅ ปิดการแพนอัตโนมัติ (สำคัญมาก!)
            closeOnClick: true // ใช้ค่าเริ่มต้น (ปิดเมื่อคลิกนอกป๊อปอัป)
          });
          
          marker._popupData = { ...data, type: type };
          
          // ✅ ลบโค้ด setTimeout + panTo ทั้งหมดออก!
          // เหลือเฉพาะการผูกปุ่ม
        marker.on('popupopen', () => {
            const buttons = marker.getPopup().getElement().querySelectorAll('button');
            buttons[0].onclick = (e) => {
                e.stopPropagation();
                openEditPanel(marker._popupData, marker._popupData.type, marker); // ✅ แก้ไขตรงนี้
            };
            buttons[1].onclick = (e) => {
                e.stopPropagation();
                showDeleteConfirm(marker, marker._popupData, marker._popupData.type);
            };
        });
        }

        // ฟังก์ชันลบจุดและข้อมูลจาก Google Sheets (ข้อ 1)
        // แก้ไขฟังก์ชัน deleteMarker
        async function deleteMarker(marker, data, type) {
            const refreshBtn = document.getElementById('btn-refresh');
            const refreshIcon = document.getElementById('refresh-icon');
            
            // ปิดการใช้งานปุ่ม
            disableRefreshButton();
            refreshIcon.classList.add('animate-spin');
            
            // แสดงแจ้งเตือนว่ากำลังลบ (ฝั่งซ้าย)
            const deletingMsg = document.createElement('div');
            deletingMsg.className = 'fixed top-4 left-4 bg-blue-500 text-white px-6 py-3 rounded-lg shadow-lg z-[2000] animate-fade-in';
            deletingMsg.innerHTML = '<i data-lucide="loader" class="w-5 h-5 inline mr-2 animate-spin"></i>กำลังลบข้อมูล...';
            document.body.appendChild(deletingMsg);
            
            const rowKey = data._row_num || data.id;
            
            if (!rowKey) {
                alert("ไม่พบข้อมูลสำหรับลบ");
                refreshIcon.classList.remove('animate-spin');
                enableRefreshButton();
                deletingMsg.classList.add('animate-fade-out');
                setTimeout(() => deletingMsg.remove(), 300);
                return;
            }
            
            const body = new URLSearchParams();
            body.append('action', 'delete');
            body.append('type', type);
            body.append('rowKey', rowKey);
            
            try {
                const res = await fetch(CONFIG.SCRIPT_URL.trim(), { method: 'POST', body });
                
                if (res.ok) {
                    // ซ่อนข้อความ "กำลังลบ"
                    deletingMsg.classList.add('animate-fade-out');
                    setTimeout(() => deletingMsg.remove(), 300);
                    
                    // แสดงแจ้งเตือนสำเร็จ (ฝั่งซ้าย)
                    const successMsg = document.createElement('div');
                    successMsg.className = 'fixed top-4 left-4 bg-green-500 text-white px-6 py-3 rounded-lg shadow-lg z-[2000] animate-fade-in';
                    successMsg.innerHTML = '<i data-lucide="check-circle" class="w-5 h-5 inline mr-2"></i>ลบข้อมูลเรียบร้อยแล้ว!';
                    document.body.appendChild(successMsg);
                    
                    setTimeout(() => {
                        successMsg.classList.add('animate-fade-out');
                        setTimeout(() => successMsg.remove(), 300);
                    }, 500);
                    
                    surveyLayers.removeLayer(marker);
                    await loadExistingData();
                    
                    refreshIcon.classList.remove('animate-spin');
                    refreshBtn.classList.add('refresh-success');
                    setTimeout(() => {
                        refreshBtn.classList.remove('refresh-success');
                        enableRefreshButton();
                    }, 500);
                    
                    console.log("ลบข้อมูลเรียบร้อยแล้ว");
                } else {
                    throw new Error("ลบข้อมูลไม่สำเร็จ");
                }
            } catch (err) {
                // ซ่อนข้อความ "กำลังลบ"
                deletingMsg.classList.add('animate-fade-out');
                setTimeout(() => deletingMsg.remove(), 300);
                
                refreshIcon.classList.remove('animate-spin');
                enableRefreshButton();
                console.error("Error deleting marker:", err);
                
                // แสดงแจ้งเตือนข้อผิดพลาด (ฝั่งซ้าย)
                const errorMsg = document.createElement('div');
                errorMsg.className = 'fixed top-4 left-4 bg-red-500 text-white px-6 py-3 rounded-lg shadow-lg z-[2000] animate-fade-in';
                errorMsg.innerHTML = '<i data-lucide="alert-circle" class="w-5 h-5 inline mr-2"></i>เกิดข้อผิดพลาดในการลบ!';
                document.body.appendChild(errorMsg);
                
                setTimeout(() => {
                    errorMsg.classList.add('animate-fade-out');
                    setTimeout(() => errorMsg.remove(), 300);
                }, 500);
                
                throw err;
            }
        }


        function openEditPanel(data, type, marker) {
            editingMarker = marker;
            const form = document.getElementById('survey-form');
            document.getElementById('latlng-display').innerText = data.lat_long;
            document.getElementById('panel-title').innerText = type === 'building' ? 'รายละเอียดสิ่งปลูกสร้าง' : 'รายละเอียดป้าย';
            
            const buildingFields = [
                { id: 'image', label: 'รูปสิ่งปลูกสร้าง', type: 'file', icon: 'camera' },
                { id: 'full_name', label: 'เจ้าของ', type: 'text' },
                { id: 'address', label: 'ที่อยู่', type: 'text' },
                { id: 'building_c', label: 'รหัสสิ่งปลูกสร้าง', type: 'text' },
                { id: 'b_type', label: 'ประเภทสิ่งปลูกสร้าง', type: 'select', options: [ '000-ไม่ระบุ', '101-บ้านพักอาศัยไม้ชั้นเดียว', '102-บ้านพักอาศัยไม้ชั้นเดียวใต้ถุนสูง', '103-บ้านพักอาศัยตึกชั้นเดียว', '104-บ้านพักอาศัยไม้สองชั้น', '105-บ้านพักอาศัยตึกสองชั้น', '106-บ้านพักอาศัยครึ่งตึกครึ่งไม้สองชั้น', '107-บ้านพักอาศัยตึกสามชั้น', '108-บ้านพักอาศัยแฝดตึกสองชั้น', '109-บ้านพักอาศัยแฝดตึกสามชั้น', '110-บ้านทรงไทยไม้ชั้นเดียวใต้ถุนสูง', '111-บ้านทรงไทยครึ่งตึกครึ่งไม้สองชั้น', '112-บ้านพักอาศัยแฝดตึกชั้นเดียว', '201-บ้านแถว ทาวน์เฮาส์) ชั้นเดียว', '202-บ้านแถว ทาวน์เฮาส์) สองชั้น', '203-บ้านแถว ทาวน์เฮาส์) สามชั้น', '204-บ้านแถว ทาวน์เฮาส์) สี่ชั้น', '301-ห้องแถวไม้ชั้นเดียว', '302-ห้องแถวไม้สองชั้น', '303-ห้องแถวครึ่งตึกครึ่งไม้สองชั้น', '401-ตึกแถวชั้นเดียว', '402-ตึกแถวสองชั้น', '403-ตึกแถวสองชั้นครึ่ง', '404-ตึกแถวสามชั้น', '405-ตึกแถวสามชั้นครึ่ง', '406-ตึกแถวสี่ชั้น', '407-ตึกแถวสี่ชั้นครึ่ง', '408-ตึกแถวห้าชั้น', '409-ตึกแถวหกชั้น', '501-คลังสินค้า พื้นที่ไม่เกิน 300 ตารางเมตร', '502-คลังสินค้าพื้นที่เกินกว่า 300 ตารางเมตรขึ้นไป', '503-เรือนคนใช้ /ครัว', '504-โรงจอดรถ', '505-สถานศึกษา', '506/1-โรงแรม ความสูงไม่เกิน 5 ชั้น', '506/2-โรงแรม ความสูงเกินกว่า 5 ชั้นขึ้นไป', '507-โรงมหรสพ', '508-สถานพยาบาล', '509/1-สำนักงาน ความสูงไม่เกิน 5 ชั้น', '509/2-สำนักงาน ความสูงเกินกว่า 5 ชั้นขึ้นไป', '510-ภัตตาคาร', '511/1-ห้างสรรพสินค้า', '511/2-อาคารพาณิชยกรรม ประเภทค้าปลีกค้าส่ง', '512-สถานีบริการน้ำมันเชื้อเพลิง', '513-โรงงาน', '514-ตลาด พื้นที่ไม่เกิน 1,000 ตารางเมตร', '515-ตลาด พื้นที่เกินกว่า 1,000 ตารางเมตรขึ้นไป', '516-อาคารพาณิชย์ ประเภทโฮมออฟฟิศ', '517-โรงเลี้ยงสัตว์', '518-โรงงานซ่อมรถยนต์', '519-อาคารจอดรถ', '520/1-อาคารอยู่อาศัยรวม ความสูงไม่เกิน 5 ชั้น', '520/2-อาคารอยู่อาศัยรวม ความสูงเกินกว่า 5 ชั้นขึ้นไป', '521-ป้อมยาม', '522-อาคารพาณิชย์ ประเภทโชว์รูมรถยนต์', '523-ห้องน้ำรวม', '601-รั้วคอนกรีต', '602-รั้วลวดหนาม', '603-รั้วสังกะสี', '604-รั้วลวดถัก', '605-รั้วไม้', '606-รั้วเหล็กดัด', '607-รั้วอัลลอยด์', '608-สระว่ายน้ำ', '609-ลานกีฬาอเนกประสงค์', '610-ถนนคอนกรีต', '611-ลานคอนกรีต', '612-ถนนลาดยาง', '613-ป้ายโฆษณา', '614-ท่าเทียบเรือ'] },
                { id: 'b_mat', label: 'วัสดุ', type: 'select', options: ['ไม้', 'ตึก', 'ตึก/ไม้'] },
                { id: 'b_year', label: 'อายุ (ปี)', type: 'select', options: [1, 2, 3, 5, 7, 10, 15, 20, 25, 30, 35, 40, 45, 50, 70, 80, 100], allowCustom: true },
                { id: 'hs_no', label: 'บ้านเลขที่', type: 'text' },
                { id: 'hs_moo', label: 'หมู่', type: 'select', options: ['', 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]},
                { id: 'no_floor', label: 'จำนวนชั้น', type: 'select', options: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], defaultValue: 1 },
                { id: 'b_area', label: 'พื้นที่ทั้งหลัง (ตร.ม.)', type: 'number' },
                { id: 'b_note', label: 'รายละเอียด', type: 'select', options: ['ยุ้งข้าว', 'คอกวัว', 'เล้าไก่', 'คอกหมู', 'โรงจอดรถ', 'ห้องน้ำ', 'ร้านค้าของชำ', 'กระท่อมนา', 'เพิงพัก', 'โรงเก็บของ', 'เก็บฟาง', 'โรงครัว', 'ศาลาพักผ่อน', 'ตู้เติมเงิน', 'ตู้น้ำมันหยอดเหรียญ', 'ตู้น้ำดื่มหยอดเหรียญ', 'รื้อ'], allowCustom: true },
                // ✅ กลุ่มที่ 1 - สีเขียว
                { id: 'b_use', label: 'ใช้ประโยชน์', type: 'select', options: ['', '1-เกษตรกรรม', '2-(1)ที่อยู่อาศัย หลังหลัก', '2-(2)ที่อยู่อาศัย หลังหลักกรณีไม่ได้เป็นเจ้าของกรรมสิทธิ์ที่ดิน)', '2-(3)ที่อยู่อาศัย หลังอื่นๆ เช่น กรณีให้เช่าอยู่อาศัย หรือแบ่งพื้นที่ให้เช่าอยู่อาศัย', '3-อื่นๆ ไม่ใช่เกษตรกรรมหรือที่อยู่อาศัย)', '4-ทิ้งไว้ว่างเปล่า/รกร้าง', '5-ใช้ประโยชน์หลายประเภท'], customClass: 'bg-custom-green' },
                { id: 'per_use', label: 'การเช่า', type: 'select', options: ['ใช้ประโยชน์เอง', 'ให้เช่า', 'ผู้อื่นใช้'], customClass: 'bg-custom-green' },
                { id: 'full_area', label: 'ใช้ทั้งหลัง', type: 'select', options: ['', 'เต็มพื้นที่', 'บางส่วน'], customClass: 'bg-custom-green' },
                { id: 'buse_floor', label: 'ชั้นที่ใช้', type: 'select', options: ['1-1', '1-2', '1-3', '1-4', '1-5'], allowCustom: true, defaultValue: '1-1', customClass: 'bg-custom-green' },
                { id: 'buse_area', label: 'พื้นที่ใช้ (ตร.ม.)', type: 'number', customClass: 'bg-custom-green' },
                { id: 'ment_use', label: 'รายละเอียด', type: 'select', options: ['ยุ้งข้าว', 'คอกวัว', 'เล้าไก่', 'คอกหมู', 'โรงจอดรถ', 'ห้องน้ำ', 'ร้านค้าของชำ', 'กระท่อมนา', 'เพิงพัก', 'โรงเก็บของ', 'เก็บฟาง', 'โรงครัว', 'ศาลาพักผ่อน', 'ตู้เติมเงิน', 'ตู้น้ำมันหยอดเหรียญ', 'ตู้น้ำดื่มหยอดเหรียญ', 'รื้อ'], allowCustom: true, customClass: 'bg-custom-green' },
                
                // ✅ กลุ่มที่ 2 - สีชมพู
                { id: 'b_use2', label: 'ใช้ประโยชน์ (2)', type: 'select', options: ['', '1-เกษตรกรรม', '2-(1)ที่อยู่อาศัย หลังหลัก', '2-(2)ที่อยู่อาศัย หลังหลักกรณีไม่ได้เป็นเจ้าของกรรมสิทธิ์ที่ดิน)', '2-(3)ที่อยู่อาศัย หลังอื่นๆ เช่น กรณีให้เช่าอยู่อาศัย หรือแบ่งพื้นที่ให้เช่าอยู่อาศัย', '3-อื่นๆ ไม่ใช่เกษตรกรรมหรือที่อยู่อาศัย)', '4-ทิ้งไว้ว่างเปล่า/รกร้าง', '5-ใช้ประโยชน์หลายประเภท'], customClass: 'bg-custom-pink' },
                { id: 'per_use2', label: 'การเช่า (2)', type: 'select', options: ['ใช้ประโยชน์เอง', 'ให้เช่า', 'ผู้อื่นใช้'], customClass: 'bg-custom-pink' },
                { id: 'buse_flor2', label: 'ชั้นที่ใช้ (2)', type: 'select', options: ['', '1-1', '1-2', '1-3', '1-4', '1-5'], allowCustom: true, customClass: 'bg-custom-pink' },
                { id: 'buse_area2', label: 'พื้นที่ใช้ (2) (ตร.ม.)', type: 'number', customClass: 'bg-custom-pink' },
                { id: 'ment_use2', label: 'รายละเอียด (2)', type: 'select', options: ['ยุ้งข้าว', 'คอกวัว', 'เล้าไก่', 'คอกหมู', 'โรงจอดรถ', 'ห้องน้ำ', 'ร้านค้าของชำ', 'กระท่อมนา', 'เพิงพัก', 'โรงเก็บของ', 'เก็บฟาง', 'โรงครัว', 'ศาลาพักผ่อน', 'ตู้เติมเงิน', 'ตู้น้ำมันหยอดเหรียญ', 'ตู้น้ำดื่มหยอดเหรียญ', 'รื้อ'], allowCustom: true, customClass: 'bg-custom-pink' },
                { id: 'full_area2', label: 'ใช้ทั้งหลัง (2)', type: 'select', options: ['', 'บางส่วน'], customClass: 'bg-custom-pink' },
                
                // ✅ สถานะการตรวจสอบ - สีเขียว
                { id: 'check', label: 'สถานะการตรวจสอบ', type: 'select', options: ['ยังไม่สำรวจ', 'ถ่ายรูปแล้ว', 'ตรวจสอบแล้ว'], customClass: 'bg-custom-check-status' }
            ];

            
            const signFields = [
                { id: 'image', label: 'รูปป้าย', type: 'file', icon: 'camera' },
                { id: 's_code', label: 'รหัสป้าย', type: 'text' },
                { id: 's_name', label: 'ชื่อกิจการ', type: 'text' },
                { id: 's_type', label: 'ประเภทป้าย', type: 'select', options: ['ป้าย/แสดงโฆษณาทั่วไป', 'ป้าย/ป้ายภายในอาคาร 3 ตร.ม. ขึ้นไป', 'ป้ายตามกฎหมายทะเบียนพาณิชย์'] },
                { id: 's_wide', label: 'กว้าง (ซ.ม.)', type: 'number' },
                { id: 's_length', label: 'ยาว (ซ.ม.)', type: 'number' },
                { id: 'no_side', label: 'จำนวนด้าน', type: 'select', options: [1, 2], defaultValue: 1 },
                // ✅ เพิ่ม 2 ฟิลด์ชั่วคราว (ไม่บันทึกลงชีท)
                { 
                    id: 'content_type_temp', 
                    label: 'ลักษณะเนื้อหา', 
                    type: 'select', 
                    options: ['1.ไทยล้วน', '2.ไทยอยู่บนสุด', '3.ไม่มีไทย', '3.ไทยไม่อยู่บนสุด'],
                    tempField: true // หมายเหตุ: ฟิลด์นี้ไม่บันทึกลงชีท
                },
                { 
                    id: 'sign_type_detail_temp', 
                    label: 'ลักษณะตัวป้าย', 
                    type: 'select', 
                    options: ['(ข) ทั่วไป', '(ก) จอ LED', '(ก) มอเตอร์/เคลื่อนไหว'],
                    tempField: true // หมายเหตุ: ฟิลด์นี้ไม่บันทึกลงชีท
                },
                // ✅ ฟิลด์ "ลักษณะ" แบบอ่านอย่างเดียว (สร้างอัตโนมัติ)
                { 
                    id: 's_characte', 
                    label: 'ลักษณะ', 
                    type: 'text',
                    readonly: true,
                    description: 'ค่านี้สร้างอัตโนมัติจาก 2 ฟิลด์ด้านบน'
                },
                { id: 's_text', label: 'ข้อความ', type: 'text' },
                { id: 'comment', label: 'หมายเหตุ', type: 'text' },
                { id: 'fullname', label: 'เจ้าของ', type: 'text' },
                { id: 'address', label: 'ที่อยู่', type: 'text' },
                { id: 'check', label: 'สถานะการตรวจสอบ', type: 'select', options: ['ยังไม่สำรวจ', 'ถ่ายรูปแล้ว', 'ตรวจสอบแล้ว'], customClass: 'bg-custom-check-status' }
            ];
            
            const fields = type === 'building' ? buildingFields : signFields;
            let html = '';
            fields.forEach(f => {
                html += `<div class="mb-2">`;
                
                // ✅ สร้าง <label> เฉพาะฟิลด์ที่ไม่ใช่ 'file'
                if (f.type !== 'file') {
                    html += `<label class="form-label">${f.label}</label>`;
                }
                
                // ✅ ตรวจสอบฟิลด์ "สถานะการตรวจสอบ" และตั้งค่าอัตโนมัติถ้ามีรูปภาพ
                let fieldValue = data[f.id] || '';
                if (f.id === 'check' && type === 'building' && data.image && data.image.trim() !== '') {
                    fieldValue = 'ถ่ายรูปแล้ว';
                } else if (f.id === 'check' && type === 'sign' && data.picture && data.picture.trim() !== '') {
                    fieldValue = 'ถ่ายรูปแล้ว';
                }
                
                if (f.type === 'textarea') {
                    const customClass = f.customClass || '';
                    html += `<textarea name="${f.id}" class="form-input ${customClass}" rows="2"${f.readonly ? ' readonly' : ''}>${fieldValue}</textarea>`;
                } else if (f.type === 'file') {
                    html += `<div class="mb-2">
                        <div class="mb-3">
                            <label class="form-label flex items-center gap-1">
                                <i data-lucide="camera" class="w-3 h-3"></i>
                                ${f.label}
                            </label>
                            <input type="file" name="${f.id}" accept="image/*" capture="environment" class="hidden">
                            <button type="button" onclick="this.previousElementSibling.click()" 
                                class="w-full bg-gradient-to-r from-blue-500 to-blue-600 text-white py-2 px-2 rounded-md font-semibold text-sm shadow-sm hover:from-blue-600 hover:to-blue-700 transition-all flex items-center justify-center gap-1">
                                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M14.5 4h-4L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-3.5-3z"></path>
                                    <circle cx="12" cy="13" r="3"></circle>
                                    <path d="M12 10v3l1.5 1.5"></path>
                                </svg>
                                <span>เปิดกล้อง</span>
                            </button>
                            <span id="filename-${f.id}" class="text-[10px] text-gray-600 mt-1 px-2 py-0.5 bg-gray-100 rounded-full hidden"></span>
                        </div>
                    </div>`;
                } else if (f.type === 'select') {
                    const customClass = f.customClass || '';
                    if (f.allowCustom) {
                        const value = fieldValue !== undefined && fieldValue !== null && fieldValue !== '' ? fieldValue : (f.defaultValue !== undefined ? f.defaultValue : '');
                        html += `<input type="text" name="${f.id}" class="form-input ${customClass}" list="${f.id}-options" value="${value}">`;
                        html += `<datalist id="${f.id}-options">`;
                        f.options.forEach(opt => {
                            html += `<option value="${opt}">${opt}</option>`;
                        });
                        html += `</datalist>`;
                    } else {
                        const value = fieldValue !== undefined && fieldValue !== null && fieldValue !== '' ? fieldValue : (f.defaultValue !== undefined ? f.defaultValue : '');
                        html += `<select name="${f.id}" class="form-input ${customClass}">`;
                        f.options.forEach(opt => {
                            const selected = String(value) === String(opt) ? 'selected' : '';
                            html += `<option value="${opt}" ${selected}>${opt}</option>`;
                        });
                        html += `</select>`;
                    }
                } else {
                    const customClass = f.customClass || '';
                    html += `<input type="${f.type}" name="${f.id}" class="form-input ${customClass}" value="${fieldValue}"${f.readonly ? ' readonly' : ''}>`;
                }
                html += `</div>`;
            });
            
            form.innerHTML = html;
            // ✅ เพิ่มหลังจาก form.innerHTML = html; ในฟังก์ชัน openEditPanel()
            if (type === 'sign') {
                // ฟังก์ชันอัปเดตค่า s_characte อัตโนมัติ
                const updateSCharacte = () => {
                    const contentTypeEl = document.querySelector('select[name="content_type_temp"]');
                    const signTypeDetailEl = document.querySelector('select[name="sign_type_detail_temp"]');
                    const sCharacteEl = document.querySelector('input[name="s_characte"]');
                    
                    if (!contentTypeEl || !signTypeDetailEl || !sCharacteEl) return;
                    
                    const num = contentTypeEl.value.charAt(0); // ดึงเลขหน้าสุด (1, 2, 3, 4)
                    const letterMatch = signTypeDetailEl.value.match(/\(([^)]+)\)/); // ดึงตัวอักษรในวงเล็บ
                    const letter = letterMatch ? letterMatch[1].charAt(0) : ''; // เอาแค่ตัวแรก (ก หรือ ข)
                    
                    sCharacteEl.value = num && letter ? `${num}(${letter})` : '-';
                };
                
                // ผูกเหตุการณ์เมื่อเลือกค่า
                const contentTypeEl = document.querySelector('select[name="content_type_temp"]');
                const signTypeDetailEl = document.querySelector('select[name="sign_type_detail_temp"]');
                
                if (contentTypeEl && signTypeDetailEl) {
                    contentTypeEl.addEventListener('change', updateSCharacte);
                    signTypeDetailEl.addEventListener('change', updateSCharacte);
                    
                    // ตั้งค่าเริ่มต้นจากข้อมูลเดิม (ถ้ามี)
                    if (data.s_characte) {
                        const match = data.s_characte.match(/^(\d)\(([^)]+)\)$/);
                        if (match) {
                            const num = match[1];
                            const letter = match[2];
                            
                            // ตั้งค่าลักษณะเนื้อหา
                            for (let opt of contentTypeEl.options) {
                                if (opt.value.startsWith(`${num}.`)) {
                                    contentTypeEl.value = opt.value;
                                    break;
                                }
                            }
                            
                            // ตั้งค่าลักษณะตัวป้าย
                            for (let opt of signTypeDetailEl.options) {
                                if (opt.value.includes(`(${letter})`)) {
                                    signTypeDetailEl.value = opt.value;
                                    break;
                                }
                            }
                        }
                    }
                    
                    // อัปเดตค่าเริ่มต้น
                    updateSCharacte();
                }
            }
            document.getElementById('side-panel').classList.add('open');
            marker.closePopup();
        }

        function closePanel() { document.getElementById('side-panel').classList.remove('open'); }

        function locateUser() { 
            map.locate({setView: true, maxZoom: 18}); 
            map.once('locationfound', (e) => {
                L.circleMarker(e.latlng, { radius: 8, fillColor: '#2563eb', color: '#fff', weight: 3, fillOpacity: 0.9 }).addTo(map);
            });
        }
        // ตัวแปรเก็บข้อมูลสำหรับการลบ
        let deleteMarkerData = null;
        let deleteMarkerType = null;
        let deleteMarkerRef = null;

        // เปิดหน้าต่างยืนยันการลบ
        function showDeleteConfirm(marker, data, type) {
            deleteMarkerRef = marker;
            deleteMarkerData = data;
            deleteMarkerType = type;
            
            const title = document.getElementById('delete-modal-title');
            const message = document.getElementById('delete-modal-message');
            
            if (type === 'building') {
                title.textContent = 'ลบสิ่งปลูกสร้าง';
                message.textContent = 'คุณแน่ใจว่าต้องการลบสิ่งปลูกสร้างนี้? การกระทำนี้ไม่สามารถยกเลิกได้';
            } else {
                title.textContent = 'ลบป้าย';
                message.textContent = 'คุณแน่ใจว่าต้องการลบป้ายนี้? การกระทำนี้ไม่สามารถยกเลิกได้';
            }
            
            document.getElementById('confirm-delete-modal').classList.remove('hidden');
            document.getElementById('confirm-delete-modal').classList.add('flex');
        }

        // ปิดหน้าต่างยืนยันการลบ
        function cancelDelete() {
            document.getElementById('confirm-delete-modal').classList.add('hidden');
            deleteMarkerData = null;
            deleteMarkerType = null;
            deleteMarkerRef = null;
        }

        // ยืนยันการลบ
        async function confirmDeleteAction() {
            if (!deleteMarkerRef || !deleteMarkerData || !deleteMarkerType) {
                cancelDelete();
                return;
            }
            
            // ปิดหน้าต่างยืนยัน
            document.getElementById('confirm-delete-modal').classList.add('hidden');
            
            try {
                await deleteMarker(deleteMarkerRef, deleteMarkerData, deleteMarkerType);
            } catch (err) {
                console.error("Error in delete action:", err);
            } finally {
                cancelDelete();
            }
        }

        // เปิดหน้าต่างโหมดแก้ไข
        function showEditModeModal() {
            document.getElementById('edit-mode-modal').classList.remove('hidden');
            document.getElementById('edit-mode-modal').classList.add('flex');
            
            // ปิดอัตโนมัติหลัง 3 วินาที
            setTimeout(() => {
                closeEditModeModal();
            }, 4000);
        }

        // ปิดหน้าต่างโหมดแก้ไข
        function closeEditModeModal() {
            document.getElementById('edit-mode-modal').classList.add('hidden');
        }

        // ฟังก์ชันสำหรับแสดง/ซ่อนตาราง
        function toggleTable() {
            const panel = document.getElementById('data-table-panel');
            const btn = document.getElementById('btn-show-table');
            const icon = document.getElementById('table-icon');
            
            panel.classList.toggle('open');
            
            if (panel.classList.contains('open')) {
                btn.innerHTML = '<i data-lucide="x" class="w-6 h-6 text-red-600"></i>';
            } else {
                btn.innerHTML = '<i data-lucide="table" class="w-6 h-6 text-blue-600"></i>';
            }
            
            lucide.createIcons();
        }

        // ฟังก์ชันสลับแท็บตาราง
        function switchTableTab(type) {
            // เปลี่ยนแท็บ
            document.querySelectorAll('.table-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // แสดงตารางที่เลือก
            document.getElementById('building-table-container').classList.toggle('hidden', type !== 'building');
            document.getElementById('sign-table-container').classList.toggle('hidden', type !== 'sign');
        }

        // ฟังก์ชันซูมไปที่ตำแหน่ง
        function zoomToLocation(latlng, zoomLevel = 18) {
            map.setView(latlng, zoomLevel);
            
            // สร้างเอฟเฟกต์กระพริบ
            const blinkMarker = L.circleMarker(latlng, {
                radius: 15,
                fillColor: '#ef4444',
                color: '#fff',
                weight: 3,
                fillOpacity: 0.8,
                opacity: 1
            }).addTo(map);
            
            // กระพริบ 3 ครั้ง
            let count = 0;
            const blinkInterval = setInterval(() => {
                blinkMarker.setStyle({
                    opacity: blinkMarker.options.opacity === 1 ? 0 : 1,
                    fillOpacity: blinkMarker.options.fillOpacity === 0.8 ? 0 : 0.8
                });
                count++;
                if (count >= 6) {
                    clearInterval(blinkInterval);
                    map.removeLayer(blinkMarker);
                }
            }, 300);
        }

        // ฟังก์ชันสร้างแถวข้อมูลสิ่งปลูกสร้าง
        function renderBuildingTable() {
            const tbody = document.getElementById('building-table-body');
            if (allBuildings.length === 0) {
                tbody.innerHTML = '<tr><td colspan="8" class="text-center py-8 text-gray-500">ไม่มีข้อมูลสิ่งปลูกสร้าง</td></tr>';
                return;
            }
            tbody.innerHTML = allBuildings.map((building, index) => {
                if (!building.lat_long) return '';
                const [lat, lng] = building.lat_long.split(',').map(Number);
                
                // ✅ แก้ไขให้แสดงสถานะตรงกับข้อมูลจริง
                const statusClass = building.check === 'ถ่ายรูปแล้ว' ? 'status-ถ่ายรูปแล้ว' :
                                   building.check === 'ตรวจสอบแล้ว' ? 'status-ตรวจสอบแล้ว' : 'status-ยังไม่สำรวจ';
                const statusText = building.check || 'ยังไม่สำรวจ'; // ✅ แสดงค่าจริงจากข้อมูล
                
                return `
                <tr>
                    <td><span class="marker-icon marker-building"></span></td>
                    <td class="font-medium">${building.building_c || '-'}</td>
                    <td>${building.full_name || '-'}</td>
                    <td>${building.address || '-'}</td>
                    <td>${building.b_type || '-'}</td>
                    <td>${building.b_area || '-'}</td>
                    <td><span class="status-badge ${statusClass}">${statusText}</span></td>
                    <td>
                        <button class="zoom-btn" onclick="zoomToLocation(L.latLng(${lat}, ${lng}))">
                            <i data-lucide="locate" class="w-3 h-3 inline"></i>
                        </button>
                    </td>
                </tr>
                `;
            }).join('');
            lucide.createIcons();
        }
        // ============================================
        // ฟังก์ชันเมนูฟันเฟือง
        // ============================================

        /**
         * เปิด/ปิดเมนูฟันเฟือง
         */
        function toggleSettingsMenu() {
          const menu = document.getElementById('settings-menu');
          const icon = document.getElementById('settings-icon');
          const badge = document.getElementById('settings-badge');
          
          if (menu.classList.contains('hidden')) {
            // เปิดเมนู - ปุ่มย่อยเลื่อนลงมาทีละปุ่ม
            menu.classList.remove('hidden');
            icon.classList.add('animate-spin');
            
            // ซ่อนจุดแจ้งเตือน (ถ้ามี)
            badge.classList.add('hidden');
            
            // แอนิเมชันเลื่อนลงมาทีละปุ่ม
            setTimeout(() => {
              const buttons = menu.querySelectorAll('button');
              buttons.forEach((btn, index) => {
                setTimeout(() => {
                  btn.style.transform = 'translateY(0)';
                  btn.style.opacity = '1';
                }, index * 100);
              });
            }, 100);
            
            // ปิดเมนูอัตโนมัติเมื่อคลิกที่อื่น
            setTimeout(() => {
              document.addEventListener('click', closeSettingsMenuOnClickOutside);
            }, 100);
            
          } else {
            // ปิดเมนู
            closeSettingsMenu();
          }
        }

        /**
         * ปิดเมนูเมื่อคลิกที่อื่น
         */
        function closeSettingsMenuOnClickOutside(e) {
          const settingsBtn = document.getElementById('btn-settings');
          const settingsMenu = document.getElementById('settings-menu');
          
          if (!settingsBtn.contains(e.target) && !settingsMenu.contains(e.target)) {
            closeSettingsMenu();
            document.removeEventListener('click', closeSettingsMenuOnClickOutside);
          }
        }

        /**
         * ปิดเมนู
         */
        function closeSettingsMenu() {
          const menu = document.getElementById('settings-menu');
          const icon = document.getElementById('settings-icon');
          
          // แอนิเมชันเลื่อนขึ้นไป
          const buttons = menu.querySelectorAll('button');
          buttons.forEach((btn, index) => {
            setTimeout(() => {
              btn.style.transform = 'translateY(-20px)';
              btn.style.opacity = '0';
            }, (buttons.length - index - 1) * 50);
          });
          
          setTimeout(() => {
            menu.classList.add('hidden');
            icon.classList.remove('animate-spin');
          }, buttons.length * 50 + 100);
        }

        /**
         * ปุ่ม 1: ส่งออกแผนที่สิ่งปลูกสร้าง (GeoJSON)
         */
        async function exportBuildingGeoJSON() {
          closeSettingsMenu();
          
          // แสดงข้อความแจ้งเตือน
          showNotificationLeft('กำลังเตรียมข้อมูลสิ่งปลูกสร้าง...', 'info');
          
          try {
            // ดึงข้อมูลจากเซิร์ฟเวอร์
            const res = await fetch(`${CONFIG.SCRIPT_URL}?action=exportGeoJSON&type=building`);
            const geojsonData = await res.json();
            
            if (geojsonData.type === 'FeatureCollection') {
              // สร้าง Blob และดาวน์โหลดไฟล์
              const blob = new Blob([JSON.stringify(geojsonData, null, 2)], { 
                type: 'application/geo+json' 
              });
              
              const url = window.URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              a.download = `buildings_${new Date().toISOString().slice(0,10)}.geojson`;
              document.body.appendChild(a);
              a.click();
              window.URL.revokeObjectURL(url);
              document.body.removeChild(a);
              
              showNotificationLeft('ดาวน์โหลดไฟล์สิ่งปลูกสร้างสำเร็จ!', 'success');
            } else {
              throw new Error('ข้อมูลไม่ถูกต้อง');
            }
          } catch (err) {
            console.error('Error exporting buildings:', err);
            showNotificationLeft('เกิดข้อผิดพลาดในการส่งออกข้อมูล', 'error');
          }
        }

        /**
         * ปุ่ม 2: ส่งออกแผนที่ป้าย (GeoJSON)
         */
        async function exportSignGeoJSON() {
          closeSettingsMenu();
          
          showNotificationLeft('กำลังเตรียมข้อมูลป้าย...', 'info');
          
          try {
            const res = await fetch(`${CONFIG.SCRIPT_URL}?action=exportGeoJSON&type=sign`);
            const geojsonData = await res.json();
            
            if (geojsonData.type === 'FeatureCollection') {
              const blob = new Blob([JSON.stringify(geojsonData, null, 2)], { 
                type: 'application/geo+json' 
              });
              
              const url = window.URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              a.download = `signs_${new Date().toISOString().slice(0,10)}.geojson`;
              document.body.appendChild(a);
              a.click();
              window.URL.revokeObjectURL(url);
              document.body.removeChild(a);
              
              showNotificationLeft('ดาวน์โหลดไฟล์ป้ายสำเร็จ!', 'success');
            } else {
              throw new Error('ข้อมูลไม่ถูกต้อง');
            }
          } catch (err) {
            console.error('Error exporting signs:', err);
            showNotificationLeft('เกิดข้อผิดพลาดในการส่งออกข้อมูล', 'error');
          }
        }

        /**
         * ปุ่ม 3: โหลดรูปสิ่งปลูกสร้างจากโฟลเดอร์ Google Drive
         */
        async function loadBuildingImages() {
          closeSettingsMenu();
          
          showNotificationLeft('กำลังโหลดรูปภาพสิ่งปลูกสร้าง...', 'info');
          
          try {
            // ดึงข้อมูลสิ่งปลูกสร้างทั้งหมด
            const res = await fetch(`${CONFIG.SCRIPT_URL}?action=getData`);
            const data = await res.json();
            const buildings = data.buildings || [];
            
            // กรองเฉพาะที่มีรูปภาพ
            const buildingsWithImages = buildings.filter(b => b.image && b.image.trim() !== '');
            
            if (buildingsWithImages.length === 0) {
              showNotificationLeft('ไม่พบรูปภาพสิ่งปลูกสร้าง', 'warning');
              return;
            }
            
            // แสดงแกลเลอรี่รูปภาพ
            showImageGallery(buildingsWithImages, 'building');
            
          } catch (err) {
            console.error('Error loading building images:', err);
            showNotificationLeft('เกิดข้อผิดพลาดในการโหลดรูปภาพ', 'error');
          }
        }

        /**
         * ปุ่ม 4: โหลดรูปป้ายจากโฟลเดอร์ Google Drive
         */
        async function loadSignImages() {
          closeSettingsMenu();
          
          showNotificationLeft('กำลังโหลดรูปภาพป้าย...', 'info');
          
          try {
            const res = await fetch(`${CONFIG.SCRIPT_URL}?action=getData`);
            const data = await res.json();
            const signs = data.signs || [];
            
            const signsWithImages = signs.filter(s => s.picture && s.picture.trim() !== '');
            
            if (signsWithImages.length === 0) {
              showNotificationLeft('ไม่พบรูปภาพป้าย', 'warning');
              return;
            }
            
            showImageGallery(signsWithImages, 'sign');
            
          } catch (err) {
            console.error('Error loading sign images:', err);
            showNotificationLeft('เกิดข้อผิดพลาดในการโหลดรูปภาพ', 'error');
          }
        }

        /**
         * แสดงแกลเลอรี่รูปภาพ - เวอร์ชันแก้ไข
         */
        function showImageGallery(items, type) {
            // ✅ ข้อ 1: กรองเฉพาะรูปที่มีลิ้งค์
            const filteredItems = items.filter(item => {
                if (type === 'building') {
                    return item.image && item.image.trim() !== '';
                } else {
                    return item.picture && item.picture.trim() !== '';
                }
            });
            
            if (filteredItems.length === 0) {
                showNotificationLeft('ไม่พบรูปภาพที่มีลิ้งค์', 'warning');
                return;
            }
            
            // สร้างหน้าต่างแกลเลอรี่
            const galleryDiv = document.createElement('div');
            galleryDiv.id = 'image-gallery-modal';
            galleryDiv.className = 'fixed inset-0 bg-black/90 z-[3000] flex flex-col p-4 overflow-hidden';
            
            // ✅ ค่าเริ่มต้น: แสดงเป็นรายชื่อ
            let isGridView = false;
            
            galleryDiv.innerHTML = `
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-white text-xl font-bold">
                    ${type === 'building' ? 'รูปภาพสิ่งปลูกสร้าง' : 'รูปภาพป้าย'} (${filteredItems.length} รูป)
                </h3>
                <div class="flex gap-2">
                    <!-- ✅ ปุ่มสลับมุมมอง (ค่าเริ่มต้น: แสดงเป็นภาพ) -->
                    <button onclick="toggleGalleryView()" id="btn-toggle-view" class="bg-gray-700 text-white px-4 py-2 rounded-lg hover:bg-gray-600 transition flex items-center gap-2">
                        <i data-lucide="grid" id="view-icon" class="w-4 h-4"></i>
                        <span id="view-text">แสดงเป็นภาพ</span>
                    </button>
                    <!-- ✅ ปุ่มดาวน์โหลดทั้งหมด -->
                    <button onclick="downloadAllImagesAsZip()" class="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition flex items-center gap-2">
                        <i data-lucide="download" class="w-4 h-4"></i>
                        <span>ดาวน์โหลดทั้งหมด</span>
                    </button>
                    <button onclick="closeImageGallery()" class="text-white hover:text-gray-300 transition">
                        <i data-lucide="x" class="w-8 h-8"></i>
                    </button>
                </div>
            </div>
            <!-- ✅ คอนเทนเนอร์สำหรับสลับมุมมอง -->
            <div id="gallery-container" class="flex-1 overflow-y-auto">
                <!-- จะถูกแทนที่ด้วยฟังก์ชัน toggleGalleryView() -->
            </div>
            `;
            
            document.body.appendChild(galleryDiv);
            lucide.createIcons();
            
            // ✅ เริ่มต้นด้วยมุมมองรายชื่อ
            renderGalleryListView(filteredItems, type);
        }

        // ✅ ประกาศตัวแปรสำหรับเก็บสถานะมุมมองและข้อมูลปัจจุบัน
        let currentGalleryItems = [];
        let currentGalleryType = '';
        let isGridView = false; // ✅ ค่าเริ่มต้น: false = แสดงเป็นรายชื่อ

        /**
         * ✅ ฟังก์ชันสลับระหว่างมุมมองภาพตัวอย่างกับรายชื่อ
         */
        function toggleGalleryView() {
            isGridView = !isGridView;
            
            const btn = document.getElementById('btn-toggle-view');
            const icon = document.getElementById('view-icon');
            const text = document.getElementById('view-text');
            
            if (isGridView) {
                // สลับไปมุมมองภาพตัวอย่าง
                btn.className = 'bg-gray-700 text-white px-4 py-2 rounded-lg hover:bg-gray-600 transition flex items-center gap-2';
                icon.innerHTML = '<i data-lucide="list" class="w-4 h-4"></i>';
                text.textContent = 'แสดงเป็นรายชื่อ';
                renderGalleryGridView(currentGalleryItems, currentGalleryType);
            } else {
                // สลับไปมุมมองรายชื่อ
                btn.className = 'bg-gray-700 text-white px-4 py-2 rounded-lg hover:bg-gray-600 transition flex items-center gap-2';
                icon.innerHTML = '<i data-lucide="grid" class="w-4 h-4"></i>';
                text.textContent = 'แสดงเป็นภาพ';
                renderGalleryListView(currentGalleryItems, currentGalleryType);
            }
            
            lucide.createIcons();
        }

        /**
         * ✅ แสดงมุมมองภาพตัวอย่าง (Grid View)
         */
        function renderGalleryGridView(items, type) {
            currentGalleryItems = items;
            currentGalleryType = type;
            
            const container = document.getElementById('gallery-container');
            
            container.innerHTML = `
            <div id="gallery-grid" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3">
                ${items.map((item, index) => `
                <div class="relative group cursor-pointer" onclick="openImageViewer(${index}, '${type}')">
                    <img src="${type === 'building' ? item.image : item.picture}"
                        alt="รูปภาพ ${index + 1}"
                        class="w-full h-32 object-cover rounded-lg hover:opacity-75 transition"
                        onerror="this.src='https://via.placeholder.com/150?text=No+Image'">
                    <div class="absolute inset-0 bg-black/50 opacity-0 group-hover:opacity-100 transition-opacity rounded-lg flex items-center justify-center">
                        <span class="text-white text-sm font-bold">ดูรูปใหญ่</span>
                    </div>
                    <div class="mt-1 text-xs text-white truncate">
                        ${type === 'building' ? (item.building_c || item.full_name || '-') : (item.s_code || item.s_name || '-')}
                    </div>
                </div>
                `).join('')}
            </div>
            `;
            
            lucide.createIcons();
        }

        /**
         * ✅ แสดงมุมมองรายชื่อ (List View)
         */
        function renderGalleryListView(items, type) {
            currentGalleryItems = items;
            currentGalleryType = type;
            
            const container = document.getElementById('gallery-container');
            
            container.innerHTML = `
            <div class="bg-gray-800 rounded-lg overflow-hidden">
                <div class="grid grid-cols-[40px_1fr_120px_80px] gap-2 p-3 bg-gray-700 text-white font-bold text-sm">
                    <span>#</span>
                    <span>ชื่อ</span>
                    <span>ขนาด</span>
                    <span>ดาวน์โหลด</span>
                </div>
                <div class="max-h-[calc(100vh-150px)] overflow-y-auto">
                    ${items.map((item, index) => `
                    <div class="grid grid-cols-[40px_1fr_120px_80px] gap-2 p-3 border-b border-gray-700 hover:bg-gray-700/50 transition cursor-pointer" onclick="openImageViewer(${index}, '${type}')">
                        <span class="text-gray-400 text-sm">${index + 1}</span>
                        <div class="flex items-center gap-2">
                            <i data-lucide="image" class="w-4 h-4 text-blue-400"></i>
                            <span class="text-white truncate">
                                ${type === 'building' ? (item.building_c || item.full_name || '-') : (item.s_code || item.s_name || '-')}
                            </span>
                        </div>
                        <span class="text-gray-400 text-xs">-</span>
                        <button onclick="event.stopPropagation(); downloadSingleImage('${type === 'building' ? item.image : item.picture}', '${type === 'building' ? (item.building_c || 'building') : (item.s_code || 'sign')}')" 
                            class="bg-blue-600 text-white px-2 py-1 rounded hover:bg-blue-700 transition text-xs flex items-center justify-center gap-1">
                            <i data-lucide="download" class="w-3 h-3"></i>
                        </button>
                    </div>
                    `).join('')}
                </div>
            </div>
            `;
            
            lucide.createIcons();
        }

        /**
         * ✅ ดาวน์โหลดรูปภาพเดียว
         */
        function downloadSingleImage(url, filename) {
            const link = document.createElement('a');
            link.href = url;
            link.download = `${filename}_${Date.now()}.jpg`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            showNotificationLeft(`ดาวน์โหลด ${filename} สำเร็จ!`, 'success');
        }

        // ============================================
        // ดาวน์โหลดรูปทั้งหมดเป็นไฟล์เดียว (ใช้ JSZip) - เวอร์ชันแก้ไขแล้ว
        // ============================================
        async function downloadAllImagesAsZip() {
            showNotificationLeft('กำลังเตรียมดาวน์โหลด...', 'info');
            
            try {
                const galleryGrid = document.getElementById('gallery-grid');
                if (!galleryGrid) {
                    showNotificationLeft('❌ ไม่พบข้อมูลรูปภาพ', 'error');
                    return;
                }
                
                const items = [];
                const type = document.querySelector('#image-gallery-modal h3')?.innerText.includes('สิ่งปลูกสร้าง') ? 'building' : 'sign';
                
                galleryGrid.querySelectorAll('.relative.group').forEach((el, index) => {
                    const img = el.querySelector('img');
                    const url = img?.src;
                    const codeEl = el.querySelector('p.font-bold');
                    const codeText = codeEl?.innerText || '';
                    const code = codeText.replace(/[^0-9]/g, '');
                    
                    // ✅ แก้ไข: ลบช่องว่างพิเศษในสตริงตรวจสอบ
                    if (url && url !== 'https://via.placeholder.com/150?text=No+Image') {
                        items.push({
                            url: url,
                            filename: `${type === 'building' ? 'B' : 'S'}${code || index + 1}.jpg`
                        });
                    }
                });
                
                if (items.length === 0) {
                    showNotificationLeft('⚠️ ไม่พบรูปภาพให้ดาวน์โหลด', 'warning');
                    return;
                }
                
                showNotificationLeft(`กำลังดาวน์โหลด ${items.length} รูป...`, 'info');
                
                // ✅ แก้ไข: ลบช่องว่างพิเศษใน URL JSZip
                if (typeof JSZip === 'undefined') {
                    await new Promise((resolve, reject) => {
                        const script = document.createElement('script');
                        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js'; // ✅ ลบช่องว่าง
                        script.onload = resolve;
                        script.onerror = () => reject(new Error('Failed to load JSZip'));
                        document.head.appendChild(script);
                    });
                }
                
                const zip = new JSZip();
                const folder = zip.folder(type === 'building' ? 'buildings' : 'signs');
                let successCount = 0;
                
                for (let i = 0; i < items.length; i++) {
                    const item = items[i];
                    try {
                        const response = await fetch(item.url);
                        if (!response.ok) throw new Error(`HTTP ${response.status}`);
                        
                        const blob = await response.blob();
                        folder.file(item.filename, blob);
                        successCount++;
                        
                        if ((i + 1) % 5 === 0 || i === items.length - 1) {
                            showNotificationLeft(`กำลังดาวน์โหลด (${successCount}/${items.length})...`, 'info');
                        }
                    } catch (err) {
                        console.error(`ดาวน์โหลด ${item.filename} ล้มเหลว:`, err);
                    }
                }
                
                if (successCount === 0) {
                    showNotificationLeft('❌ ดาวน์โหลดรูปภาพล้มเหลวทั้งหมด', 'error');
                    return;
                }
                
                const content = await zip.generateAsync({ type: 'blob' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(content);
                link.download = `${type === 'building' ? 'buildings' : 'signs'}_${new Date().toISOString().slice(0, 10)}.zip`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href);
                
                showNotificationLeft(`✅ ดาวน์โหลดรูปภาพทั้งหมด (${successCount} รูป) เสร็จสิ้น!`, 'success');
            } catch (err) {
                console.error('ข้อผิดพลาด:', err);
                showNotificationLeft('❌ ดาวน์โหลดล้มเหลว: ' + err.message, 'error');
            }
        }

        /**
         * เปิดดูรูปภาพขนาดใหญ่ - เวอร์ชันแก้ไข
         */
        function openImageViewer(index, type) {
            const items = currentGalleryItems;
            const item = items[index];
            
            if (!item) return;
            
            // สร้างหน้าต่างดูรูปใหญ่
            const viewerDiv = document.createElement('div');
            viewerDiv.id = 'image-viewer-modal';
            viewerDiv.className = 'fixed inset-0 bg-black/95 z-[3001] flex items-center justify-center p-4';
            viewerDiv.onclick = (e) => {
                if (e.target === viewerDiv) closeImageViewer();
            };
            
            // ✅ ใช้ลิ้งค์ที่ถูกต้องตามประเภท
            const imageUrl = type === 'building' ? item.image : item.picture;
            const code = type === 'building' ? item.building_c : item.s_code;
            const name = type === 'building' ? item.full_name : item.s_name;
            const address = type === 'building' ? item.address : item.comment;
            
            viewerDiv.innerHTML = `
            <div class="relative max-w-4xl w-full">
                <img src="${imageUrl}"
                    alt="รูปภาพ"
                    class="w-full max-h-[80vh] object-contain rounded-lg"
                    onerror="this.src='https://via.placeholder.com/800x600?text=No+Image'">
                <div class="absolute bottom-4 left-4 right-4 bg-black/70 text-white p-3 rounded-lg">
                    <p class="font-bold">${type === 'building' ? 'สิ่งปลูกสร้าง:' : 'ป้าย:'} ${code || '-'}</p>
                    <p class="text-sm">${name || ''}</p>
                    <p class="text-xs mt-1">${address || ''}</p>
                </div>
                <button onclick="closeImageViewer()" class="absolute top-4 right-4 text-white hover:text-gray-300 transition">
                    <i data-lucide="x" class="w-8 h-8"></i>
                </button>
                <button onclick="downloadSingleImage('${imageUrl}', '${code || 'image'}')"
                    class="absolute top-4 left-4 bg-blue-600 text-white p-2 rounded-lg hover:bg-blue-700 transition">
                    <i data-lucide="download" class="w-5 h-5"></i>
                </button>
            </div>
            `;
            
            document.body.appendChild(viewerDiv);
            lucide.createIcons();
        }

        /**
         * ปิดหน้าต่างดูรูปใหญ่
         */
        function closeImageViewer() {
          const viewer = document.getElementById('image-viewer-modal');
          if (viewer) viewer.remove();
        }

        /**
         * ปิดแกลเลอรี่รูปภาพ
         */
        function closeImageGallery() {
          const gallery = document.getElementById('image-gallery-modal');
          if (gallery) gallery.remove();
          closeImageViewer(); // ปิดหน้าต่างดูรูปใหญ่ด้วย (ถ้ามี)
        }

        /**
         * ดาวน์โหลดรูปภาพ
         */
        function downloadImage(url, filename) {
          const link = document.createElement('a');
          link.href = url;
          link.download = `${filename}_${Date.now()}.jpg`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        }

        /**
         * แสดงแจ้งเตือน
         */
        function showNotificationLeft(message, type = 'info') {
          const colors = {
            info: 'bg-blue-500',
            success: 'bg-green-500',
            error: 'bg-red-500',
            warning: 'bg-yellow-500'
          };
          
          const icons = {
            info: 'info',
            success: 'check-circle',
            error: 'alert-circle',
            warning: 'alert-triangle'
          };
          
          const notification = document.createElement('div');
          notification.className = `fixed top-4 left-4 ${colors[type]} text-white px-6 py-3 rounded-lg shadow-lg z-[2000] animate-fade-in`;
          notification.innerHTML = `
            <i data-lucide="${icons[type]}" class="w-5 h-5 inline mr-2"></i>
            ${message}
          `;
          
          document.body.appendChild(notification);
          lucide.createIcons();
          
          setTimeout(() => {
            notification.classList.add('animate-fade-out');
            setTimeout(() => notification.remove(), 300);
          }, 500);
        }
        /**
         * แสดงมาร์กเกอร์ทั้งหมด (สำหรับข้อมูลน้อย)
         */
        function renderAllMarkers() {
          allBuildings.forEach(r => {
            if (!r.lat_long) return;
            const coords = r.lat_long.split(',').map(Number);
            if (coords.length < 2 || isNaN(coords[0]) || isNaN(coords[1])) return;
            const m = createCircleMarker(L.latLng(coords[0], coords[1]), 'building', isEditMode);
            setupMarkerPopup(m, r, 'building');
            m.addTo(surveyLayers);
            if (isEditMode) enableMarkerDragging(m, r);
          });
          
          allSigns.forEach(r => {
            if (!r.lat_long) return;
            const coords = r.lat_long.split(',').map(Number);
            if (coords.length < 2 || isNaN(coords[0]) || isNaN(coords[1])) return;
            const m = createCircleMarker(L.latLng(coords[0], coords[1]), 'sign', isEditMode);
            setupMarkerPopup(m, r, 'sign');
            m.addTo(surveyLayers);
            if (isEditMode) enableMarkerDragging(m, r);
          });
        }

        // ============================================
        // อัปเดตมาร์กเกอร์เฉพาะในมุมมอง (GPU Optimized)
        // ============================================
        function updateVisibleMarkers() {
            // ✅ ใช้ requestAnimationFrame สำหรับการเรนเดอร์แบบประสิทธิภาพสูง
            requestAnimationFrame(() => {
                const bounds = map.getBounds();
                const zoom = map.getZoom();
                const bufferRatio = isMobile() ? 0.3 : 0.5; // ลดบัฟเฟอร์สำหรับมือถือ
                const bufferedBounds = bounds.pad(bufferRatio);
                
                // ✅ ล้างมาร์กเกอร์ทั้งหมดในครั้งเดียว (แทนทีละตัว)
                surveyLayers.clearLayers();
                
                // ✅ สร้างมาร์กเกอร์แบบแบตช์
                const markersToRender = [];
                
                // จุดสิ่งปลูกสร้าง
                allBuildings.forEach(r => {
                    if (!r.lat_long) return;
                    const coords = r.lat_long.split(',').map(Number);
                    if (coords.length < 2 || isNaN(coords[0]) || isNaN(coords[1])) return;
                    
                    const latLng = L.latLng(coords[0], coords[1]);
                    if (!bufferedBounds.contains(latLng)) return;
                    
                    // ✅ ข้ามจุดที่กำลังถูกย้าย
                    const recordKey = r._row_num || r.id;
                    if (markersBeingMoved.has(recordKey)) return;
                    
                    markersToRender.push({ latLng, data: r, type: 'building' });
                });
                
                // จุดป้าย
                allSigns.forEach(r => {
                    if (!r.lat_long) return;
                    const coords = r.lat_long.split(',').map(Number);
                    if (coords.length < 2 || isNaN(coords[0]) || isNaN(coords[1])) return;
                    
                    const latLng = L.latLng(coords[0], coords[1]);
                    if (!bufferedBounds.contains(latLng)) return;
                    
                    const recordKey = r._row_num || r.id;
                    if (markersBeingMoved.has(recordKey)) return;
                    
                    markersToRender.push({ latLng, data: r, type: 'sign' });
                });
                
                // ✅ เรนเดอร์ทั้งหมดในครั้งเดียว
                markersToRender.forEach(item => {
                    const m = createCircleMarker(item.latLng, item.type, isEditMode);
                    m._popupData = item.data;
                    m.addTo(surveyLayers);
                });
                
                console.log(`✅ เรนเดอร์มาร์กเกอร์ ${markersToRender.length} จุดด้วย GPU (Canvas)`);
            });
        }

        // เปิดใช้งานการลากมาร์กเกอร์ในโหมดแก้ไข
        function enableMarkerDragging(marker, data) {
            // ✅ ตรวจสอบว่ามีเมธอดที่จำเป็นก่อนเรียกใช้
            if (!isEditMode || !marker || !marker.on || !marker.off) return;
            
            if (marker.dragging?.enable) {
                marker.dragging.enable();
            }
            
            marker.off('dragend');
            marker.on('dragend', async function(e) {
                const newLatLng = e.target.getLatLng();
                const marker = e.target;
                const data = marker._popupData;
                if (data) {
                    await updateMarkerPosition(marker, data, newLatLng);
                }
            });
        }

        // ฟังก์ชันสร้างแถวข้อมูลป้าย
        function renderSignTable() {
            const tbody = document.getElementById('sign-table-body');
            if (allSigns.length === 0) {
                tbody.innerHTML = '<tr><td colspan="9" class="text-center py-8 text-gray-500">ไม่มีข้อมูลป้าย</td></tr>';
                return;
            }
            // ในฟังก์ชัน renderSignTable() แก้ไขส่วนสร้างแถว:
            tbody.innerHTML = allSigns.map((sign, index) => {
                if (!sign.lat_long) return '';
                const [lat, lng] = sign.lat_long.split(',').map(Number);
                
                // ✅ แสดงสถานะตรวจสอบให้ตรงกับข้อมูลจริง
                const statusClass = sign.check === 'ถ่ายรูปแล้ว' ? 'status-ถ่ายรูปแล้ว' :
                                   sign.check === 'ตรวจสอบแล้ว' ? 'status-ตรวจสอบแล้ว' : 'status-ยังไม่สำรวจ';
                const statusText = sign.check || 'ยังไม่สำรวจ';
                
                return `
                <tr>
                    <td><span class="marker-icon marker-sign"></span></td>
                    <td class="font-medium">${sign.s_code || '-'}</td>      <!-- 1. รหัส -->
                    <td class="text-center">${sign.s_characte || '-'}</td>       <!-- ✅ แก้ไข: บังคับกึ่งกลางด้วย inline style -->
                    <td class="text-center">${sign.s_wide || '-'}</td>        <!-- ✅ เพิ่ม -->
                    <td class="text-center">${sign.s_length || '-'}</td>      <!-- ✅ เพิ่ม -->
                    <td class="text-center">${sign.no_side || '-'}</td>       <!-- ✅ เพิ่ม -->
                    <td>${sign.s_text || '-'}</td>                          <!-- 6. ข้อความ -->
                    <td class="text-center"><span class="status-badge ${statusClass}">${statusText}</span></td> <!-- ✅ เพิ่ม -->
                    <td>
                        <button class="zoom-btn" onclick="zoomToLocation(L.latLng(${lat}, ${lng}))">
                            <i data-lucide="locate" class="w-3 h-3 inline"></i>
                        </button>
                    </td>
                </tr>
                `;
            }).join('');
            lucide.createIcons();
        }

        async function loadExistingData() {
            try {
                const res = await fetch(`${CONFIG.SCRIPT_URL}?action=getData`);
                const data = await res.json();
                
                // เก็บจุดชั่วคราวทั้งหมดก่อนล้าง
                const tempMarkers = [];
                surveyLayers.eachLayer(layer => {
                    if (layer._popupData && layer._popupData.tempMarker) {
                        tempMarkers.push({
                            latlng: layer.getLatLng(),
                            data: layer._popupData,
                            type: layer._popupData.type
                        });
                    }
                });
                
                surveyLayers.clearLayers();
                
                // โหลดข้อมูลจริงจากเซิร์ฟเวอร์
                allBuildings = data.buildings || [];
                allSigns = data.signs || [];
                
                // แสดงข้อมูลในตาราง
                renderBuildingTable();
                renderSignTable();
                
                const totalMarkers = allBuildings.length + allSigns.length;
                const useOptimizedRendering = totalMarkers > 200;
                
                if (useOptimizedRendering) {
                    map.off('moveend', updateVisibleMarkers);
                    map.off('zoomend', updateVisibleMarkers);
                    map.on('moveend', updateVisibleMarkers);
                    map.on('zoomend', updateVisibleMarkers);
                    updateVisibleMarkers(); // ✅ ฟังก์ชันนี้ยังมีการตรวจสอบ markersBeingMoved (สำหรับการเลื่อนแผนที่ระหว่างย้าย)
                } else {
                    // ✅ สร้างจุดจริงทั้งหมดโดยไม่ตรวจสอบ markersBeingMoved
                    allBuildings.forEach(r => {
                        if (!r.lat_long) return;
                        const coords = r.lat_long.split(',').map(Number);
                        if (coords.length < 2 || isNaN(coords[0]) || isNaN(coords[1])) return;
                        // ❌ ลบบรรทัดนี้ออกทั้งหมด:
                        // if (markersBeingMoved.has(r._row_num)) return;
                        const m = createCircleMarker(L.latLng(coords[0], coords[1]), 'building', isEditMode);
                        setupMarkerPopup(m, r, 'building');
                        m.addTo(surveyLayers);
                        if (isEditMode) enableMarkerDragging(m, r);
                    });
                    
                    allSigns.forEach(r => {
                        if (!r.lat_long) return;
                        const coords = r.lat_long.split(',').map(Number);
                        if (coords.length < 2 || isNaN(coords[0]) || isNaN(coords[1])) return;
                        // ❌ ลบบรรทัดนี้ออกทั้งหมด:
                        // if (markersBeingMoved.has(r._row_num)) return;
                        const m = createCircleMarker(L.latLng(coords[0], coords[1]), 'sign', isEditMode);
                        setupMarkerPopup(m, r, 'sign');
                        m.addTo(surveyLayers);
                        if (isEditMode) enableMarkerDragging(m, r);
                    });
                }
                
                // ✅ เพิ่มจุดชั่วคราวกลับเข้ามา (จะมีทั้งจุดจริงและจุดชั่วคราวชั่วคราว 300ms)
                tempMarkers.forEach(marker => {
                    const m = createCircleMarker(marker.latlng, marker.type, isEditMode);
                    m._popupData = marker.data;
                    setupMarkerPopup(m, marker.data, marker.type);
                    m.addTo(surveyLayers);
                    if (isEditMode) enableMarkerDragging(m, marker.data);
                });
            } catch(e) {
                console.error("Error loading data:", e);
            }
        }

        // ============================================
        // Offline Data Storage System
        // ============================================

        // ตรวจจับสถานะออนไลน์
        let isOnline = navigator.onLine;
        let syncQueue = [];

        // แสดงสถานะการเชื่อมต่อ
        function updateConnectionStatus() {
            const statusDiv = document.getElementById('connection-status');
            if (!statusDiv) {
                const div = document.createElement('div');
                div.id = 'connection-status';
                div.className = 'fixed top-4 left-4 px-4 py-2 rounded-lg text-white font-bold shadow-lg z-[2000]';
                document.body.appendChild(div);
            }
            
            const status = document.getElementById('connection-status');
            if (isOnline) {
                status.textContent = '✓ เชื่อมต่ออินเทอร์เน็ต';
                status.className = 'fixed top-4 left-4 px-4 py-2 rounded-lg text-white font-bold shadow-lg z-[2000] bg-green-500';
            } else {
                status.textContent = '⚠️ โหมดออฟไลน์ - ข้อมูลจะถูกเก็บไว้ในมือถือ';
                status.className = 'fixed top-4 left-4 px-4 py-2 rounded-lg text-white font-bold shadow-lg z-[2000] bg-yellow-500';
            }
            
            // ซ่อนอัตโนมัติหลัง 3 วินาที
            setTimeout(() => {
                status.style.opacity = '0';
                setTimeout(() => status.remove(), 300);
            }, 1000);
        }

        // ฟังก์ชันตรวจสอบการเชื่อมต่อ
        window.addEventListener('online', () => {
            isOnline = true;
            updateConnectionStatus();
            // เมื่อกลับมาออนไลน์ ให้พยายามส่งข้อมูลที่ค้างอยู่
            setTimeout(processSyncQueue, 1000);
        });

        window.addEventListener('offline', () => {
            isOnline = false;
            updateConnectionStatus();
        });

        // ฟังก์ชันเก็บข้อมูลในคิว
        function addToSyncQueue(action, type, data, rowKey = null) {
            const queueItem = {
                id: Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                timestamp: new Date().toISOString(),
                action: action, // 'add', 'update', 'delete', 'updatePosition'
                type: type,     // 'building', 'sign'
                data: data,
                rowKey: rowKey,
                status: 'ยังไม่สำรวจ', // ยังไม่สำรวจ, success, failed
                retryCount: 0
            };
            
            syncQueue.push(queueItem);
            saveSyncQueueToStorage();
            
            // แสดงแจ้งเตือน
            showNotificationLeft(`บันทึกข้อมูลไว้ในมือถือ (${syncQueue.length} รายการรอซิงค์)`, 'warning');
            
            return queueItem.id;
        }

        // บันทึกคิวลงใน LocalStorage
        function saveSyncQueueToStorage() {
            localStorage.setItem('syncQueue', JSON.stringify(syncQueue));
        }

        // โหลดคิวจาก LocalStorage
        function loadSyncQueueFromStorage() {
            const saved = localStorage.getItem('syncQueue');
            if (saved) {
                syncQueue = JSON.parse(saved);
            }
        }

        // ลบรายการที่สำเร็จแล้ว
        function removeFromSyncQueue(id) {
            syncQueue = syncQueue.filter(item => item.id !== id);
            saveSyncQueueToStorage();
        }

        // ============================================
        // ฟังก์ชันส่งข้อมูลแบบมีการลองใหม่ (Retry Mechanism)
        // ============================================

        async function sendDataWithRetry(action, type, data, rowKey = null, maxRetries = 5) {
            // ถ้าออฟไลน์ → เก็บไว้ในคิวทันที
            if (!isOnline || !navigator.onLine) {
                return addToSyncQueue(action, type, data, rowKey);
            }
            
            let retryCount = 0;
            
            while (retryCount < maxRetries) {
                try {
                    const body = new URLSearchParams();
                    body.append('action', action);
                    body.append('type', type);
                    
                    if (rowKey) {
                        body.append('rowKey', rowKey);
                    }
                    
                    if (data) {
                        // ✅ แยกข้อมูลรูปภาพออก
                        const { image, fileName, ...textData } = data;
                        
                        // ส่งข้อมูลข้อความ
                        if (Object.keys(textData).length > 0) {
                            body.append('payload', JSON.stringify(textData));
                        }
                        
                        // ✅ ส่งรูปภาพไปยังเซิร์ฟเวอร์ทันที
                        if (image && fileName) {
                            body.append('image', image);
                            body.append('fileName', fileName);
                            console.log(`ส่งรูปภาพไปยังเซิร์ฟเวอร์: ${fileName}`);
                        }
                    }
                    
                    const res = await fetch(CONFIG.SCRIPT_URL.trim(), {
                        method: 'POST',
                        body,
                        timeout: action === 'updateImage' || (data && data.image) ? 60000 : 30000
                    });
                    
                    if (res.ok) {
                        // ✅ แก้ไขตรงนี้: เพิ่มชื่อคีย์ 'data'
                        return { success: true, data: await res.json() };
                    } else {
                        throw new Error(`HTTP ${res.status}`);
                    }
                } catch (err) {
                    retryCount++;
                    
                    if (retryCount >= maxRetries) {
                        // ✅ หากล้มเหลวทุกครั้ง ให้บันทึกลงคิว
                        const queueId = addToSyncQueue(action, type, data, rowKey);
                        console.error(`Failed after ${maxRetries} retries. Saved to queue: ${queueId}`);
                        return { success: false, queued: true, queueId: queueId };
                    }
                    
                    const waitTime = 1000 * Math.pow(2, retryCount);
                    console.log(`Retry ${retryCount}/${maxRetries} after ${waitTime}ms...`);
                    
                    // รอเวลาที่กำหนด
                    await new Promise(resolve => setTimeout(resolve, waitTime));
                }
            }
        }

        // ============================================
        // Enhanced Sync Process with Image Support
        // ============================================

        async function processSyncQueue() {
            if (!navigator.onLine || syncQueue.length === 0) {
                console.log('ไม่สามารถซิงค์ได้: ไม่มีอินเทอร์เน็ตหรือไม่มีคิว');
                return;
            }
            
            console.log(`กำลังซิงค์ข้อมูล (${syncQueue.length} รายการ)...`);
            
            const failedItems = [];
            for (let item of syncQueue) {
                if (item.status === 'success') continue;
                
                try {
                    const result = await sendDataWithRetry(
                        item.action,
                        item.type,
                        item.data,
                        item.rowKey,
                        3
                    );
                    
                    if (result.success) {
                        item.status = 'success';
                        removeFromSyncQueue(item.id);
                        console.log(`Synced: ${item.id}`);
                    } else {
                        item.retryCount++;
                        if (item.retryCount >= 5) {
                            item.status = 'failed';
                            failedItems.push(item);
                        }
                    }
                } catch (err) {
                    item.retryCount++;
                    console.error(`Error syncing ${item.id}:`, err);
                    if (item.retryCount >= 5) {
                        item.status = 'failed';
                        failedItems.push(item);
                    }
                }
                
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            
            // ซิงค์รูปภาพที่ยังไม่ได้ส่ง
            await syncPendingImages();
            saveSyncQueueToStorage();
            
            // แจ้งผลลัพธ์
            const successCount = syncQueue.filter(i => i.status === 'success').length;
            const ยังไม่สำรวจCount = syncQueue.filter(i => i.status === 'ยังไม่สำรวจ').length;
            
            if (ยังไม่สำรวจCount === 0 && failedItems.length === 0) {
                console.log('ซิงค์ข้อมูลสำเร็จทั้งหมด!');
            } else if (ยังไม่สำรวจCount > 0) {
                console.log(`ซิงค์ข้อมูล ${successCount} รายการ (${ยังไม่สำรวจCount} รายการรอซิงค์)`);
            }
            
            if (failedItems.length > 0) {
                console.log(`มี ${failedItems.length} รายการที่ซิงค์ไม่สำเร็จ`);
            }
        }


        // โหลดคิวเมื่อแอปเริ่มทำงาน
        loadSyncQueueFromStorage();

        // เพิ่มปุ่มตรวจสอบสถานะซิงค์ในเมนูฟันเฟือง
        // ในฟังก์ชัน toggleSettingsMenu ให้เพิ่มปุ่มใหม่:

        /*
        <button onclick="checkSyncStatus()" class="map-btn p-3 w-48 bg-gradient-to-r from-gray-400 to-gray-600 text-white hover:scale-105 transition-all shadow-lg flex items-center justify-start gap-2 text-left">
            <i data-lucide="sync" class="w-5 h-5"></i>
            <span class="text-xs font-bold">ตรวจสอบสถานะซิงค์</span>
        </button>
        */

        // ฟังก์ชันตรวจสอบสถานะ
        function checkSyncStatus() {
            closeSettingsMenu();
            
            const ยังไม่สำรวจ = syncQueue.filter(i => i.status === 'ยังไม่สำรวจ').length;
            const failed = syncQueue.filter(i => i.status === 'failed').length;
            const success = syncQueue.filter(i => i.status === 'success').length;
            
            let message = `📊 สถานะการซิงค์ข้อมูล:\n`;
            message += `✅ สำเร็จ: ${success} รายการ\n`;
            message += `⏳ รอซิงค์: ${ยังไม่สำรวจ} รายการ\n`;
            message += `❌ ล้มเหลว: ${failed} รายการ`;
            
            if (ยังไม่สำรวจ > 0) {
                message += `\n\n⚠️ มีข้อมูลที่ยังไม่ได้ซิงค์!`;
            }
            
            alert(message);
            
            // ถ้ามีข้อมูลรอซิงค์ ถามว่าต้องการซิงค์เลยไหม
            if (ยังไม่สำรวจ > 0 && isOnline) {
                if (confirm(`ต้องการซิงค์ข้อมูล ${ยังไม่สำรวจ} รายการที่รออยู่เลยหรือไม่?`)) {
                    processSyncQueue();
                }
            }
        }

        // ============================================
        // Auto-check and sync on app startup
        // ============================================

        async function checkAndSyncOnStartup() {
            console.log('ตรวจสอบข้อมูลที่รอซิงค์...');
            
            // โหลดคิวจาก localStorage
            loadSyncQueueFromStorage();
            
            // ตรวจสอบรูปภาพที่ยังไม่ได้ซิงค์
            try {
                const unsyncedImages = await getUnsyncedImages();
                const ยังไม่สำรวจCount = syncQueue.filter(i => i.status === 'ยังไม่สำรวจ').length;
                
                if (ยังไม่สำรวจCount > 0 || unsyncedImages.length > 0) {
                    const totalPending = ยังไม่สำรวจCount + unsyncedImages.length;
                    
                    showNotificationLeft(
                        `พบข้อมูลที่รอซิงค์ ${totalPending} รายการ`, 
                        'warning'
                    );
                    
                    // ถ้าออนไลน์ → เริ่มซิงค์ทันที
                    if (isOnline) {
                        setTimeout(() => {
                            showNotificationLeft('กำลังซิงค์ข้อมูล...', 'info');
                            processSyncQueue();
                        }, 1000);
                    } else {
                        showNotificationLeft('⚠️ อยู่ในโหมดออฟไลน์ - รอการเชื่อมต่อ', 'warning');
                    }
                }
            } catch (err) {
                console.error('Error checking ยังไม่สำรวจ data:', err);
            }
        }

        // ✅ มีเพียงระบบใหม่
        // ใช้ window.addEventListener แทน  เพื่อป้องกันการทับซ้อน
        window.addEventListener('load', async () => {
            // 1. เริ่มต้นแผนที่และไอคอน
            initMap();
            lucide.createIcons();
            loadExistingData();
            
            // 2. ตรวจสอบและซิงค์ข้อมูลที่ค้างอยู่ (สำคัญสำหรับระบบออฟไลน์)
            await checkAndSyncOnStartup();
            
            // 3. อัปเดตจุดแจ้งเตือนจำนวนข้อมูลที่รอซิงค์
            setInterval(() => {
                updateSyncBadge();
            }, 1000);

        window.addEventListener('beforeunload', () => {
            stopRealtimeAutoUpdate(); // ✅ หยุดระบบใหม่
        });
            
            // 4. ลงทะเบียน Service Worker สำหรับแคชไทล์
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('/sw.js')
                    .then((registration) => {
                        console.log('Service Worker registered:', registration.scope);
                    })
                    .catch((error) => {
                        console.log('Service Worker registration failed:', error);
                    });
            }
        });

        // แสดงจำนวนข้อมูลที่รอซิงค์ในปุ่มฟันเฟือง
        function updateSyncBadge() {
            const ยังไม่สำรวจ = syncQueue.filter(i => i.status === 'ยังไม่สำรวจ').length;
            const badge = document.getElementById('settings-badge');
            
            if (ยังไม่สำรวจ > 0) {
                badge.textContent = ยังไม่สำรวจ > 9 ? '9+' : ยังไม่สำรวจ;
                badge.classList.remove('hidden');
            } else {
                badge.classList.add('hidden');
            }
        }

        // เรียกใช้ทุกครั้งที่มีการเปลี่ยนแปลงคิว
        setInterval(updateSyncBadge, 1000);

        // ============================================
        // IndexedDB Storage for Images
        // ============================================

        let dbPromise = null;

        // เปิด/สร้าง IndexedDB
        function openDatabase() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('SurveyAppDB', 2);
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    
                    // สร้าง Store สำหรับรูปภาพ
                    if (!db.objectStoreNames.contains('images')) {
                        const imageStore = db.createObjectStore('images', { 
                            keyPath: 'id' 
                        });
                        imageStore.createIndex('timestamp', 'timestamp');
                        imageStore.createIndex('synced', 'synced');
                    }
                    
                    // สร้าง Store สำหรับข้อมูลซิงค์
                    if (!db.objectStoreNames.contains('syncQueue')) {
                        const queueStore = db.createObjectStore('syncQueue', { 
                            keyPath: 'id' 
                        });
                        queueStore.createIndex('status', 'status');
                        queueStore.createIndex('timestamp', 'timestamp');
                    }
                };
                
                request.onsuccess = (event) => {
                    resolve(event.target.result);
                };
                
                request.onerror = (event) => {
                    reject(event.target.error);
                };
            });
        }

        // บันทึกรูปภาพลงใน IndexedDB (พร้อมตรวจสอบพื้นที่และจัดการข้อผิดพลาด)
        async function saveImageToDB(imageData, filename, relatedId, type) {
            try {
                // ✅ ตรวจสอบขนาดรูปภาพก่อนบันทึก
                const estimateSize = Math.ceil(imageData.length * 0.75); // ประมาณขนาดจริง (ลบ 25% จาก base64)
                
                if (estimateSize > 3 * 1024 * 1024) { // เตือนถ้าเกิน 3MB
                    showNotificationLeft('⚠️ รูปภาพใหญ่เกินไป อาจใช้พื้นที่มาก', 'warning');
                }
                
                const db = await openDatabase();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction('images', 'readwrite');
                    const store = transaction.objectStore('images');
                    
                    const imageRecord = {
                        id: Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                        filename: filename,
                         imageData, // base64 string
                        relatedId: relatedId,
                        type: type, // 'building' หรือ 'sign'
                        timestamp: new Date().toISOString(),
                        synced: false,
                        retryCount: 0
                    };
                    
                    const request = store.add(imageRecord);
                    
                    request.onsuccess = () => {
                        console.log(`บันทึกรูปภาพสำเร็จ: ${filename} (${Math.round(estimateSize / 1024)} KB)`);
                        resolve(imageRecord.id);
                    };
                    
                    request.onerror = (event) => {
                        // ✅ ตรวจสอบข้อผิดพลาดพื้นที่เต็ม
                        if (event.target.error && event.target.error.name === 'QuotaExceededError') {
                            showNotificationLeft(
                                '❌ พื้นที่เก็บข้อมูลเต็ม! โปรดซิงค์ข้อมูลก่อนถ่ายรูปเพิ่ม',
                                'error'
                            );
                            reject(new Error('Storage quota exceeded'));
                        } else {
                            console.error('Error saving image to DB:', event.target.error);
                            reject(event.target.error);
                        }
                    };
                });
            } catch (err) {
                console.error('Error in saveImageToDB:', err);
                throw err;
            }
        }

        async function checkStorageSpace() {
            try {
                if ('storage' in navigator && 'estimate' in navigator.storage) {
                    const estimate = await navigator.storage.estimate();
                    const usage = estimate.usage || 0;
                    const quota = estimate.quota || 50 * 1024 * 1024; // 50MB default
                    
                    const usagePercent = (usage / quota) * 100;
                    
                    if (usagePercent > 80) {
                        showNotificationLeft(
                            `⚠️ พื้นที่เก็บข้อมูลเหลือน้อย (${Math.round(100 - usagePercent)}%)`,
                            'warning'
                        );
                    }
                    
                    if (usagePercent > 95) {
                        showNotificationLeft(
                            `❌ พื้นที่เก็บข้อมูลเกือบเต็ม! โปรดซิงค์ข้อมูล`,
                            'error'
                        );
                    }
                }
            } catch (err) {
                console.error('Error checking storage:', err);
            }
        }

        // ============================================
        // ฟังก์ชันดึงรูปภาพที่ยังไม่ได้ซิงค์ (แก้ไขแล้ว - ไม่ใช้ดัชนี boolean)
        // ============================================
        async function getUnsyncedImages() {
            const db = await openDatabase();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction('images', 'readonly');
                const store = transaction.objectStore('images');
                const request = store.openCursor(); // ✅ ไม่ใช้ดัชนี
                const unsyncedImages = [];
                
                request.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        const image = cursor.value;
                        // ✅ ตรวจสอบค่าโดยตรง
                        if (!image.synced || image.synced === false) {
                            unsyncedImages.push(image);
                        }
                        cursor.continue();
                    } else {
                        resolve(unsyncedImages);
                    }
                };
                
                request.onerror = (event) => {
                    console.error('Error getting unsynced images:', event.target.error);
                    reject(event.target.error);
                };
            });
        }

        // ============================================
        // ฟังก์ชันซิงค์รูปภาพ (แก้ไขแล้ว - ส่งให้ตรงกับเซิร์ฟเวอร์)
        // ============================================
        async function syncPendingImages() {
            try {
                const unsyncedImages = await getUnsyncedImages();
                if (unsyncedImages.length === 0) {
                    console.log('ℹ️ ไม่มีรูปภาพที่รอซิงค์');
                    return;
                }
                
                showNotificationLeft(`กำลังอัปโหลดรูปภาพ (${unsyncedImages.length} รูป)...`, 'info');
                console.log(`📤 เริ่มอัปโหลดรูปภาพ (${unsyncedImages.length} รูป)`);
                
                let successCount = 0;
                
                for (const image of unsyncedImages) {
                    try {
                        console.log(`📤 ส่งรูปภาพ: ${image.filename} (${image.relatedId})`);
                        
                        // ✅ ใช้ชื่อไฟล์ที่บันทึกไว้ใน IndexedDB (ไม่ต้องแยกอีก)
                        const payload = {};
                        
                        const body = new URLSearchParams();
                        body.append('action', 'update');
                        body.append('type', image.type);
                        body.append('rowKey', image.relatedId);
                        body.append('payload', JSON.stringify(payload));
                        body.append('image', image.imageData);
                        body.append('fileName', image.filename); // ✅ ใช้ชื่อที่ตั้งไว้แล้ว
                        
                        const res = await fetch(CONFIG.SCRIPT_URL.trim(), {
                            method: 'POST',
                            body,
                            timeout: 60000
                        });
                        
                        let result = null;
                        try {
                            result = await res.json();
                        } catch (parseErr) {
                            console.error(`❌ ไม่สามารถอ่านคำตอบจากเซิร์ฟเวอร์:`, parseErr);
                        }
                        
                        if (res.ok && result && (result.success === true || result.status === 200)) {
                            await markImageAsSynced(image.id);
                            successCount++;
                            console.log(`✅ อัปโหลดรูปภาพสำเร็จ: ${image.filename}`);
                            showNotificationLeft(`อัปโหลดรูปภาพ ${image.filename} สำเร็จ!`, 'success');
                        } else {
                            const errorMsg = result?.error || result?.message || `HTTP ${res.status}`;
                            console.error(`❌ อัปโหลดรูปภาพล้มเหลว: ${image.filename} - ${errorMsg}`);
                            
                            image.retryCount = (image.retryCount || 0) + 1;
                            if (image.retryCount >= 5) {
                                console.error(`❌ ยกเลิกหลังลอง ${image.retryCount} ครั้ง: ${image.filename}`);
                            }
                            
                            showNotificationLeft(`❌ ล้มเหลว: ${image.filename}`, 'error');
                        }
                    } catch (err) {
                        console.error(`❌ ข้อผิดพลาดในการอัปโหลด ${image.filename}:`, err);
                        image.retryCount = (image.retryCount || 0) + 1;
                        showNotificationLeft(`⚠️ ข้อผิดพลาด: ${image.filename}`, 'error');
                    }
                    
                    // รอ 2 วินาทีระหว่างส่งแต่ละรูป
                    await new Promise(resolve => setTimeout(resolve, 2000));
                }
                
                // ลบรูปภาพที่ซิงค์สำเร็จแล้ว
                await cleanupSyncedImages();
                
                if (successCount > 0) {
                    console.log(`✅ อัปโหลดรูปภาพสำเร็จทั้งหมด ${successCount}/${unsyncedImages.length} รูป`);
                }
            } catch (err) {
                console.error('❌ ข้อผิดพลาดในการซิงค์รูปภาพ:', err);
                showNotificationLeft('เกิดข้อผิดพลาดในการอัปโหลดรูปภาพ', 'error');
            }
        }

        // ============================================
        // ฟังก์ชันลบรูปภาพที่ซิงค์สำเร็จแล้ว (แก้ไขแล้ว - ไม่ใช้ดัชนี)
        // ============================================
        async function cleanupSyncedImages() {
            const db = await openDatabase();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction('images', 'readwrite');
                const store = transaction.objectStore('images');
                const request = store.openCursor(); // ✅ ไม่ใช้ดัชนี
                
                request.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        const image = cursor.value;
                        // ✅ ตรวจสอบค่าโดยตรง
                        if (image.synced === true) {
                            store.delete(cursor.primaryKey);
                        }
                        cursor.continue();
                    } else {
                        resolve();
                    }
                };
                
                request.onerror = (event) => {
                    console.error('Error cleaning up synced images:', event.target.error);
                    reject(event.target.error);
                };
            });
        }


        // ทำเครื่องหมายว่ารูปภาพซิงค์สำเร็จแล้ว
        async function markImageAsSynced(imageId) {
            const db = await openDatabase();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction('images', 'readwrite');
                const store = transaction.objectStore('images');
                
                const request = store.get(imageId);
                
                request.onsuccess = (event) => {
                    const image = event.target.result;
                    if (image) {
                        image.synced = true;
                        const updateRequest = store.put(image);
                        updateRequest.onsuccess = () => resolve();
                        updateRequest.onerror = () => reject(updateRequest.error);
                    } else {
                        reject(new Error('Image not found'));
                    }
                };
                
                request.onerror = () => {
                    reject(request.error);
                };
            });
        }

        // ลบรูปภาพที่ซิงค์สำเร็จแล้ว
        async function cleanupSyncedImages() {
            const db = await openDatabase();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction('images', 'readwrite');
                const store = transaction.objectStore('images');
                
                // ✅ ใช้ openCursor แทนการใช้ดัชนี (แก้ไขปัญหา IDBKeyRange)
                const request = store.openCursor();
                
                request.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        const image = cursor.value;
                        // ✅ ตรวจสอบค่าด้วยตนเอง
                        if (image.synced === true) {
                            store.delete(cursor.primaryKey);
                        }
                        cursor.continue();
                    } else {
                        resolve();
                    }
                };
                
                request.onerror = (event) => {
                    console.error('Error cleaning up synced images:', event.target.error);
                    reject(event.target.error);
                };
            });
        }

        // สร้างฟังก์ชันแสดงแจ้งเตือนฝั่งซ้าย
        function showNotificationLeft(message, type = 'info') {
            // ลบแจ้งเตือนเก่า
            const oldNotif = document.querySelector('.notification-left');
            if (oldNotif) oldNotif.remove();
            
            // กำหนดสีตามประเภท
            let bgColor = 'bg-blue-500';
            let icon = 'loader';
            
            if (type === 'success') {
                bgColor = 'bg-green-500';
                icon = 'check-circle';
            } else if (type === 'error') {
                bgColor = 'bg-red-500';
                icon = 'alert-circle';
            } else if (type === 'warning') {
                bgColor = 'bg-yellow-500';
                icon = 'alert-triangle';
            }
            
            // สร้างแจ้งเตือน
            const notif = document.createElement('div');
            notif.className = `fixed top-4 left-4 px-6 py-3 rounded-lg shadow-lg z-[2000] animate-fade-in notification-left ${bgColor} text-white font-bold flex items-center gap-2`;
            notif.innerHTML = `
                <i data-lucide="${icon}" class="w-5 h-5"></i>
                <span>${message}</span>
            `;
            
            document.body.appendChild(notif);
            lucide.createIcons({ elements: notif.querySelectorAll('[data-lucide]') });
            
            // ซ่อนอัตโนมัติหลัง 3 วินาที
            setTimeout(() => {
                notif.classList.add('animate-fade-out');
                setTimeout(() => notif.remove(), 300);
            }, 500);
        }

 
        // ============================================
        // อัปเดตข้อมูลแบบเรียลไทม์
        // ============================================
        async function realtimeUpdate() {
            if (!navigator.onLine || isUpdating) return;
            
            isUpdating = true;
            try {
                const res = await fetch(`${CONFIG.SCRIPT_URL}?action=getData&t=${Date.now()}`);
                const newData = await res.json();
                
                // ✅ แก้ไข: ลบการตรวจสอบ timestamp ออก (เซิร์ฟเวอร์ไม่ได้ส่งมา)
                if (!newData.buildings || !newData.signs) { // ← ลบ newData.timestamp ||
                    console.warn('ข้อมูลจากเซิร์ฟเวอร์ไม่สมบูรณ์');
                    return;
                }
                
                // ตรวจสอบการเปลี่ยนแปลง
                const buildingChanges = detectChanges(allBuildings, newData.buildings);
                const signChanges = detectChanges(allSigns, newData.signs);
                
                // อัปเดตแผนที่และตาราง
                if (buildingChanges.total > 0) {
                    applyChanges(buildingChanges, 'building');
                    showUpdateNotification(buildingChanges, 'สิ่งปลูกสร้าง');
                }
                
                if (signChanges.total > 0) {
                    applyChanges(signChanges, 'sign');
                    showUpdateNotification(signChanges, 'ป้าย');
                }
                
                // อัปเดตข้อมูลแคช
                allBuildings = newData.buildings;
                allSigns = newData.signs;
                
                console.log('✅ อัปเดตข้อมูลเรียลไทม์สำเร็จ');
            } catch (err) {
                console.error('❌ ข้อผิดพลาดในการอัปเดต:', err);
            } finally {
                isUpdating = false;
            }
        }

        // ตรวจจับการเปลี่ยนแปลง
        function detectChanges(oldData, newData) {
            const oldMap = new Map(oldData.map(item => [item.id || item._row_num, item]));
            const newMap = new Map(newData.map(item => [item.id || item._row_num, item]));
            
            const added = [];
            const updated = [];
            const deleted = [];
            
            // หาข้อมูลที่เพิ่มใหม่
            newData.forEach(item => {
                const id = item.id || item._row_num;
                if (!oldMap.has(id)) added.push(item);
            });
            
            // หาข้อมูลที่อัปเดต
            newData.forEach(item => {
                const id = item.id || item._row_num;
                const oldItem = oldMap.get(id);
                if (oldItem && JSON.stringify(oldItem) !== JSON.stringify(item)) {
                    updated.push(item);
                }
            });
            
            // หาข้อมูลที่ถูกลบ
            oldData.forEach(item => {
                const id = item.id || item._row_num;
                if (!newMap.has(id)) deleted.push(item);
            });
            
            return { 
                added, 
                updated, 
                deleted,
                total: added.length + updated.length + deleted.length
            };
        }

        // ประยุกต์การเปลี่ยนแปลง
        function applyChanges(changes, type) {
            // ลบมาร์กเกอร์ที่ถูกลบ
            changes.deleted.forEach(item => {
                surveyLayers.eachLayer(layer => {
                    if (layer._popupData && 
                        (layer._popupData.id === item.id || layer._popupData._row_num === item._row_num)) {
                        surveyLayers.removeLayer(layer);
                    }
                });
            });
            
            // อัปเดตหรือเพิ่มมาร์กเกอร์ใหม่
            [...changes.added, ...changes.updated].forEach(item => {
                if (!item.lat_long) return;
                
                const coords = item.lat_long.split(',').map(Number);
                if (coords.length < 2 || isNaN(coords[0]) || isNaN(coords[1])) return;
                
                // ค้นหามาร์กเกอร์ที่มีอยู่
                let existingMarker = null;
                surveyLayers.eachLayer(layer => {
                    if (layer._popupData && 
                        (layer._popupData.id === item.id || layer._popupData._row_num === item._row_num)) {
                        existingMarker = layer;
                    }
                });
                
                if (existingMarker) {
                    // อัปเดตมาร์กเกอร์ที่มีอยู่
                    existingMarker.setLatLng(L.latLng(coords[0], coords[1]));
                    existingMarker._popupData = item;
                    setupMarkerPopup(existingMarker, item, type);
                } else {
                    // เพิ่มมาร์กเกอร์ใหม่
                    const marker = createCircleMarker(L.latLng(coords[0], coords[1]), type, isEditMode);
                    marker._popupData = item;
                    setupMarkerPopup(marker, item, type);
                    marker.addTo(surveyLayers);
                    if (isEditMode) enableMarkerDragging(marker, item);
                }
            });
            
            // อัปเดตตาราง
            if (type === 'building') renderBuildingTable();
            else renderSignTable();
        }

        // แสดงการแจ้งเตือน
        function showUpdateNotification(changes, typeName) {
            if (changes.total === 0) return;
            
            let message = `🔄 มีการอัปเดต${typeName} `;
            const parts = [];
            if (changes.added.length > 0) parts.push(`เพิ่ม ${changes.added.length}`);
            if (changes.updated.length > 0) parts.push(`แก้ไข ${changes.updated.length}`);
            if (changes.deleted.length > 0) parts.push(`ลบ ${changes.deleted.length}`);
            
            message += parts.join(', ');
            showNotificationLeft(message, 'info');
        }

        // ============================================
        // เริ่มระบบอัปเดตอัตโนมัติ
        // ============================================
        function startRealtimeAutoUpdate() {
            if (autoUpdateInterval) clearInterval(autoUpdateInterval);
            
            autoUpdateInterval = setInterval(() => {
                if (!isUpdating && navigator.onLine) {
                    realtimeUpdate();
                }
            }, 5000); // 5 วินาที
            
            console.log('✅ เริ่มระบบอัปเดตเรียลไทม์ทุก 5 วินาที');
        }

        // ============================================
















        // ประยุกต์การเปลี่ยนแปลงเฉพาะจุด
        async function applyDeltaUpdates(records, type) {
            for (const record of records) {
                const id = record.id || record._row_num;
                
                // ค้นหามาร์กเกอร์ที่มีอยู่
                let existingMarker = null;
                surveyLayers.eachLayer(layer => {
                    if (layer._popupData && (layer._popupData.id === id || layer._popupData._row_num === id)) {
                        existingMarker = layer;
                    }
                });
                
                if (existingMarker) {
                    // ✅ อัปเดตมาร์กเกอร์ที่มีอยู่ (ไม่ลบรีโหลดใหม่ทั้งหมด)
                    existingMarker._popupData = { ...existingMarker._popupData, ...record };
                    setupMarkerPopup(existingMarker, existingMarker._popupData, type);
                    
                    // อัปเดตพิกัดถ้ามีการเปลี่ยนแปลง
                    if (record.lat_long && record.lat_long !== existingMarker._popupData.lat_long) {
                        const coords = record.lat_long.split(',').map(Number);
                        existingMarker.setLatLng(L.latLng(coords[0], coords[1]));
                    }
                } else {
                    // ✅ เพิ่มมาร์กเกอร์ใหม่
                    if (record.lat_long) {
                        const coords = record.lat_long.split(',').map(Number);
                        const marker = createCircleMarker(L.latLng(coords[0], coords[1]), type, isEditMode);
                        marker._popupData = record;
                        setupMarkerPopup(marker, record, type);
                        marker.addTo(surveyLayers);
                        if (isEditMode) enableMarkerDragging(marker, record);
                    }
                }
            }
            
            // อัปเดตตารางข้อมูล
            if (type === 'building') {
                allBuildings = [...allBuildings.filter(b => !records.some(r => r.id === b.id)), ...records];
                renderBuildingTable();
            } else {
                allSigns = [...allSigns.filter(s => !records.some(r => r.id === s.id)), ...records];
                renderSignTable();
            }
        }

        // ลบมาร์กเกอร์ที่ถูกลบ
        function removeDeletedMarkers(deletedIds) {
            surveyLayers.eachLayer(layer => {
                if (layer._popupData && deletedIds.includes(layer._popupData.id || layer._popupData._row_num)) {
                    surveyLayers.removeLayer(layer);
                }
            });
            
            // อัปเดตตาราง
            allBuildings = allBuildings.filter(b => !deletedIds.includes(b.id));
            allSigns = allSigns.filter(s => !deletedIds.includes(s.id));
            renderBuildingTable();
            renderSignTable();
        }

        // อัปเดตเฉพาะมาร์กเกอร์ที่เปลี่ยนแปลง
        async function updateChangedMarkers(data) {
            const currentMarkers = {};
            
            // เก็บข้อมูลมาร์กเกอร์ปัจจุบัน
            surveyLayers.eachLayer(layer => {
                if (layer._popupData && layer._popupData.id) {
                    currentMarkers[layer._popupData.id] = layer;
                }
            });
            
            // ล้างมาร์กเกอร์ทั้งหมด
            surveyLayers.clearLayers();
            
            // สร้างมาร์กเกอร์ใหม่จากข้อมูล
            const allData = [...(data.buildings || []), ...(data.signs || [])];
            
            for (const item of allData) {
                if (!item.lat_long) continue;
                
                const coords = item.lat_long.split(',').map(Number);
                if (coords.length < 2 || isNaN(coords[0]) || isNaN(coords[1])) continue;
                
                const type = item.building_c ? 'building' : 'sign';
                const latLng = L.latLng(coords[0], coords[1]);
                
                // ตรวจสอบว่ามีมาร์กเกอร์เดิมหรือไม่
                const existingMarker = currentMarkers[item.id];
                
                if (existingMarker) {
                    // อัปเดตข้อมูลในมาร์กเกอร์เดิม
                    existingMarker.setLatLng(latLng);
                    existingMarker._popupData = item;
                    setupMarkerPopup(existingMarker, item, type);
                    existingMarker.addTo(surveyLayers);
                    
                    if (isEditMode) enableMarkerDragging(existingMarker, item);
                } else {
                    // สร้างมาร์กเกอร์ใหม่
                    const m = createCircleMarker(latLng, type, isEditMode);
                    setupMarkerPopup(m, item, type);
                    m.addTo(surveyLayers);
                    
                    if (isEditMode) enableMarkerDragging(m, item);
                }
            }
        }


        // ใช้ MarkerCluster สำหรับมาร์กเกอร์จำนวนมาก
        let markerCluster = null;

        function initMarkerClustering() {
            // สร้าง MarkerCluster Group
            markerCluster = L.markerClusterGroup({
                maxClusterRadius: 80, // ระยะห่างที่จะรวมเป็นคลัสเตอร์
                disableClusteringAtZoom: 16, // ปิดคลัสเตอร์เมื่อซูมใกล้
                chunkedLoading: true, // โหลดแบบแบ่งชิ้นส่วน
                chunkInterval: 200, // เวลาในการโหลดแต่ละชิ้น (มิลลิวินาที)
                chunkDelay: 50 // ดีเลย์ระหว่างการโหลด
            });
            
            // เพิ่มมาร์กเกอร์ลงในคลัสเตอร์แทนการเพิ่มลงแผนที่โดยตรง
            markerCluster.addTo(map);
        }

        // เมื่อสร้างมาร์กเกอร์ใหม่
        function createCircleMarker(latlng, type, isDraggable = false) {
            const className = type === 'building' ? 'circle-building' : 'circle-sign';
            const icon = L.divIcon({
                className: `circle-marker ${className}`,
                iconSize: [14, 14],
                iconAnchor: [7, 7]
            });
            const marker = L.marker(latlng, {
                icon: icon,
                draggable: isDraggable, // ✅ ตั้งค่าให้ลากได้
                zIndexOffset: 1000
            });
            
            // เก็บข้อมูลไว้ในมาร์กเกอร์
            marker._popupData = null;
            
            return marker;
        }

        // ============================================
        // ดาวน์โหลดรูปทั้งหมดจากสเปรดชีต
        // ============================================
        document.addEventListener('DOMContentLoaded', function() {
            const downloadBtn = document.getElementById('download-all-images');
            if (downloadBtn) {
                downloadBtn.addEventListener('click', async function() {
                    try {
                        showNotificationLeft('กำลังโหลดข้อมูลรูปภาพ...', 'info');
                        
                        // ดึงข้อมูลจากสเปรดชีต
                        const response = await fetch(CONFIG.SCRIPT_URL + '?action=getData');
                        const data = await response.json();
                        
                        // รวมรูปจากทั้งอาคารและป้าย
                        const allImages = [
                            ...data.buildings.filter(b => b.image && b.image.includes('http')),
                            ...data.signs.filter(s => s.image && s.image.includes('http'))
                        ];
                        
                        if (allImages.length === 0) {
                            showNotificationLeft('⚠️ ไม่พบรูปภาพในระบบ', 'warning');
                            return;
                        }
                        
                        showNotificationLeft(`กำลังดาวน์โหลด ${allImages.length} รูปภาพ...`, 'info');
                        
                        // ดาวน์โหลดทีละรูป
                        for (let i = 0; i < allImages.length; i++) {
                            const item = allImages[i];
                            const imageUrl = item.image;
                            const fileName = item.picture || `image_${i + 1}.jpg`;
                            
                            try {
                                // ดาวน์โหลดรูป
                                const imgResponse = await fetch(imageUrl);
                                const blob = await imgResponse.blob();
                                
                                // สร้างลิงก์ดาวน์โหลด
                                const link = document.createElement('a');
                                link.href = URL.createObjectURL(blob);
                                link.download = fileName;
                                document.body.appendChild(link);
                                link.click();
                                document.body.removeChild(link);
                                URL.revokeObjectURL(link.href);
                                
                                console.log(`✅ ดาวน์โหลด: ${fileName}`);
                                
                                // รอ 500ms ระหว่างดาวน์โหลดแต่ละรูป
                                if (i < allImages.length - 1) {
                                    await new Promise(resolve => setTimeout(resolve, 500));
                                }
                            } catch (err) {
                                console.error(`❌ ดาวน์โหลด ${fileName} ล้มเหลว:`, err);
                                showNotificationLeft(`⚠️ ดาวน์โหลด ${fileName} ล้มเหลว`, 'error');
                            }
                        }
                        
                        showNotificationLeft(`✅ ดาวน์โหลดรูปภาพทั้งหมด (${allImages.length} รูป) เสร็จสิ้น!`, 'success');
                    } catch (err) {
                        console.error('❌ ข้อผิดพลาด:', err);
                        showNotificationLeft('❌ ดาวน์โหลดล้มเหลว: ' + err.message, 'error');
                    }
                });
            }
        });

        // ฟังก์ชันโหลดมาร์กเกอร์เฉพาะที่มองเห็น + buffer
        function loadVisibleMarkers() {
            // เก็บจุดชั่วคราวทั้งหมดก่อนล้าง
            const ยังไม่สำรวจMarkers = [];
            if (markerCluster) {
                markerCluster.eachLayer(layer => {
                    if (layer._popupData) {
                        if (layer._popupData.queued || layer._popupData.tempMarker) {
                            ยังไม่สำรวจMarkers.push({
                                latlng: layer.getLatLng(),
                                data: layer._popupData,
                                type: layer._popupData.type
                            });
                        }
                    }
                });
            } else {
                surveyLayers.eachLayer(layer => {
                    if (layer._popupData) {
                        if (layer._popupData.queued || layer._popupData.tempMarker) {
                            ยังไม่สำรวจMarkers.push({
                                latlng: layer.getLatLng(),
                                data: layer._popupData,
                                type: layer._popupData.type
                            });
                        }
                    }
                });
            }
            
            const bounds = map.getBounds();
            const bufferRatio = isMobile() ? 0.5 : 1.0;
            const bufferedBounds = bounds.pad(bufferRatio);
            
            // ล้างมาร์กเกอร์ทั้งหมด
            if (markerCluster) {
                markerCluster.clearLayers();
            } else {
                surveyLayers.clearLayers();
            }
            
            // โหลดเฉพาะมาร์กเกอร์ที่อยู่ในขอบเขต + buffer
            allBuildings.forEach(r => {
                if (!r.lat_long) return;
                const coords = r.lat_long.split(',').map(Number);
                if (coords.length < 2 || isNaN(coords[0]) || isNaN(coords[1])) return;
                const latLng = L.latLng(coords[0], coords[1]);
                if (!bufferedBounds.contains(latLng)) return;
                
                // ✅ ตรวจสอบว่าจุดนี้กำลังถูกย้ายหรือไม่
                const recordKey = r._row_num || r.id;
                if (markersBeingMoved.has(recordKey)) {
                    return; // ข้ามการสร้างจุดจริง
                }
                
                const m = createCircleMarker(latLng, 'building', isEditMode);
                setupMarkerPopup(m, r, 'building');
                if (isEditMode) enableMarkerDragging(m, r);
                if (markerCluster) {
                    markerCluster.addLayer(m);
                } else {
                    m.addTo(surveyLayers);
                }
            });
            
            allSigns.forEach(r => {
                if (!r.lat_long) return;
                const coords = r.lat_long.split(',').map(Number);
                if (coords.length < 2 || isNaN(coords[0]) || isNaN(coords[1])) return;
                const latLng = L.latLng(coords[0], coords[1]);
                if (!bufferedBounds.contains(latLng)) return;
                
                // ✅ ตรวจสอบว่าจุดนี้กำลังถูกย้ายหรือไม่
                const recordKey = r._row_num || r.id; // ✅ เพิ่มบรรทัดนี้
                if (markersBeingMoved.has(recordKey)) { // ✅ แก้เป็น recordKey
                    return;
                }
                
                const m = createCircleMarker(latLng, 'sign', isEditMode);
                setupMarkerPopup(m, r, 'sign');
                if (isEditMode) enableMarkerDragging(m, r);
                if (markerCluster) {
                    markerCluster.addLayer(m);
                } else {
                    m.addTo(surveyLayers);
                }
            });
            
            // เพิ่มจุดชั่วคราวกลับเข้ามา
            ยังไม่สำรวจMarkers.forEach(marker => {
                const m = createCircleMarker(marker.latlng, marker.type, isEditMode);
                m._popupData = marker.data;
                setupMarkerPopup(m, marker.data, marker.type);
                if (markerCluster) {
                    markerCluster.addLayer(m);
                } else {
                    m.addTo(surveyLayers);
                }
                if (isEditMode) enableMarkerDragging(m, marker.data);
            });
        }

        // เรียกใช้เมื่อเลื่อนหรือซูมแผนที่
        map.on('moveend', loadVisibleMarkers);
        map.on('zoomend', loadVisibleMarkers);

        // ============================================
        // 1. แก้ไขฟังก์ชัน refreshData (ใช้ระบบใหม่)
        // ============================================
        function refreshData() {
            const refreshBtn = document.getElementById('btn-refresh');
            const refreshIcon = document.getElementById('refresh-icon');
            
            disableRefreshButton();
            refreshIcon.classList.add('animate-spin');
            
            // ✅ เปลี่ยนจาก smartLoadData() เป็น loadExistingData()
            loadExistingData().finally(() => {
                setTimeout(() => {
                    refreshIcon.classList.remove('animate-spin');
                    enableRefreshButton();
                }, 500);
            });
        }

        // ============================================
        // 2. วาง beforeunload ที่ระดับบนสุด (นอก window.load)
        // ============================================
        window.addEventListener('beforeunload', () => {
            stopRealtimeAutoUpdate(); // ✅ หยุดระบบใหม่
        });

        // ============================================
        // 3. เริ่มต้นแอป (วางด้านล่าง beforeunload)
        // ============================================
        window.addEventListener('load', async () => {
            initMap();
            lucide.createIcons();
            
            // ✅ เพิ่ม await และเริ่มระบบอัปเดต
            await loadExistingData(); // ← เพิ่ม await
            startRealtimeAutoUpdate(); // ← เพิ่มบรรทัดนี้ (สำคัญที่สุด!)
            
            await checkAndSyncOnStartup();
            setInterval(updateSyncBadge, 1000);
            
            // ลงทะเบียน Service Worker
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => console.log('Service Worker registered:', registration.scope))
                    .catch(error => console.log('Service Worker registration failed:', error));
            }
        });

        // ฟังก์ชันแสดงชื่อไฟล์ที่เลือก
        function updateFileName(input, fieldId) {
        const filenameSpan = document.getElementById(`filename-${fieldId}`);
        if (!filenameSpan) return;
        if (input.files && input.files[0]) {
        const filename = input.files[0].name;
        filenameSpan.textContent = filename;
        filenameSpan.classList.remove('hidden');
        filenameSpan.classList.add('bg-blue-100', 'text-blue-800');
        } else {
        filenameSpan.classList.add('hidden');
        }
        }

    </script>
</body>

</html>
