<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="โนนไทย">

    <meta name="theme-color" content="#2563eb">
    <title>โนนไทย</title>
    <link rel="manifest" href="manifest.json">
    <link rel="icon" href="static/icons/lb.ico" type="image/x-icon"> <!-- แก้เป็นพาธสัมพัทธ์ -->
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <style>
        body, html { height: 100%; margin: 0; padding: 0; overflow: hidden; font-family: sans-serif; }
        #map { height: 100vh; width: 100vw; z-index: 0; }
        
        /* ข้อ 1: ปรับแต่งเป้าเล็งใหม่ (ใหญ่ขึ้น 20%, หนาขึ้น, สูงขึ้น 15%) */
        .crosshair {
            position: absolute;
            top: 35%; /* สูงขึ้นจากกึ่งกลาง (50% - 15%) */
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 1000;
        }
        .crosshair-center {
            width: 6px; height: 6px;
            background-color: #ef4444;
            border-radius: 50%;
            position: absolute;
            top: 50%; left: 50%; transform: translate(-50%, -50%);
        }
        .crosshair-circle {
            width: 60px; height: 60px; /* ใหญ่ขึ้นจาก 50px */
            border: 3px solid rgba(239, 68, 68, 0.9); /* เส้นหนาขึ้น */
            border-radius: 50%;
            position: relative;
        }
        .crosshair-line { position: absolute; background-color: rgba(239, 68, 68, 0.9); }
        .line-v { width: 3px; height: 18px; left: 50%; transform: translateX(-50%); }
        .line-h { height: 3px; width: 18px; top: 50%; transform: translateY(-50%); }
        .v-top { top: -20px; } .v-bottom { bottom: -20px; }
        .h-left { left: -20px; } .h-right { right: -20px; }

        /* แก้ไขส่วน .side-panel ให้โปร่งใส */
        .side-panel { 
            transition: transform 0.3s ease-in-out; 
            transform: translateX(100%); 
            background: rgba(200, 200, 200, 1.0); /* โปร่งใส 95% */            
            z-index: 1010;
            box-shadow: -5px 0 25px rgba(0,0,0,0.15); /* เงาให้ดูดีขึ้น */
        }
        .form-label { 
            font-size: 0.85rem; /* ขนาดใหญ่ขึ้น */
            font-weight: 700; 
            color: #dc2626; /* สีแดง */
            margin-bottom: 0.2rem; /* เพิ่มระยะห่าง */
            display: block;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.8); /* เงาสีขาว */
        }
        .form-input { 
            width: 100%; 
            padding: 0.5rem 0.75rem; /* เพิ่ม padding */
            font-size: 0.9rem; /* ขนาดตัวหนังสือใหญ่ขึ้น */
            font-weight: 600; /* ตัวหนา */
            color: #2563eb; /* สีน้ำเงิน */
            background-color: rgba(255, 255, 255, 0.6); /* พื้นหลังโปร่งใส */
            border: 1.5px solid #d1d5db; /* เส้นหนาขึ้น */
            border-radius: 0.5rem; 
            outline: none;
            transition: border-color 0.2s ease;
        }
        .form-input:focus {
            border-color: #2563eb;
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2); /* เงาชัดเจนขึ้น */
        }
        .form-input::placeholder {
            color: #9ca3af; /* สีเทาอ่อนสำหรับ placeholder */
            font-style: italic;
        }
        .side-panel.open { transform: translateX(0); }
        
        .map-btn { background: white; border-radius: 10px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        .active-tool { background-color: #2563eb !important; color: white !important; border: 2px solid white; }
        .active-edit { background-color: #2563eb !important; color: white !important; border: 2px solid white !important; }

        /* ข้อ 2: ปุ่มยืนยันเหนือปุ่มบวก (ระยะห่าง = เส้นผ่าศูนย์กลางปุ่มบวก 70px) */
        .confirm-btn-overlay {
        position: absolute;
        bottom: calc(2.5rem + 4.375rem + 4.375rem); /* bottom-10 (40px) + ความสูงปุ่ม (70px) + ระยะห่าง (70px) */
        left: 50%;
        transform: translateX(-50%);
        z-index: 1005;
        }
        /* สไตล์สำหรับเมนูฟันเฟือง */
        #settings-menu button {
          opacity: 0;
          transform: translateY(-20px);
          transition: all 0.3s ease;
        }

        #settings-menu button:hover {
          transform: translateY(0) scale(1.05) !important;
        }
        /* ========== แอนิเมชันเลื่อนขึ้น/ลง + ศูนย์กลางสำหรับเป้าเล็งและปุ่มบวก ========== */
        #crosshair {
          transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275),
                      opacity 0.6s ease;
          transform: translate(-50%, -50%) translateY(100vh); /* รวมศูนย์กลาง + เลื่อนจากล่าง */
          opacity: 0;
          will-change: transform, opacity;
        }
        #crosshair.visible {
          transform: translate(-50%, -50%) translateY(0); /* ศูนย์กลาง + ตำแหน่งปกติ */
          opacity: 1;
        }

        #add-trigger-container {
          transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275),
                      opacity 0.6s ease;
          transform: translateX(-50%) translateY(100vh); /* รวมศูนย์กลาง + เลื่อนจากล่าง */
          opacity: 0;
          will-change: transform, opacity;
        }
        #add-trigger-container.visible {
          transform: translateX(-50%) translateY(0); /* ศูนย์กลาง + ตำแหน่งปกติ */
          opacity: 1;
        }
        /* เพิ่มการเร่งฮาร์ดแวร์สำหรับแผนที่ */
        #map {
          transform: translate3d(0, 0, 0);
          will-change: transform;
        }

        /* ปิดการเรนเดอร์ชั่วคราวเมื่อเลื่อนแผนที่ (เพิ่มความลื่น) */
        .leaflet-zoom-anim .circle-marker,
        .leaflet-zoom-anim .crosshair {
          display: none !important;
        }
        /* สำหรับมือถือ: ความเร็วแอนิเมชันปรับให้เหมาะสม */
        @media (max-width: 768px) {
          #crosshair,
          #add-trigger-container {
            transition-duration: 0.35s;
          }
        }
        /* แอนิเมชันสำหรับปุ่มฟันเฟือง */
        @keyframes spin {
          from { transform: rotate(0deg); }
          to { transform: rotate(360deg); }
        }
        .animate-spin {
          animation: spin 0.5s linear;
        }

        /* สไตล์สำหรับแกลเลอรี่รูปภาพ */
        #image-gallery-modal {
        }

        #gallery-grid::-webkit-scrollbar {
          width: 8px;
        }

        #gallery-grid::-webkit-scrollbar-track {
          background: #1f2937;
        }

        #gallery-grid::-webkit-scrollbar-thumb {
          background: #4b5563;
          border-radius: 4px;
        }

        #gallery-grid::-webkit-scrollbar-thumb:hover {
          background: #6b7280;
        }
        /* แอนิเมชันสำหรับ Modal */
        @keyframes scale-in {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }
        @keyframes scale-out {
            from { opacity: 1; transform: scale(1); }
            to { opacity: 0; transform: scale(0.9); }
        }
        .animate-scale-in { animation: scale-in 0.2s ease-out; }
        .animate-scale-out { animation: scale-out 0.2s ease-in; }

        /* แอนิเมชันสำหรับแจ้งเตือน */
        @keyframes fade-in {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes fade-out {
            from { opacity: 1; transform: translateY(0); }
            to { opacity: 0; transform: translateY(-20px); }
        }
        .animate-fade-in { animation: fade-in 0.3s ease-out; }
        .animate-fade-out { animation: fade-out 0.3s ease-in; }
        /* สถานะปุ่มรีโหลด */
        @keyframes flash-green {
            0%, 100% { background-color: white; }
            50% { background-color: #22c55e; color: white; }
        }
        .refresh-success { animation: flash-green 0.5s ease 3; }

        /* แอนิเมชันสำหรับแจ้งเตือน */
        @keyframes fade-in {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes fade-out {
            from { opacity: 1; transform: translateY(0); }
            to { opacity: 0; transform: translateY(-20px); }
        }
        .animate-fade-in { animation: fade-in 0.3s ease-out; }
        .animate-fade-out { animation: fade-out 0.3s ease-in; }

        .circle-marker {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            border: 2px solid white;
            cursor: pointer;
        }
        .circle-building { background-color: #f59e0b; }
        .circle-sign { background-color: #4ade80; }
        
        .user-location-dot {
            width: 14px; height: 14px;
            background-color: #2563eb;
            border: 2px solid white;
            border-radius: 50%;
        }
        
        /* สไตล์สำหรับตาราง */
        .data-table-panel {
            position: fixed;
            bottom: 5px;
            left: 5px;
            width: 90%;
            max-width: 900px;
            max-height: 45vh; /* ✅ เปลี่ยนจาก 60vh เป็น 47vh */
            height: 45vh; /* ✅ เพิ่มบรรทัดนี้เพื่อให้ความสูงคงที่ 47% */
            background: white;
            border-radius: 6px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            z-index: 1003;
            display: none;
            flex-direction: column;
            overflow: hidden;
            transform: translateY(100%);
            transition: transform 0.3s ease;
        }
        .data-table-panel.open {
            display: flex;
            transform: translateY(0);
        }
        .data-table-panel.open {
            display: flex;
            transform: translateY(0);
        }
        .table-header {
            background: linear-gradient(135deg, #667eea 0%, #db2777 100%);
            color: white;
            padding: 0.1rem 0.5rem;
            min-height: 20px;       /* กำหนดความสูงต่ำสุดให้เล็กลง */
            height: 44px;  
            gap: 0.25rem;    
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .table-tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }
        .table-tab {
            padding: 6px 6px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s;
        }
        .table-tab.active {
            background: white;
            color: #667eea;
        }
        .table-tab:hover:not(.active) {
            background: rgba(255,255,255,0.2);
        }
        .table-content {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }
        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }
        .data-table th {
            background: #f3f4f6;
            padding: 6px 8px;
            text-align: left;
            font-weight: 700;
            color: #374151;
            border-bottom: 2px solid #e5e7eb;
            position: sticky;
            top: 0;
            z-index: 1;
        }
        .data-table td {
            padding: 4px;
            border-bottom: 1px solid #e5e7eb;
            vertical-align: middle;
        }
        .data-table tr:hover {
            background: #f9fafb;
        }
        .data-table tr:nth-child(even) {
            background: #f9fafb;
        }
        .status-badge {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
        }
        .status-pending { background: #fef3c7; color: #92400e; }
        .status-verified { background: #d1fae5; color: #065f46; }
        .status-rejected { background: #fee2e2; color: #991b1b; }
        .zoom-btn {
            padding: 4px 10px;
            background: #2563eb;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 600;
            transition: all 0.2s;
        }
        .zoom-btn:hover {
            background: #1d4ed8;
            transform: scale(1.05);
        }
        .marker-icon {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid white;
        }
        .marker-building { background-color: #f97316; }
        .marker-sign { background-color: #22c55e; }
    </style>
</head>
<!-- Custom Modal Dialogs -->
<!-- Modal ยืนยันการลบ -->
<div id="confirm-delete-modal" class="fixed inset-0 bg-black/50 backdrop-blur-sm z-[2000] hidden items-center justify-center p-4">
    <div class="bg-white rounded-2xl shadow-2xl max-w-md w-full animate-scale-in">
        <div class="p-6">
            <div class="flex items-center justify-center w-16 h-16 bg-red-100 rounded-full mx-auto mb-4">
                <i data-lucide="trash-2" class="w-8 h-8 text-red-600"></i>
            </div>
            <h3 id="delete-modal-title" class="text-xl font-bold text-center text-gray-900 mb-2">ยืนยันการลบ</h3>
            <p id="delete-modal-message" class="text-center text-gray-600 mb-6">คุณแน่ใจว่าต้องการลบสิ่งปลูกสร้างนี้?</p>
            
            <div class="flex gap-3">
                <button onclick="cancelDelete()" class="flex-1 py-3 px-6 bg-gray-200 text-gray-700 rounded-lg font-semibold hover:bg-gray-300 transition-all active:scale-95">
                    ยกเลิก
                </button>
                <button onclick="confirmDeleteAction()" class="flex-1 py-3 px-6 bg-red-600 text-white rounded-lg font-semibold hover:bg-red-700 transition-all active:scale-95 flex items-center justify-center gap-2">
                    <i data-lucide="trash-2" class="w-4 h-4"></i>
                    ลบ
                </button>
            </div>
        </div>
    </div>
</div>
<!-- Modal โหมดแก้ไข -->
<div id="edit-mode-modal" class="fixed inset-0 bg-black/30 backdrop-blur-sm z-[2000] hidden items-center justify-center p-4">
    <div class="bg-white rounded-2xl shadow-2xl max-w-md w-full animate-scale-in">
        <div class="p-6">
            <div class="flex items-center justify-center w-16 h-16 bg-blue-100 rounded-full mx-auto mb-4">
                <i data-lucide="move" class="w-8 h-8 text-blue-600"></i>
            </div>
            <h3 class="text-xl font-bold text-center text-gray-900 mb-2">โหมดแก้ไขตำแหน่ง</h3>
            <p class="text-center text-gray-600 mb-6">คลิกและลากหมุดเพื่อย้ายตำแหน่ง</p>
            
            <div class="flex justify-center">
                <button onclick="closeEditModeModal()" class="py-3 px-8 bg-blue-600 text-white rounded-lg font-semibold hover:bg-blue-700 transition-all active:scale-95">
                    ตกลง
                </button>
            </div>
        </div>
    </div>
</div>
<body class="bg-gray-100">

    <div id="map"></div>

    <!-- เป้าเล็ง -->
    <div id="crosshair" class="crosshair hidden">
        <div class="crosshair-circle">
            <div class="crosshair-line line-v v-top"></div>
            <div class="crosshair-line line-v v-bottom"></div>
            <div class="crosshair-line line-h h-left"></div>
            <div class="crosshair-line line-h h-right"></div>
        </div>
        <div class="crosshair-center"></div>
    </div>

    <!-- ปุ่มคอนเฟิร์ม (ข้อ 2) -->
    <div id="confirm-overlay" class="confirm-btn-overlay hidden">
        <button id="btn-confirm-action" onclick="confirmCapture()" class="flex items-center gap-2 px-6 py-4 rounded-full text-white font-bold shadow-2xl active:scale-95 transition-all text-lg border-4 border-white">
            <i data-lucide="check-circle" class="w-6 h-6"></i>
            <span id="confirm-text">ยืนยันการเพิ่มจุด</span>
        </button>
    </div>

        <!-- ปุ่มฟันเฟืองและรีเฟรช (ด้านบนซ้าย) -->
        <div class="absolute top-4 left-4 z-[1001]">
          <!-- ปุ่มฟันเฟือง (เมนูหลัก) -->
          <button id="btn-settings" onclick="toggleSettingsMenu()" class="map-btn p-3 text-gray-600 hover:text-blue-600 transition-all relative group mb-2">
            <i data-lucide="settings-2" id="settings-icon" class="w-6 h-6"></i>
            <!-- จุดแจ้งเตือน -->
            <span id="settings-badge" class="absolute top-0 right-0 w-2 h-2 bg-red-500 rounded-full hidden"></span>
          </button>
          
          <!-- ปุ่มรีเฟรช -->
          <button id="btn-refresh" onclick="refreshData()" class="map-btn p-3 text-blue-600 transition-all">
            <i data-lucide="refresh-cw" id="refresh-icon" class="w-6 h-6"></i>
          </button>
          
          <!-- ปุ่มย่อยที่เลื่อนลงมา -->
          <div id="settings-menu" class="mt-2 space-y-2 hidden">
            <!-- ปุ่ม 1: ดาวน์โหลดสิ่งปลูกสร้าง -->
            <button onclick="exportBuildingGeoJSON()" class="map-btn p-3 w-48 bg-gradient-to-r from-orange-400 to-orange-600 text-white hover:scale-105 transition-all shadow-lg flex items-center justify-start gap-2 text-left">
              <i data-lucide="home" class="w-5 h-5"></i>
              <span class="text-xs font-bold">ดาวน์โหลดสิ่งปลูกสร้าง</span>
            </button>
            <!-- ปุ่ม 2: ดาวน์โหลดป้าย -->
            <button onclick="exportSignGeoJSON()" class="map-btn p-3 w-48 bg-gradient-to-r from-green-400 to-green-600 text-white hover:scale-105 transition-all shadow-lg flex items-center justify-start gap-2 text-left">
              <i data-lucide="map-pin" class="w-5 h-5"></i>
              <span class="text-xs font-bold">ดาวน์โหลดป้าย</span>
            </button>
            <!-- ปุ่ม 3: ดาวน์โหลดรูปสิ่งปลูกสร้าง -->
            <button onclick="loadBuildingImages()" class="map-btn p-3 w-48 bg-gradient-to-r from-blue-400 to-blue-600 text-white hover:scale-105 transition-all shadow-lg flex items-center justify-start gap-2 text-left">
              <i data-lucide="image" class="w-5 h-5"></i>
              <span class="text-xs font-bold">ดาวน์โหลดรูปสิ่งปลูกสร้าง</span>
            </button>
            <!-- ปุ่ม 4: ดาวน์โหลดรูปป้าย -->
            <button onclick="loadSignImages()" class="map-btn p-3 w-48 bg-gradient-to-r from-purple-400 to-purple-600 text-white hover:scale-105 transition-all shadow-lg flex items-center justify-start gap-2 text-left">
              <i data-lucide="gallery-horizontal" class="w-5 h-5"></i>
              <span class="text-xs font-bold">ดาวน์โหลดรูปป้าย</span>
            </button>
          </div>
        </div>

    <!-- ปุ่มเลือกประเภทและแก้ไข -->
    <div class="absolute top-4 right-4 z-[1001] flex flex-row gap-2">
        <button id="btn-building" onclick="activateTool('building')" class="map-btn p-3" title="เพิ่มสิ่งปลูกสร้าง">
            <i data-lucide="home" class="w-6 h-6 text-orange-500"></i>
        </button>
        <button id="btn-sign" onclick="activateTool('sign')" class="map-btn p-3" title="เพิ่มป้าย">
            <i data-lucide="map-pin" class="w-6 h-6 text-green-500"></i>
        </button>
        <button id="btn-edit" onclick="toggleEditMode()" class="map-btn p-3" title="โหมดแก้ไขตำแหน่ง">
            <i data-lucide="move" class="w-6 h-6 text-red-600"></i>
        </button>
    </div>

    <!-- ปุ่มตำแหน่งปัจจุบัน -->
    <div class="absolute bottom-4 left-4 z-[1001]">
    <button onclick="locateUser()" class="map-btn p-3 shadow-lg border-2 border-blue-100">
    <div class="user-location-dot"></div>
    </button>
    </div>

    <!-- ปุ่มบวก (Add Trigger) -->
    <div id="add-trigger-container" class="absolute bottom-10 left-1/2 -translate-x-1/2 z-[1001] hidden">
        <button onclick="showConfirmButton()" class="p-4 bg-blue-600/50 text-white rounded-full shadow-xl border-[3px] border-white active:scale-90 transition-all">
            <i data-lucide="plus" class="w-8 h-8"></i>
        </button>
    </div>

    <!-- ปุ่มแสดงตาราง -->
    <div class="absolute bottom-4 right-4 z-[1002]">
        <button id="btn-show-table" onclick="toggleTable()" class="map-btn p-3 bg-white hover:bg-blue-50">
            <i data-lucide="table" id="table-icon" class="w-6 h-6 text-blue-600"></i>
        </button>
    </div>

    <!-- หน้าต่างตารางข้อมูล -->
    <div id="data-table-panel" class="data-table-panel">
        <div class="table-header">
            <div class="flex items-center gap-2">
                <div class="table-tabs">
                    <div class="table-tab active" onclick="switchTableTab('building')">สิ่งปลูกสร้าง</div>
                    <div class="table-tab" onclick="switchTableTab('sign')">ป้าย</div>
                </div>
            </div>
            <button onclick="toggleTable()" class="p-1.5 hover:bg-white/20 rounded-full">
                <i data-lucide="x" class="w-4 h-4"></i>
            </button>
        </div>
        <div class="table-content">
            <div id="building-table-container" class="table-tab-content">
                <table class="data-table" id="building-table">
                    <thead>
                        <tr>
                            <th style="width: 30px"><i data-lucide="map-pin" class="w-4 h-4"></i></th>
                            <th>รหัส</th>
                            <th>เจ้าของ</th>
                            <th>ที่อยู่</th>
                            <th>ประเภท</th>
                            <th>พื้นที่ (ตร.ม.)</th>
                            <th>ตรวจสอบ</th>
                            <th style="width: 60px">ซูม</th>
                        </tr>
                    </thead>
                    <tbody id="building-table-body">
                        <tr>
                            <td colspan="8" class="text-center py-8 text-gray-500">กำลังโหลดข้อมูล...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div id="sign-table-container" class="table-tab-content hidden">
                <table class="data-table" id="sign-table">
                    <thead>
                        <tr>
                            <th style="width: 30px"><i data-lucide="map-pin" class="w-4 h-4"></i></th>
                            <th>รหัส</th>
                            <th>ชื่อกิจการ</th>
                            <th>ประเภท</th>
                            <th>กว้าง (ม.)</th>
                            <th>ยาว (ม.)</th>
                            <th>ข้อความ</th>
                            <th style="width: 60px">ซูม</th>
                        </tr>
                    </thead>
                    <tbody id="sign-table-body">
                        <tr>
                            <td colspan="8" class="text-center py-8 text-gray-500">กำลังโหลดข้อมูล...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- หน้าต่างกรอกข้อมูล -->
    <div id="side-panel" class="side-panel fixed top-0 right-0 w-[44vw] sm:w-[280px] h-full z-[1002] shadow-2xl flex flex-col">
        <div class="p-4 border-b flex justify-between items-center bg-gray-50">
            <div>
                <h2 id="panel-title" class="font-bold text-blue-900">บันทึกข้อมูล</h2>
                <p id="latlng-display" class="text-[10px] text-gray-500 font-mono"></p>
            </div>
            <button onclick="closePanel()" class="p-2 hover:bg-gray-200 rounded-full"><i data-lucide="x" class="w-5 h-5"></i></button>
        </div>
        <form id="survey-form" class="flex-1 overflow-y-auto p-4 space-y-3"></form>
        <div class="p-4 bg-white border-t">
            <button type="button" onclick="saveSurveyData()" class="w-full bg-blue-600 text-white py-3 rounded-xl font-bold flex items-center justify-center gap-2">
                <i data-lucide="save" class="w-5 h-5"></i> บันทึก
            </button>
        </div>
    </div>

    <script>
        const CONFIG = {
            SCRIPT_URL: 'https://script.google.com/macros/s/AKfycbx_NlwFmiw31BxckLSYI_q0Bu24YXw4XFkwrqvUz1LYvT6W0DcYkdpSIQXoysJhq4gVCQ/exec'
        };

    // ✅ ประกาศตัวแปร Global ทั้งหมดไว้ที่นี่ที่เดียว
        let map;
        let activeTool = null;
        let isEditMode = false;
        let surveyLayers = L.layerGroup();
        let editingMarker = null;
        let markersBeingMoved = new Set(); // ✅ เพิ่มบรรทัดนี้ - เก็บ rowKey ของจุดที่กำลังถูกย้าย
        // ตัวแปรสำหรับเก็บข้อมูลและ Cache
        let allBuildings = []; 
        let allSigns = [];   
        let movingMarkerId = null; // ✅ เก็บ ID ของจุดที่กำลังถูกลากอยู่  
        
        // ตัวแปรสำหรับระบบอัปเดตอัตโนมัติ

        let autoUpdateInterval = null;
        let isUpdating = false;
        let isUploadingImage = false; // [cite: 71]

        function initMap() {
          const mapOptions = {
            zoomControl: false,
            attributionControl: false,
            preferCanvas: true,
            zoomSnap: isMobile() ? 0.5 : 1, // Conditional snap
            wheelDebounceTime: 40,         // Better scroll performance
          };

          map = L.map('map', {
            zoomControl: false,
            attributionControl: false,
            preferCanvas: true,
            // ✅ อนุญาตให้แผนที่แสดงล้นขอบจอได้
            padding: [50, 50], // เพิ่มพื้นที่ว่างรอบแผนที่ (บน, ล่าง, ซ้าย, ขวา)
            maxBoundsViscosity: 0.5, // ลดความหนืดของขอบเขต (ทำให้เลื่อนลื่นขึ้น)
            inertia: true, // เปิดใช้งานการเลื่อนแบบอินเนอร์เชีย
            inertiaDeceleration: 3000, // ความเร็วการชะลอตัว
            inertiaMaxSpeed: 1500, // ความเร็วสูงสุด
            // ไม่กำหนดขอบเขตแผนที่ (ให้แสดงล้นได้)
            // maxBounds: undefined
          }).setView([15.202, 102.068], 14);

          // Hardware Acceleration
          const container = map.getContainer();
          container.style.transform = 'translate3d(0, 0, 0)';
          
        // Google Hybrid Tile Options - ปรับเพิ่มประสิทธิภาพ
        const tileOptions = {
            subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],
            updateWhenIdle: false, // ✅ โหลดขณะเลื่อน (ไม่รอหยุด)
            updateWhenZooming: true, // ✅ อัปเดตขณะซูม
            keepBuffer: isMobile() ? 6 : 10, // ✅ เพิ่มบัฟเฟอร์ (มือถือ 4, คอม 8)
            maxNativeZoom: 19, // ป้องกันการโหลดไทล์ที่ไม่มี
            reuseTiles: true, // ✅ ใช้ไทล์เก่าซ้ำแทนโหลดใหม่
            className: 'map-tiles-optimized'
        };

        // Low Res / Background Layer
        const lowResLayer = L.tileLayer('https://{s}.google.com/vt/lyrs=y&x={x}&y={y}&z={z}', {
            ...tileOptions,
            maxZoom: 15,
            zIndex: 1
        });

        // High Res Layer
        const highResLayer = L.tileLayer('https://{s}.google.com/vt/lyrs=y&x={x}&y={y}&z={z}', {
            ...tileOptions,
            minZoom: 16,
            maxZoom: 22,
            zIndex: 2
        });

          lowResLayer.addTo(map);
          highResLayer.addTo(map);
          surveyLayers.addTo(map);
        }
        // ตรวจจับอุปกรณ์มือถือ
        function isMobile() {
          return /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        function activateTool(tool) {
          isEditMode = false;
          document.getElementById('btn-edit').classList.remove('active-edit');
          surveyLayers.eachLayer(l => l.dragging && l.dragging.disable());
          
          if (activeTool === tool) {
            // ยกเลิกการเพิ่มจุด - เลื่อนลง
            deactivateTools();
          } else {
            // เปิดใช้งานเครื่องมือใหม่
            activeTool = tool;
            document.getElementById('btn-building').classList.toggle('active-tool', tool === 'building');
            document.getElementById('btn-sign').classList.toggle('active-tool', tool === 'sign');
            
            // แสดงเป้าเล็งและปุ่มบวกด้วยแอนิเมชันเลื่อนขึ้น
            const crosshair = document.getElementById('crosshair');
            const addTrigger = document.getElementById('add-trigger-container');
            
            // ลบคลาส hidden และเพิ่มคลาส visible พร้อมแอนิเมชัน
            crosshair.classList.remove('hidden');
            addTrigger.classList.remove('hidden');
            
            // บังคับให้เบราว์เซอร์คำนวณใหม่ก่อนเริ่มแอนิเมชัน
            void crosshair.offsetWidth;
            void addTrigger.offsetWidth;
            
            // เริ่มแอนิเมชันเลื่อนขึ้น
            crosshair.classList.add('visible');
            addTrigger.classList.add('visible');
            
            // ซ่อนปุ่มคอนเฟิร์มหากมี
            document.getElementById('confirm-overlay').classList.add('hidden');
          }
        }

        // ระบบแคชแผนที่
        let mapCache = {};

        function cacheCurrentView() {
            const bounds = map.getBounds();
            const zoom = map.getZoom();
            
            // สร้างคีย์สำหรับแคช
            const cacheKey = `${bounds.getNorth()},${bounds.getEast()},${bounds.getSouth()},${bounds.getWest()}_${zoom}`;
            
            // บันทึกตำแหน่งปัจจุบันลงในแคช
            mapCache[cacheKey] = {
                timestamp: new Date().toISOString(),
                bounds: bounds,
                zoom: zoom
            };
            
            console.log(`แคชตำแหน่ง: ${cacheKey}`);
        }

        // โหลดแผนที่จากแคชเมื่อเปิดแอป
        function loadCachedMapViews() {
            // โหลดจาก localStorage
            const cached = localStorage.getItem('mapCache');
            if (cached) {
                mapCache = JSON.parse(cached);
                console.log('โหลดแคชแผนที่เรียบร้อย');
            }
        }

        // บันทึกแคชเมื่อปิดแอป
        window.addEventListener('beforeunload', () => {
            localStorage.setItem('mapCache', JSON.stringify(mapCache));
        });

        // เรียกใช้เมื่อเปิดแอป
        loadCachedMapViews();

        function deactivateTools() {
          activeTool = null;
          document.getElementById('btn-building').classList.remove('active-tool');
          document.getElementById('btn-sign').classList.remove('active-tool');
          
          const crosshair = document.getElementById('crosshair');
          const addTrigger = document.getElementById('add-trigger-container');
          
          // เริ่มแอนิเมชันเลื่อนลง
          crosshair.classList.remove('visible');
          addTrigger.classList.remove('visible');
          
          // หลังแอนิเมชันเสร็จ ซ่อนองค์ประกอบจริงๆ
          setTimeout(() => {
            crosshair.classList.add('hidden');
            addTrigger.classList.add('hidden');
            document.getElementById('confirm-overlay').classList.add('hidden');
          }, 400); // ตรงกับระยะเวลาแอนิเมชัน 0.4s
        }

        function toggleEditMode() {
            isEditMode = !isEditMode;
            
            const btnEdit = document.getElementById('btn-edit');
            
            if (isEditMode) {
                // ปิดเครื่องมือเพิ่มจุด
                activeTool = null;
                document.getElementById('btn-building').classList.remove('active-tool');
                document.getElementById('btn-sign').classList.remove('active-tool');
                
                // ✅ เพิ่มคลาส 'active-edit' ให้ปุ่ม "move" เป็นสีน้ำเงิน
                btnEdit.classList.add('active-edit');
                
                // ✅ เปิดใช้งานการลากมาร์กเกอร์ทั้งหมด
                surveyLayers.eachLayer(function(layer) {
                    if (layer._popupData && layer.dragging && layer.dragging.enable) {
                        layer.dragging.enable();
                        
                        // ผูกเหตุการณ์เมื่อลากเสร็จ
                        layer.off('dragend');
                        layer.on('dragend', async function(e) {
                            const newLatLng = e.target.getLatLng();
                            const marker = e.target;
                            const data = marker._popupData;
                            if (data) {
                                await updateMarkerPosition(marker, data, newLatLng);
                            }
                        });
                    }
                });
                
                showEditModeModal();
            } else {
                // ✅ ลบคลาส 'active-edit' ออกจากปุ่ม "move"
                btnEdit.classList.remove('active-edit');
                
                // ✅ ปิดการลากมาร์กเกอร์ทั้งหมด
                surveyLayers.eachLayer(function(layer) {
                    if (layer.dragging && layer.dragging.disable) {
                        layer.dragging.disable();
                    }
                });
            }
        }

        // ฟังก์ชันสำหรับปิด/เปิดการใช้งานปุ่มรีโหลด
        function disableRefreshButton() {
            const btn = document.getElementById('btn-refresh');
            btn.disabled = true;
            btn.style.opacity = '0.5';
            btn.style.cursor = 'not-allowed';
        }

        function enableRefreshButton() {
            const btn = document.getElementById('btn-refresh');
            btn.disabled = false;
            btn.style.opacity = '1';
            btn.style.cursor = 'pointer';
        }


        // ข้อ 2: แสดงปุ่มยืนยัน
        function showConfirmButton() {
            const overlay = document.getElementById('confirm-overlay');
            const btn = document.getElementById('btn-confirm-action');
            const text = document.getElementById('confirm-text');

            if (activeTool === 'building') {
                btn.style.backgroundColor = '#f97316'; 
                text.innerText = "เพิ่มสิ่งปลูกสร้าง";
            } else {
                btn.style.backgroundColor = '#22c55e';
                text.innerText = "ยืนยันเพิ่มป้าย";
            }
            overlay.classList.remove('hidden');
        }

        // ข้อ 2: ยืนยันและบันทึกเบื้องหลัง
        async function confirmCapture() {
            // คำนวณพิกัดตามตำแหน่งเป้า (สูงขึ้น 15%)
            const containerPoint = L.point(map.getSize().x / 2, map.getSize().y * 0.35);
            const latlng = map.containerPointToLatLng(containerPoint);

            document.getElementById('confirm-overlay').classList.add('hidden');
            
            const tempMarker = createCircleMarker(latlng, activeTool);
            tempMarker.addTo(surveyLayers);
            
            backgroundUpload(latlng, activeTool, tempMarker);
        }

        // แก้ไขฟังก์ชัน backgroundUpload
        // แก้ไขฟังก์ชันนี้
        async function backgroundUpload(latlng, type, marker) {
            const refreshBtn = document.getElementById('btn-refresh');
            const refreshIcon = document.getElementById('refresh-icon');
            
            disableRefreshButton();
            refreshIcon.classList.add('animate-spin');
            
            // สร้างข้อมูลพื้นฐาน
            const data = {
                lat_long: `${latlng.lat.toFixed(6)}, ${latlng.lng.toFixed(6)}`,
                date_added: new Date().toISOString(),
                tempMarker: true // ✅ ทำเครื่องหมายว่าเป็นมาร์กเกอร์ชั่วคราว
            };
            
            // เพิ่มข้อมูลเริ่มต้น
            if (type === 'sign') {
                data.s_code = `05G032-S${Date.now().toString().slice(-4)}`;
                data.s_name = 'ป้ายใหม่';
                data.s_type = 'ป้ายทั่วไป';
                data.s_wide = '0';
                data.s_length = '0';
            } else {
                data.building_c = `B${Date.now().toString().slice(-5)}`;
                data.full_name = 'เจ้าของใหม่';
                data.b_type = 'บ้านพักอาศัย';
                data.b_area = '0';
            }
            
            // ✅ ทำเครื่องหมายในมาร์กเกอร์ว่าเป็นชั่วคราว
            marker._popupData = { ...data, type: type, tempMarker: true };
            setupMarkerPopup(marker, marker._popupData, type);
            
            try {
                const result = await sendDataWithRetry('quickAdd', type, data);
                
                if (result.success) {
                    // ✅ ขั้นตอนที่ 1-3: จุดชั่วคราวยังแสดงอยู่
                    // โหลดข้อมูลใหม่ก่อน (เพื่อให้มีข้อมูลจริงแสดงบนแผนที่)
                    await loadExistingData();
                    
                    // ✅ ขั้นตอนที่ 4: ลบจุดชั่วคราวหลังจากโหลดเสร็จ
                    setTimeout(() => {
                        surveyLayers.eachLayer(layer => {
                            if (layer._popupData && layer._popupData.tempMarker) {
                                surveyLayers.removeLayer(layer);
                            }
                        });
                        
                        refreshIcon.classList.remove('animate-spin');
                        refreshBtn.classList.add('refresh-success');
                        setTimeout(() => {
                            refreshBtn.classList.remove('refresh-success');
                            enableRefreshButton();
                        }, 2000);
                        
                        showNotificationLeft('เพิ่มจุดสำเร็จ!', 'success');
                    }, 300); // รอให้แสดงจุดจริงก่อน
                    
                } else if (result.queued) {
                    // ถ้าอยู่ในคิว - ไม่ลบจุดชั่วคราว
                    refreshIcon.classList.remove('animate-spin');
                    enableRefreshButton();
                    marker._popupData = {
                        ...data,
                        type: type,
                        tempMarker: true,
                        queued: true,
                        queueId: result.queueId
                    };
                    setupMarkerPopup(marker, marker._popupData, type);
                    await loadExistingData();
                    showNotificationLeft('บันทึกข้อมูลไว้ในมือถือ (รอซิงค์)', 'warning');
                }
            } catch (err) {
                refreshIcon.classList.remove('animate-spin');
                enableRefreshButton();
                // ไม่ลบมาร์กเกอร์ แต่ทำเครื่องหมายว่าล้มเหลว
                marker._popupData = {
                    ...data,
                    type: type,
                    tempMarker: true,
                    failed: true
                };
                setupMarkerPopup(marker, marker._popupData, type);
                showNotificationLeft("การบันทึกล้มเหลว: " + err.message, 'error');
            }
        }

        // แก้ไขฟังก์ชัน saveSurveyData --- ลบเวอร์ชั่นแรกออก เพราะไม่มีระบบออฟไลน์
        // แก้ไขฟังก์ชัน saveSurveyData

        // แก้ไขฟังก์ชัน deleteMarker
        async function deleteMarker(marker, data, type) {
            const rowKey = data._row_num || data.id;
            
            if (!rowKey) {
                alert("ไม่พบข้อมูลสำหรับลบ");
                return;
            }
            
            try {
                // ส่งคำขอลบพร้อมการลองใหม่
                const result = await sendDataWithRetry('delete', type, null, rowKey);
                
                if (result.success) {
                    surveyLayers.removeLayer(marker);
                    await loadExistingData();
                    showNotificationLeft('ลบข้อมูลเรียบร้อยแล้ว!', 'success');
                    
                } else if (result.queued) {
                    // เก็บไว้ในคิว แต่ลบจากแผนที่ก่อน
                    surveyLayers.removeLayer(marker);
                    await loadExistingData();
                    showNotificationLeft('ลบข้อมูลไว้ในมือถือ (รอซิงค์)', 'warning');
                }
                
            } catch (err) {
                console.error("Error deleting marker:", err);
                showNotificationLeft('เกิดข้อผิดพลาดในการลบ!', 'error');
                throw err;
            }
        }

        // แก้ไขฟังก์ชัน updateMarkerPosition
        async function updateMarkerPosition(marker, data, newLatLng) {
            const refreshBtn = document.getElementById('btn-refresh');
            const refreshIcon = document.getElementById('refresh-icon');
            
            disableRefreshButton();
            refreshIcon.classList.add('animate-spin');
            
            const oldLatLng = data.lat_long;
            const newLatLngStr = `${newLatLng.lat.toFixed(6)}, ${newLatLng.lng.toFixed(6)}`;
            const rowKey = data._row_num || data.id;
            const type = data.type || (data.building_c ? 'building' : 'sign');
            
            if (!rowKey) {
                alert("ไม่พบข้อมูลสำหรับอัปเดต");
                refreshIcon.classList.remove('animate-spin');
                enableRefreshButton();
                return;
            }
            
            // ✅ เพิ่มลงในรายการจุดที่กำลังถูกย้าย
            markersBeingMoved.add(rowKey);
            
            // แสดงจุดชั่วคราว
            const tempMarker = createCircleMarker(newLatLng, type);
            tempMarker._popupData = {
                ...data,
                lat_long: newLatLngStr,
                tempMarker: true,
                tempMarkerId: `temp_${rowKey}`
            };
            setupMarkerPopup(tempMarker, tempMarker._popupData, type);
            tempMarker.addTo(surveyLayers);
            
            // ✅ ซ่อนจุดจริงทั้งหมดที่มี _row_num เดียวกัน
            surveyLayers.eachLayer(layer => {
                if (layer._popupData) {
                    const layerId = layer._popupData._row_num || layer._popupData.id;
                    if (layerId === rowKey && !layer._popupData.tempMarker) {
                        surveyLayers.removeLayer(layer);
                    }
                }
            });
            
            // ตรวจสอบสถานะออนไลน์
            if (!isOnline || !navigator.onLine) {
                const queueId = addToSyncQueue('updatePosition', type, { lat_long: newLatLngStr }, rowKey);
                data.lat_long = newLatLngStr;
                if (marker) marker._popupData.lat_long = newLatLngStr;
                setupMarkerPopup(tempMarker, data, type);
                refreshIcon.classList.remove('animate-spin');
                enableRefreshButton();
                
                // ลบออกจากรายการ (เพราะยังไม่ได้อัปเดตจริง)
                markersBeingMoved.delete(rowKey);
                
                console.log(`อัปเดตตำแหน่งไว้ในมือถือ (รอซิงค์): ${queueId}`);
                return;
            }
            
            const body = new URLSearchParams();
            body.append('action', 'updatePosition');
            body.append('type', type);
            body.append('rowKey', rowKey);
            body.append('lat_long', newLatLngStr);
            
            try {
                const res = await fetch(CONFIG.SCRIPT_URL.trim(), { method: 'POST', body });
                
                if (res.ok) {
                    // ✅ โหลดข้อมูลใหม่ (จุดจริงจะถูกสร้างทันที พร้อมจุดชั่วคราว)
                    await loadExistingData();
                    
                    // ⏱️ รอ 1 วินาที ให้แน่ใจว่าจุดจริงเรนเดอร์เสร็จแล้ว
                    setTimeout(() => {
                        // ลบจุดชั่วคราว
                        surveyLayers.eachLayer(layer => {
                            if (layer._popupData && layer._popupData.tempMarkerId === `temp_${rowKey}`) {
                                surveyLayers.removeLayer(layer);
                            }
                        });
                        
                        markersBeingMoved.delete(rowKey);
                        
                        refreshIcon.classList.remove('animate-spin');
                        refreshBtn.classList.add('refresh-success');
                        setTimeout(() => {
                            refreshBtn.classList.remove('refresh-success');
                            enableRefreshButton();
                        }, 2000);
                        
                        showNotificationLeft('อัปเดตตำแหน่งสำเร็จ!', 'success');
                    }, 10000); // รอ 1 วินาที
                    
                } else {
                    throw new Error("อัปเดตตำแหน่งไม่สำเร็จ");
                }
            } catch (err) {
                // หากเกิดข้อผิดพลาด ให้คืนค่าจุดเดิม
                surveyLayers.removeLayer(tempMarker);
                if (marker) {
                    marker.setLatLng(L.latLng(oldLatLng.split(',').map(Number)));
                    marker.addTo(surveyLayers);
                }
                
                refreshIcon.classList.remove('animate-spin');
                enableRefreshButton();
                
                // ลบออกจากรายการ (เพราะล้มเหลว)
                markersBeingMoved.delete(rowKey);
                
                console.error("Error updating position:", err);
                
                // หากเกิดข้อผิดพลาด ให้เก็บข้อมูลไว้ในคิวแทน
                const queueId = addToSyncQueue('updatePosition', type, { lat_long: newLatLngStr }, rowKey);
                data.lat_long = newLatLngStr;
                if (marker) marker._popupData.lat_long = newLatLngStr;
                setupMarkerPopup(marker, data, type);
                console.log(`อัปเดตตำแหน่งไว้ในมือถือ (รอซิงค์): ${queueId}`);
            }
        }

        // ข้อ 3: ตั้งค่าป๊อปอัปเพื่อเปิดฟอร์ม (แก้ไขเพิ่มปุ่มลบ + แก้ไขป๊อบอัปไม่ปิดอัตโนมัติ)
        function setupMarkerPopup(marker, data, type) {
            const popupDiv = document.createElement('div');
            popupDiv.className = "p-1 min-w-[160px]";
            popupDiv.innerHTML = `
            <p class="font-bold text-sm text-blue-900">${type === 'building' ? 'สิ่งปลูกสร้าง' : 'ป้าย'}</p>
            <p class="text-[10px] text-gray-500">${data.lat_long}</p>
            <div class="mt-2 space-y-2">  <!-- เพิ่มระยะห่างระหว่างปุ่ม -->
                <button class="w-full bg-blue-600 text-white text-[11px] py-3 rounded font-bold shadow-sm active:bg-blue-700 hover:bg-blue-700 transition">แก้ข้อมูล</button>
                <button class="w-full bg-red-600 text-white text-[11px] py-3 rounded font-bold shadow-sm active:bg-red-700 hover:bg-red-700 transition">ลบจุด</button>
            </div>
          `;
          
          // ✅ แก้ไขหลัก: ปิด autoPan + ไม่แพนแผนที่อัตโนมัติ
          marker.bindPopup(popupDiv, {
            minWidth: 190,
            maxWidth: 220,
            autoPan: false, // ✅ ปิดการแพนอัตโนมัติ (สำคัญมาก!)
            closeOnClick: true // ใช้ค่าเริ่มต้น (ปิดเมื่อคลิกนอกป๊อปอัป)
          });
          
          marker._popupData = { ...data, type: type };
          
          // ✅ ลบโค้ด setTimeout + panTo ทั้งหมดออก!
          // เหลือเฉพาะการผูกปุ่ม
        marker.on('popupopen', () => {
            const buttons = marker.getPopup().getElement().querySelectorAll('button');
            buttons[0].onclick = (e) => {
                e.stopPropagation();
                openEditPanel(marker._popupData, marker._popupData.type, marker); // ✅ แก้ไขตรงนี้
            };
            buttons[1].onclick = (e) => {
                e.stopPropagation();
                showDeleteConfirm(marker, marker._popupData, marker._popupData.type);
            };
        });
        }

        // ฟังก์ชันลบจุดและข้อมูลจาก Google Sheets (ข้อ 1)
        // แก้ไขฟังก์ชัน deleteMarker
        async function deleteMarker(marker, data, type) {
            const refreshBtn = document.getElementById('btn-refresh');
            const refreshIcon = document.getElementById('refresh-icon');
            
            // ปิดการใช้งานปุ่ม
            disableRefreshButton();
            refreshIcon.classList.add('animate-spin');
            
            // แสดงแจ้งเตือนว่ากำลังลบ (ฝั่งซ้าย)
            const deletingMsg = document.createElement('div');
            deletingMsg.className = 'fixed top-4 left-4 bg-blue-500 text-white px-6 py-3 rounded-lg shadow-lg z-[2000] animate-fade-in';
            deletingMsg.innerHTML = '<i data-lucide="loader" class="w-5 h-5 inline mr-2 animate-spin"></i>กำลังลบข้อมูล...';
            document.body.appendChild(deletingMsg);
            
            const rowKey = data._row_num || data.id;
            
            if (!rowKey) {
                alert("ไม่พบข้อมูลสำหรับลบ");
                refreshIcon.classList.remove('animate-spin');
                enableRefreshButton();
                deletingMsg.classList.add('animate-fade-out');
                setTimeout(() => deletingMsg.remove(), 300);
                return;
            }
            
            const body = new URLSearchParams();
            body.append('action', 'delete');
            body.append('type', type);
            body.append('rowKey', rowKey);
            
            try {
                const res = await fetch(CONFIG.SCRIPT_URL.trim(), { method: 'POST', body });
                
                if (res.ok) {
                    // ซ่อนข้อความ "กำลังลบ"
                    deletingMsg.classList.add('animate-fade-out');
                    setTimeout(() => deletingMsg.remove(), 300);
                    
                    // แสดงแจ้งเตือนสำเร็จ (ฝั่งซ้าย)
                    const successMsg = document.createElement('div');
                    successMsg.className = 'fixed top-4 left-4 bg-green-500 text-white px-6 py-3 rounded-lg shadow-lg z-[2000] animate-fade-in';
                    successMsg.innerHTML = '<i data-lucide="check-circle" class="w-5 h-5 inline mr-2"></i>ลบข้อมูลเรียบร้อยแล้ว!';
                    document.body.appendChild(successMsg);
                    
                    setTimeout(() => {
                        successMsg.classList.add('animate-fade-out');
                        setTimeout(() => successMsg.remove(), 300);
                    }, 500);
                    
                    surveyLayers.removeLayer(marker);
                    await loadExistingData();
                    
                    refreshIcon.classList.remove('animate-spin');
                    refreshBtn.classList.add('refresh-success');
                    setTimeout(() => {
                        refreshBtn.classList.remove('refresh-success');
                        enableRefreshButton();
                    }, 500);
                    
                    console.log("ลบข้อมูลเรียบร้อยแล้ว");
                } else {
                    throw new Error("ลบข้อมูลไม่สำเร็จ");
                }
            } catch (err) {
                // ซ่อนข้อความ "กำลังลบ"
                deletingMsg.classList.add('animate-fade-out');
                setTimeout(() => deletingMsg.remove(), 300);
                
                refreshIcon.classList.remove('animate-spin');
                enableRefreshButton();
                console.error("Error deleting marker:", err);
                
                // แสดงแจ้งเตือนข้อผิดพลาด (ฝั่งซ้าย)
                const errorMsg = document.createElement('div');
                errorMsg.className = 'fixed top-4 left-4 bg-red-500 text-white px-6 py-3 rounded-lg shadow-lg z-[2000] animate-fade-in';
                errorMsg.innerHTML = '<i data-lucide="alert-circle" class="w-5 h-5 inline mr-2"></i>เกิดข้อผิดพลาดในการลบ!';
                document.body.appendChild(errorMsg);
                
                setTimeout(() => {
                    errorMsg.classList.add('animate-fade-out');
                    setTimeout(() => errorMsg.remove(), 300);
                }, 500);
                
                throw err;
            }
        }


        function openEditPanel(data, type, marker) {
            editingMarker = marker;
            const form = document.getElementById('survey-form');
            document.getElementById('latlng-display').innerText = data.lat_long;
            document.getElementById('panel-title').innerText = type === 'building' ? 'รายละเอียดสิ่งปลูกสร้าง' : 'รายละเอียดป้าย';
            
            const buildingFields = [
                { id: 'full_name', label: 'เจ้าของ', type: 'text' },
                { id: 'address', label: 'ที่อยู่', type: 'text' },
                { id: 'building_c', label: 'รหัสสิ่งปลูกสร้าง', type: 'text' },
                { id: 'b_type', label: 'ประเภทสิ่งปลูกสร้าง', type: 'text' },
                { id: 'b_mat', label: 'วัสดุ', type: 'text' },
                { id: 'b_year', label: 'อายุ (ปี)', type: 'number' },
                { id: 'hs_no', label: 'บ้านเลขที่', type: 'text' },
                { id: 'hs_moo', label: 'หมู่', type: 'text' },
                { id: 'no_floor', label: 'ชั้น', type: 'number' },
                { id: 'b_area', label: 'พื้นที่ทั้งหลัง (ตร.ม.)', type: 'number' },
                { id: 'b_note', label: 'รายละเอียด', type: 'textarea' },
                { id: 'b_use', label: 'ใช้ประโยชน์', type: 'text' },
                { id: 'per_use', label: 'การเช่า', type: 'text' },
                { id: 'buse_floor', label: 'ชั้นที่ใช้', type: 'text' },
                { id: 'buse_area', label: 'พื้นที่ใช้ (ตร.ม.)', type: 'number' },
                { id: 'ment_use', label: 'หมายเหตุ', type: 'textarea' },
                { id: 'full_area', label: 'ใช้ทั้งหลัง', type: 'checkbox' },
                { id: 'b_use2', label: 'ใช้ประโยชน์ (2)', type: 'text' },
                { id: 'per_use2', label: 'การเช่า (2)', type: 'text' },
                { id: 'buse_flor2', label: 'ชั้นที่ใช้ (2)', type: 'text' },
                { id: 'buse_area2', label: 'พื้นที่ใช้ (2) (ตร.ม.)', type: 'number' },
                { id: 'ment_use2', label: 'หมายเหตุ (2)', type: 'textarea' },
                { id: 'full_area2', label: 'ใช้ทั้งหลัง (2)', type: 'checkbox' },
                { id: 'picture', label: 'ถ่ายรูป', type: 'file' },
                { id: 'check', label: 'สถานะการตรวจสอบ', type: 'select', options: ['pending', 'verified', 'rejected'] }
            ];
            
            const signFields = [
                { id: 's_code', label: 'รหัสป้าย', type: 'text' },
                { id: 's_name', label: 'ชื่อกิจการ', type: 'text' },
                { id: 's_type', label: 'ประเภทป้าย', type: 'text' },
                { id: 's_characte', label: 'ลักษณะป้าย', type: 'text' },
                { id: 's_wide', label: 'กว้าง (ม.)', type: 'number' },
                { id: 's_length', label: 'ยาว (ม.)', type: 'number' },
                { id: 'no_side', label: 'จำนวนด้าน', type: 'text' },
                { id: 's_text', label: 'ข้อความ', type: 'text' },
                { id: 'comment', label: 'หมายเหตุ', type: 'text' },
                { id: 'fullname', label: 'เจ้าของ', type: 'text' },
                { id: 'address', label: 'ที่อยู่', type: 'text' },
                { id: 'picture', label: 'ถ่ายรูป', type: 'file' }
            ];
            
            const fields = type === 'building' ? buildingFields : signFields;
            let html = '';
            
            fields.forEach(f => {
                html += `<div class="mb-2">`;
                html += `<label class="form-label">${f.label}</label>`;
                
                if (f.type === 'textarea') {
                    html += `<textarea name="${f.id}" class="form-input" rows="2">${data[f.id] || ''}</textarea>`;
                } else if (f.type === 'file') {
                    html += `<input type="file" name="${f.id}" accept="image/*" capture="camera" class="text-xs w-full mt-1">`;
                } else if (f.type === 'checkbox') {
                    const checked = data[f.id] === 'TRUE' || data[f.id] === true ? 'checked' : '';
                    html += `<input type="checkbox" name="${f.id}" class="mt-1" ${checked}>`;
                } else if (f.type === 'select') {
                    html += `<select name="${f.id}" class="form-input">`;
                    f.options.forEach(opt => {
                        const selected = data[f.id] === opt ? 'selected' : '';
                        html += `<option value="${opt}" ${selected}>${opt}</option>`;
                    });
                    html += `</select>`;
                } else {
                    html += `<input type="${f.type}" name="${f.id}" class="form-input" value="${data[f.id] || ''}">`;
                }
                
                html += `</div>`;
            });
            
            form.innerHTML = html;
            document.getElementById('side-panel').classList.add('open');
            marker.closePopup();
        }

        // ============================================
        // ฟังก์ชันบันทึกข้อมูล (แก้ไขแล้ว)
        // ============================================
        async function saveSurveyData() {
            const form = document.getElementById('survey-form');
            const formData = new FormData(form);
            
            // ดึงค่าฟอร์ม
            const data = {};
            for (let [key, value] of formData.entries()) {
                const input = form.querySelector(`[name="${key}"]`);
                if (input && input.type === 'checkbox') {
                    data[key] = input.checked ? 'TRUE' : 'FALSE';
                } else if (input && input.type !== 'file') {
                    data[key] = value;
                }
            }
            
            // ดึงพิกัด
            data.lat_long = document.getElementById('latlng-display').innerText;
            
            // ✅ ประกาศตัวแปรครั้งเดียวที่นี่
            const markerType = editingMarker._popupData.type;
            const rowKey = editingMarker._popupData.id || editingMarker._popupData._row_num;
            
            if (!rowKey) {
                alert("ไม่พบข้อมูลสำหรับอัปเดต");
                return;
            }
            
            // จัดการรูปภาพ
            let imageBase64 = "";
            let imageFilename = null;
            const fileInput = form.querySelector('input[type="file"]');
            
            if (fileInput && fileInput.files[0]) {
                const file = fileInput.files[0];
                
                // ✅ ใช้ตัวแปรที่ประกาศไว้แล้ว
                const maxSize = markerType === 'building' ? 1500 : 2000;
                
                const resizeImage = (file, maxWidth = maxSize, maxHeight = maxSize) => {
                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            const img = new Image();
                            img.onload = () => {
                                let width = img.width;
                                let height = img.height;
                                
                                if (width > height) {
                                    if (width > maxWidth) {
                                        height = Math.round(height * maxWidth / width);
                                        width = maxWidth;
                                    }
                                } else {
                                    if (height > maxHeight) {
                                        width = Math.round(width * maxHeight / height);
                                        height = maxHeight;
                                    }
                                }
                                
                                const canvas = document.createElement('canvas');
                                canvas.width = width;
                                canvas.height = height;
                                
                                const ctx = canvas.getContext('2d');
                                ctx.drawImage(img, 0, 0, width, height);
                                
                                const resizedBase64 = canvas.toDataURL(file.type, 0.85);
                                resolve(resizedBase64);
                            };
                            img.onerror = reject;
                            img.src = e.target.result;
                        };
                        reader.onerror = reject;
                        reader.readAsDataURL(file);
                    });
                };
                
                try {
                    imageBase64 = await resizeImage(file, maxSize, maxSize);
                    const base64Data = imageBase64.split(',')[1];
                    imageBase64 = `${file.type};base64,${base64Data}`;
                    imageFilename = data.building_c || data.s_code || `IMG_${Date.now()}.jpg`;
                    console.log(`รูปภาพถูกปรับขนาดเป็น ${maxSize} พิกเซล: ${imageFilename}`);
                } catch (err) {
                    console.error('Error resizing image:', err);
                    const arrayBuffer = await file.arrayBuffer();
                    const bytes = [...new Uint8Array(arrayBuffer)];
                    const binary = bytes.map(b => String.fromCharCode(b)).join('');
                    imageBase64 = `${file.type};base64,${btoa(binary)}`;
                    imageFilename = data.building_c || data.s_code || `IMG_${Date.now()}.jpg`;
                }
            }
            
            // ปิดหน้าต่างทันที
            closePanel();
            showNotificationLeft('กำลังบันทึกข้อมูล...', 'info');
            
            try {
                // ตรวจสอบสถานะออนไลน์/ออฟไลน์
                if (!isOnline || !navigator.onLine) {
                    if (imageBase64) {
                        const imageId = await saveImageToDB(imageBase64, imageFilename, rowKey, markerType);
                        console.log(`รูปภาพถูกบันทึกไว้ในมือถือ (ID: ${imageId})`);
                    }
                    
                    const textData = { ...data };
                    if (imageBase64) {
                        textData.hasImage = true;
                        textData.imageFilename = imageFilename;
                    }
                    
                    const result = await sendDataWithRetry('update', markerType, textData, rowKey);
                    
                    if (result.success) {
                        editingMarker._popupData = { ...editingMarker._popupData, ...data };
                        setupMarkerPopup(editingMarker, editingMarker._popupData, markerType);
                        await loadExistingData();
                        showNotificationLeft('บันทึกข้อมูลเรียบร้อยแล้ว! (รูปภาพจะถูกอัปโหลดเมื่อออนไลน์)', 'success');
                    } else if (result.queued) {
                        editingMarker._popupData = { 
                            ...editingMarker._popupData, 
                            ...data,
                            queued: true,
                            queueId: result.queueId
                        };
                        setupMarkerPopup(editingMarker, editingMarker._popupData, markerType);
                        showNotificationLeft('บันทึกข้อมูลไว้ในมือถือ (รอซิงค์)', 'warning');
                    }
                    return;
                }
                
                // ถ้าออนไลน์ → ส่งข้อมูลทันที
                if (imageBase64) {
                    data.image = imageBase64;
                    data.fileName = imageFilename;
                }
                
                const result = await sendDataWithRetry('update', markerType, data, rowKey);
                
                if (result.success) {
                    editingMarker._popupData = { ...editingMarker._popupData, ...data };
                    setupMarkerPopup(editingMarker, editingMarker._popupData, markerType);
                    await loadExistingData();
                    showNotificationLeft('บันทึกข้อมูลเรียบร้อยแล้ว!', 'success');
                } else if (result.queued) {
                    editingMarker._popupData = { 
                        ...editingMarker._popupData, 
                        ...data,
                        queued: true,
                        queueId: result.queueId
                    };
                    setupMarkerPopup(editingMarker, editingMarker._popupData, markerType);
                    showNotificationLeft('บันทึกข้อมูลไว้ในมือถือ (รอซิงค์)', 'warning');
                }
                
            } catch (err) {
                console.error("Error saving ", err);
                
                try {
                    const textData = { ...data };
                    if (imageBase64) {
                        const imageId = await saveImageToDB(imageBase64, imageFilename, rowKey, markerType);
                        textData.hasImage = true;
                        textData.imageFilename = imageFilename;
                    }
                    
                    const queueId = addToSyncQueue('update', markerType, textData, rowKey);
                    
                    editingMarker._popupData = { 
                        ...editingMarker._popupData, 
                        ...data,
                        queued: true,
                        queueId: queueId
                    };
                    setupMarkerPopup(editingMarker, editingMarker._popupData, markerType);
                    showNotificationLeft('บันทึกข้อมูลไว้ในมือถือ (รอซิงค์)', 'warning');
                } catch (queueErr) {
                    console.error("Failed to save to queue:", queueErr);
                    showNotificationLeft('เกิดข้อผิดพลาดในการบันทึก!', 'error');
                }
            }
        }

        function closePanel() { document.getElementById('side-panel').classList.remove('open'); }

        function locateUser() { 
            map.locate({setView: true, maxZoom: 18}); 
            map.once('locationfound', (e) => {
                L.circleMarker(e.latlng, { radius: 8, fillColor: '#2563eb', color: '#fff', weight: 3, fillOpacity: 0.9 }).addTo(map);
            });
        }
        // ตัวแปรเก็บข้อมูลสำหรับการลบ
        let deleteMarkerData = null;
        let deleteMarkerType = null;
        let deleteMarkerRef = null;

        // เปิดหน้าต่างยืนยันการลบ
        function showDeleteConfirm(marker, data, type) {
            deleteMarkerRef = marker;
            deleteMarkerData = data;
            deleteMarkerType = type;
            
            const title = document.getElementById('delete-modal-title');
            const message = document.getElementById('delete-modal-message');
            
            if (type === 'building') {
                title.textContent = 'ลบสิ่งปลูกสร้าง';
                message.textContent = 'คุณแน่ใจว่าต้องการลบสิ่งปลูกสร้างนี้? การกระทำนี้ไม่สามารถยกเลิกได้';
            } else {
                title.textContent = 'ลบป้าย';
                message.textContent = 'คุณแน่ใจว่าต้องการลบป้ายนี้? การกระทำนี้ไม่สามารถยกเลิกได้';
            }
            
            document.getElementById('confirm-delete-modal').classList.remove('hidden');
            document.getElementById('confirm-delete-modal').classList.add('flex');
        }

        // ปิดหน้าต่างยืนยันการลบ
        function cancelDelete() {
            document.getElementById('confirm-delete-modal').classList.add('hidden');
            deleteMarkerData = null;
            deleteMarkerType = null;
            deleteMarkerRef = null;
        }

        // ยืนยันการลบ
        async function confirmDeleteAction() {
            if (!deleteMarkerRef || !deleteMarkerData || !deleteMarkerType) {
                cancelDelete();
                return;
            }
            
            // ปิดหน้าต่างยืนยัน
            document.getElementById('confirm-delete-modal').classList.add('hidden');
            
            try {
                await deleteMarker(deleteMarkerRef, deleteMarkerData, deleteMarkerType);
            } catch (err) {
                console.error("Error in delete action:", err);
            } finally {
                cancelDelete();
            }
        }

        // เปิดหน้าต่างโหมดแก้ไข
        function showEditModeModal() {
            document.getElementById('edit-mode-modal').classList.remove('hidden');
            document.getElementById('edit-mode-modal').classList.add('flex');
            
            // ปิดอัตโนมัติหลัง 3 วินาที
            setTimeout(() => {
                closeEditModeModal();
            }, 4000);
        }

        // ปิดหน้าต่างโหมดแก้ไข
        function closeEditModeModal() {
            document.getElementById('edit-mode-modal').classList.add('hidden');
        }

        // ฟังก์ชันสำหรับแสดง/ซ่อนตาราง
        function toggleTable() {
            const panel = document.getElementById('data-table-panel');
            const btn = document.getElementById('btn-show-table');
            const icon = document.getElementById('table-icon');
            
            panel.classList.toggle('open');
            
            if (panel.classList.contains('open')) {
                btn.innerHTML = '<i data-lucide="x" class="w-6 h-6 text-red-600"></i>';
            } else {
                btn.innerHTML = '<i data-lucide="table" class="w-6 h-6 text-blue-600"></i>';
            }
            
            lucide.createIcons();
        }

        // ฟังก์ชันสลับแท็บตาราง
        function switchTableTab(type) {
            // เปลี่ยนแท็บ
            document.querySelectorAll('.table-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // แสดงตารางที่เลือก
            document.getElementById('building-table-container').classList.toggle('hidden', type !== 'building');
            document.getElementById('sign-table-container').classList.toggle('hidden', type !== 'sign');
        }

        // ฟังก์ชันซูมไปที่ตำแหน่ง
        function zoomToLocation(latlng, zoomLevel = 18) {
            map.setView(latlng, zoomLevel);
            
            // สร้างเอฟเฟกต์กระพริบ
            const blinkMarker = L.circleMarker(latlng, {
                radius: 15,
                fillColor: '#ef4444',
                color: '#fff',
                weight: 3,
                fillOpacity: 0.8,
                opacity: 1
            }).addTo(map);
            
            // กระพริบ 3 ครั้ง
            let count = 0;
            const blinkInterval = setInterval(() => {
                blinkMarker.setStyle({
                    opacity: blinkMarker.options.opacity === 1 ? 0 : 1,
                    fillOpacity: blinkMarker.options.fillOpacity === 0.8 ? 0 : 0.8
                });
                count++;
                if (count >= 6) {
                    clearInterval(blinkInterval);
                    map.removeLayer(blinkMarker);
                }
            }, 300);
        }

        // ฟังก์ชันสร้างแถวข้อมูลสิ่งปลูกสร้าง
        function renderBuildingTable() {
            const tbody = document.getElementById('building-table-body');
            
            if (allBuildings.length === 0) {
                tbody.innerHTML = '<tr><td colspan="8" class="text-center py-8 text-gray-500">ไม่มีข้อมูลสิ่งปลูกสร้าง</td></tr>';
                return;
            }
            
            tbody.innerHTML = allBuildings.map((building, index) => {
                if (!building.lat_long) return '';
                
                const [lat, lng] = building.lat_long.split(',').map(Number);
                const statusClass = building.check === 'verified' ? 'status-verified' : 
                                   building.check === 'rejected' ? 'status-rejected' : 'status-pending';
                const statusText = building.check === 'verified' ? 'ตรวจสอบแล้ว' : 
                                  building.check === 'rejected' ? 'ปฏิเสธ' : 'รอดำเนินการ';
                
                return `
                    <tr>
                        <td><span class="marker-icon marker-building"></span></td>
                        <td class="font-medium">${building.building_c || '-'}</td>
                        <td>${building.full_name || '-'}</td>
                        <td>${building.address || '-'}</td>
                        <td>${building.b_type || '-'}</td>
                        <td>${building.b_area || '-'}</td>
                        <td><span class="status-badge ${statusClass}">${statusText}</span></td>
                        <td>
                            <button class="zoom-btn" onclick="zoomToLocation(L.latLng(${lat}, ${lng}))">
                                <i data-lucide="locate" class="w-3 h-3 inline"></i>
                            </button>
                        </td>
                    </tr>
                `;
            }).join('');
            
            lucide.createIcons();
        }
        // ============================================
        // ฟังก์ชันเมนูฟันเฟือง
        // ============================================

        /**
         * เปิด/ปิดเมนูฟันเฟือง
         */
        function toggleSettingsMenu() {
          const menu = document.getElementById('settings-menu');
          const icon = document.getElementById('settings-icon');
          const badge = document.getElementById('settings-badge');
          
          if (menu.classList.contains('hidden')) {
            // เปิดเมนู - ปุ่มย่อยเลื่อนลงมาทีละปุ่ม
            menu.classList.remove('hidden');
            icon.classList.add('animate-spin');
            
            // ซ่อนจุดแจ้งเตือน (ถ้ามี)
            badge.classList.add('hidden');
            
            // แอนิเมชันเลื่อนลงมาทีละปุ่ม
            setTimeout(() => {
              const buttons = menu.querySelectorAll('button');
              buttons.forEach((btn, index) => {
                setTimeout(() => {
                  btn.style.transform = 'translateY(0)';
                  btn.style.opacity = '1';
                }, index * 100);
              });
            }, 100);
            
            // ปิดเมนูอัตโนมัติเมื่อคลิกที่อื่น
            setTimeout(() => {
              document.addEventListener('click', closeSettingsMenuOnClickOutside);
            }, 100);
            
          } else {
            // ปิดเมนู
            closeSettingsMenu();
          }
        }

        /**
         * ปิดเมนูเมื่อคลิกที่อื่น
         */
        function closeSettingsMenuOnClickOutside(e) {
          const settingsBtn = document.getElementById('btn-settings');
          const settingsMenu = document.getElementById('settings-menu');
          
          if (!settingsBtn.contains(e.target) && !settingsMenu.contains(e.target)) {
            closeSettingsMenu();
            document.removeEventListener('click', closeSettingsMenuOnClickOutside);
          }
        }

        /**
         * ปิดเมนู
         */
        function closeSettingsMenu() {
          const menu = document.getElementById('settings-menu');
          const icon = document.getElementById('settings-icon');
          
          // แอนิเมชันเลื่อนขึ้นไป
          const buttons = menu.querySelectorAll('button');
          buttons.forEach((btn, index) => {
            setTimeout(() => {
              btn.style.transform = 'translateY(-20px)';
              btn.style.opacity = '0';
            }, (buttons.length - index - 1) * 50);
          });
          
          setTimeout(() => {
            menu.classList.add('hidden');
            icon.classList.remove('animate-spin');
          }, buttons.length * 50 + 100);
        }

        /**
         * ปุ่ม 1: ส่งออกแผนที่สิ่งปลูกสร้าง (GeoJSON)
         */
        async function exportBuildingGeoJSON() {
          closeSettingsMenu();
          
          // แสดงข้อความแจ้งเตือน
          showNotificationLeft('กำลังเตรียมข้อมูลสิ่งปลูกสร้าง...', 'info');
          
          try {
            // ดึงข้อมูลจากเซิร์ฟเวอร์
            const res = await fetch(`${CONFIG.SCRIPT_URL}?action=exportGeoJSON&type=building`);
            const geojsonData = await res.json();
            
            if (geojsonData.type === 'FeatureCollection') {
              // สร้าง Blob และดาวน์โหลดไฟล์
              const blob = new Blob([JSON.stringify(geojsonData, null, 2)], { 
                type: 'application/geo+json' 
              });
              
              const url = window.URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              a.download = `buildings_${new Date().toISOString().slice(0,10)}.geojson`;
              document.body.appendChild(a);
              a.click();
              window.URL.revokeObjectURL(url);
              document.body.removeChild(a);
              
              showNotificationLeft('ดาวน์โหลดไฟล์สิ่งปลูกสร้างสำเร็จ!', 'success');
            } else {
              throw new Error('ข้อมูลไม่ถูกต้อง');
            }
          } catch (err) {
            console.error('Error exporting buildings:', err);
            showNotificationLeft('เกิดข้อผิดพลาดในการส่งออกข้อมูล', 'error');
          }
        }

        /**
         * ปุ่ม 2: ส่งออกแผนที่ป้าย (GeoJSON)
         */
        async function exportSignGeoJSON() {
          closeSettingsMenu();
          
          showNotificationLeft('กำลังเตรียมข้อมูลป้าย...', 'info');
          
          try {
            const res = await fetch(`${CONFIG.SCRIPT_URL}?action=exportGeoJSON&type=sign`);
            const geojsonData = await res.json();
            
            if (geojsonData.type === 'FeatureCollection') {
              const blob = new Blob([JSON.stringify(geojsonData, null, 2)], { 
                type: 'application/geo+json' 
              });
              
              const url = window.URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              a.download = `signs_${new Date().toISOString().slice(0,10)}.geojson`;
              document.body.appendChild(a);
              a.click();
              window.URL.revokeObjectURL(url);
              document.body.removeChild(a);
              
              showNotificationLeft('ดาวน์โหลดไฟล์ป้ายสำเร็จ!', 'success');
            } else {
              throw new Error('ข้อมูลไม่ถูกต้อง');
            }
          } catch (err) {
            console.error('Error exporting signs:', err);
            showNotificationLeft('เกิดข้อผิดพลาดในการส่งออกข้อมูล', 'error');
          }
        }

        /**
         * ปุ่ม 3: โหลดรูปสิ่งปลูกสร้างจากโฟลเดอร์ Google Drive
         */
        async function loadBuildingImages() {
          closeSettingsMenu();
          
          showNotificationLeft('กำลังโหลดรูปภาพสิ่งปลูกสร้าง...', 'info');
          
          try {
            // ดึงข้อมูลสิ่งปลูกสร้างทั้งหมด
            const res = await fetch(`${CONFIG.SCRIPT_URL}?action=getData`);
            const data = await res.json();
            const buildings = data.buildings || [];
            
            // กรองเฉพาะที่มีรูปภาพ
            const buildingsWithImages = buildings.filter(b => b.image && b.image.trim() !== '');
            
            if (buildingsWithImages.length === 0) {
              showNotificationLeft('ไม่พบรูปภาพสิ่งปลูกสร้าง', 'warning');
              return;
            }
            
            // แสดงแกลเลอรี่รูปภาพ
            showImageGallery(buildingsWithImages, 'building');
            
          } catch (err) {
            console.error('Error loading building images:', err);
            showNotificationLeft('เกิดข้อผิดพลาดในการโหลดรูปภาพ', 'error');
          }
        }

        /**
         * ปุ่ม 4: โหลดรูปป้ายจากโฟลเดอร์ Google Drive
         */
        async function loadSignImages() {
          closeSettingsMenu();
          
          showNotificationLeft('กำลังโหลดรูปภาพป้าย...', 'info');
          
          try {
            const res = await fetch(`${CONFIG.SCRIPT_URL}?action=getData`);
            const data = await res.json();
            const signs = data.signs || [];
            
            const signsWithImages = signs.filter(s => s.picture && s.picture.trim() !== '');
            
            if (signsWithImages.length === 0) {
              showNotificationLeft('ไม่พบรูปภาพป้าย', 'warning');
              return;
            }
            
            showImageGallery(signsWithImages, 'sign');
            
          } catch (err) {
            console.error('Error loading sign images:', err);
            showNotificationLeft('เกิดข้อผิดพลาดในการโหลดรูปภาพ', 'error');
          }
        }

        /**
         * แสดงแกลเลอรี่รูปภาพ
         */
        function showImageGallery(items, type) {
          // สร้างหน้าต่างแกลเลอรี่
          const galleryDiv = document.createElement('div');
          galleryDiv.id = 'image-gallery-modal';
          galleryDiv.className = 'fixed inset-0 bg-black/90 z-[3000] flex flex-col p-4 overflow-hidden';
          galleryDiv.innerHTML = `
            <div class="flex justify-between items-center mb-4">
              <h3 class="text-white text-xl font-bold">
                ${type === 'building' ? 'รูปภาพสิ่งปลูกสร้าง' : 'รูปภาพป้าย'} (${items.length} รูป)
              </h3>
              <button onclick="closeImageGallery()" class="text-white hover:text-gray-300 transition">
                <i data-lucide="x" class="w-8 h-8"></i>
              </button>
            </div>
            <div id="gallery-grid" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3 flex-1 overflow-y-auto">
              ${items.map((item, index) => `
                <div class="relative group cursor-pointer" onclick="openImageViewer(${index}, '${type}')">
                  <img src="${item.image || item.picture}" 
                       alt="รูปภาพ ${index + 1}" 
                       class="w-full h-32 object-cover rounded-lg hover:opacity-75 transition"
                       onerror="this.src='https://via.placeholder.com/150?text=No+Image'">
                  <div class="absolute inset-0 bg-black/50 opacity-0 group-hover:opacity-100 transition-opacity rounded-lg flex items-center justify-center">
                    <span class="text-white text-sm font-bold">ดูรูปใหญ่</span>
                  </div>
                  <div class="mt-1 text-xs text-white truncate">
                    ${type === 'building' ? (item.building_c || item.full_name || '-') : (item.s_code || item.s_name || '-')}
                  </div>
                </div>
              `).join('')}
            </div>
            <div class="mt-4 text-center">
              <button onclick="closeImageGallery()" class="bg-red-600 text-white px-6 py-2 rounded-lg hover:bg-red-700 transition">
                ปิด
              </button>
            </div>
          `;
          
          document.body.appendChild(galleryDiv);
          lucide.createIcons();
        }

        /**
         * เปิดดูรูปภาพขนาดใหญ่
         */
        function openImageViewer(index, type) {
          // ดึงข้อมูลจากหน้าต่างแกลเลอรี่
          const gallery = document.getElementById('image-gallery-modal');
          const items = type === 'building' ? allBuildings.filter(b => b.image) : allSigns.filter(s => s.picture);
          const item = items[index];
          
          if (!item) return;
          
          // สร้างหน้าต่างดูรูปใหญ่
          const viewerDiv = document.createElement('div');
          viewerDiv.id = 'image-viewer-modal';
          viewerDiv.className = 'fixed inset-0 bg-black/95 z-[3001] flex items-center justify-center p-4';
          viewerDiv.onclick = (e) => {
            if (e.target === viewerDiv) closeImageViewer();
          };
          viewerDiv.innerHTML = `
            <div class="relative max-w-4xl w-full">
              <img src="${item.image || item.picture}" 
                   alt="รูปภาพ" 
                   class="w-full max-h-[80vh] object-contain rounded-lg"
                   onerror="this.src='https://via.placeholder.com/800x600?text=No+Image'">
              <div class="absolute bottom-4 left-4 right-4 bg-black/70 text-white p-3 rounded-lg">
                <p class="font-bold">${type === 'building' ? 'สิ่งปลูกสร้าง:' : 'ป้าย:'} ${item.building_c || item.s_code || '-'}</p>
                <p class="text-sm">${item.full_name || item.s_name || ''}</p>
                <p class="text-xs mt-1">${item.address || item.comment || ''}</p>
              </div>
              <button onclick="closeImageViewer()" class="absolute top-4 right-4 text-white hover:text-gray-300 transition">
                <i data-lucide="x" class="w-8 h-8"></i>
              </button>
              <button onclick="downloadImage('${item.image || item.picture}', '${item.building_c || item.s_code || 'image'}')" 
                      class="absolute top-4 left-4 bg-blue-600 text-white p-2 rounded-lg hover:bg-blue-700 transition">
                <i data-lucide="download" class="w-5 h-5"></i>
              </button>
            </div>
          `;
          
          document.body.appendChild(viewerDiv);
          lucide.createIcons();
        }

        /**
         * ปิดหน้าต่างดูรูปใหญ่
         */
        function closeImageViewer() {
          const viewer = document.getElementById('image-viewer-modal');
          if (viewer) viewer.remove();
        }

        /**
         * ปิดแกลเลอรี่รูปภาพ
         */
        function closeImageGallery() {
          const gallery = document.getElementById('image-gallery-modal');
          if (gallery) gallery.remove();
          closeImageViewer(); // ปิดหน้าต่างดูรูปใหญ่ด้วย (ถ้ามี)
        }

        /**
         * ดาวน์โหลดรูปภาพ
         */
        function downloadImage(url, filename) {
          const link = document.createElement('a');
          link.href = url;
          link.download = `${filename}_${Date.now()}.jpg`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        }

        /**
         * แสดงแจ้งเตือน
         */
        function showNotificationLeft(message, type = 'info') {
          const colors = {
            info: 'bg-blue-500',
            success: 'bg-green-500',
            error: 'bg-red-500',
            warning: 'bg-yellow-500'
          };
          
          const icons = {
            info: 'info',
            success: 'check-circle',
            error: 'alert-circle',
            warning: 'alert-triangle'
          };
          
          const notification = document.createElement('div');
          notification.className = `fixed top-4 left-4 ${colors[type]} text-white px-6 py-3 rounded-lg shadow-lg z-[2000] animate-fade-in`;
          notification.innerHTML = `
            <i data-lucide="${icons[type]}" class="w-5 h-5 inline mr-2"></i>
            ${message}
          `;
          
          document.body.appendChild(notification);
          lucide.createIcons();
          
          setTimeout(() => {
            notification.classList.add('animate-fade-out');
            setTimeout(() => notification.remove(), 300);
          }, 500);
        }
        /**
         * แสดงมาร์กเกอร์ทั้งหมด (สำหรับข้อมูลน้อย)
         */
        function renderAllMarkers() {
          allBuildings.forEach(r => {
            if (!r.lat_long) return;
            const coords = r.lat_long.split(',').map(Number);
            if (coords.length < 2 || isNaN(coords[0]) || isNaN(coords[1])) return;
            const m = createCircleMarker(L.latLng(coords[0], coords[1]), 'building', isEditMode);
            setupMarkerPopup(m, r, 'building');
            m.addTo(surveyLayers);
            if (isEditMode) enableMarkerDragging(m, r);
          });
          
          allSigns.forEach(r => {
            if (!r.lat_long) return;
            const coords = r.lat_long.split(',').map(Number);
            if (coords.length < 2 || isNaN(coords[0]) || isNaN(coords[1])) return;
            const m = createCircleMarker(L.latLng(coords[0], coords[1]), 'sign', isEditMode);
            setupMarkerPopup(m, r, 'sign');
            m.addTo(surveyLayers);
            if (isEditMode) enableMarkerDragging(m, r);
          });
        }

        /**
         * อัปเดตมาร์กเกอร์เฉพาะในมุมมองปัจจุบัน (สำหรับข้อมูลจำนวนมาก)
         */
        function updateVisibleMarkers() {
            // เก็บจุดชั่วคราวทั้งหมดก่อนล้าง
            const pendingMarkers = [];
            surveyLayers.eachLayer(layer => {
                if (layer._popupData) {
                    if (layer._popupData.queued || layer._popupData.tempMarker) {
                        pendingMarkers.push({
                            latlng: layer.getLatLng(),
                            data: layer._popupData,
                            type: layer._popupData.type
                        });
                    }
                }
            });
            
            surveyLayers.clearLayers();
            const bounds = map.getBounds();
            
            // แสดงเฉพาะสิ่งปลูกสร้างในมุมมอง
            allBuildings.forEach(r => {
                if (!r.lat_long) return;
                const coords = r.lat_long.split(',').map(Number);
                if (coords.length < 2 || isNaN(coords[0]) || isNaN(coords[1])) return;
                const latLng = L.latLng(coords[0], coords[1]);
                if (!bounds.contains(latLng)) return;
                
                // ✅ แก้ตรงนี้: ใช้ทั้ง _row_num และ id
                const recordKey = r._row_num || r.id;
                if (markersBeingMoved.has(recordKey)) {
                    return; // ข้ามการสร้างจุดจริง
                }
                
                const m = createCircleMarker(latLng, 'building', isEditMode);
                setupMarkerPopup(m, r, 'building');
                m.addTo(surveyLayers);
                if (isEditMode) enableMarkerDragging(m, r);
            });
            
            // แสดงเฉพาะป้ายในมุมมอง
            allSigns.forEach(r => {
                if (!r.lat_long) return;
                const coords = r.lat_long.split(',').map(Number);
                if (coords.length < 2 || isNaN(coords[0]) || isNaN(coords[1])) return;
                const latLng = L.latLng(coords[0], coords[1]);
                if (!bounds.contains(latLng)) return;
                
                // ✅ ตรวจสอบว่าจุดนี้กำลังถูกย้ายหรือไม่
                const recordKey = r._row_num || r.id; // ✅ เพิ่มบรรทัดนี้
                if (markersBeingMoved.has(recordKey)) { // ✅ แก้เป็น recordKey
                    return;
                }
                
                const m = createCircleMarker(latLng, 'sign', isEditMode);
                setupMarkerPopup(m, r, 'sign');
                m.addTo(surveyLayers);
                if (isEditMode) enableMarkerDragging(m, r);
            });
            
            // เพิ่มจุดชั่วคราวกลับเข้ามา
            pendingMarkers.forEach(marker => {
                const m = createCircleMarker(marker.latlng, marker.type, isEditMode);
                m._popupData = marker.data;
                setupMarkerPopup(m, marker.data, marker.type);
                m.addTo(surveyLayers);
                if (isEditMode) enableMarkerDragging(m, marker.data);
            });
        }

        // เปิดใช้งานการลากมาร์กเกอร์ในโหมดแก้ไข
        function enableMarkerDragging(marker, data) {
            if (!isEditMode) return;
            
            // ✅ เปิดใช้งานการลาก
            if (marker.dragging && marker.dragging.enable) {
                marker.dragging.enable();
            }
            
            // ผูกเหตุการณ์เมื่อลากเสร็จ
            marker.off('dragend');
            marker.on('dragend', async function(e) {
                const newLatLng = e.target.getLatLng();
                const marker = e.target;
                const data = marker._popupData;
                
                if (data) {
                    await updateMarkerPosition(marker, data, newLatLng);
                }
            });
        }

        // ฟังก์ชันสร้างแถวข้อมูลป้าย
        function renderSignTable() {
            const tbody = document.getElementById('sign-table-body');
            
            if (allSigns.length === 0) {
                tbody.innerHTML = '<tr><td colspan="8" class="text-center py-8 text-gray-500">ไม่มีข้อมูลป้าย</td></tr>';
                return;
            }
            
            tbody.innerHTML = allSigns.map((sign, index) => {
                if (!sign.lat_long) return '';
                
                const [lat, lng] = sign.lat_long.split(',').map(Number);
                
                return `
                    <tr>
                        <td><span class="marker-icon marker-sign"></span></td>
                        <td class="font-medium">${sign.s_code || '-'}</td>
                        <td>${sign.s_name || '-'}</td>
                        <td>${sign.s_type || '-'}</td>
                        <td>${sign.s_wide || '-'}</td>
                        <td>${sign.s_length || '-'}</td>
                        <td>${sign.s_text || '-'}</td>
                        <td>
                            <button class="zoom-btn" onclick="zoomToLocation(L.latLng(${lat}, ${lng}))">
                                <i data-lucide="locate" class="w-3 h-3 inline"></i>
                            </button>
                        </td>
                    </tr>
                `;
            }).join('');
            
            lucide.createIcons();
        }

        async function loadExistingData() {
            try {
                const res = await fetch(`${CONFIG.SCRIPT_URL}?action=getData`);
                const data = await res.json();
                
                // เก็บจุดชั่วคราวทั้งหมดก่อนล้าง
                const tempMarkers = [];
                surveyLayers.eachLayer(layer => {
                    if (layer._popupData && layer._popupData.tempMarker) {
                        tempMarkers.push({
                            latlng: layer.getLatLng(),
                            data: layer._popupData,
                            type: layer._popupData.type
                        });
                    }
                });
                
                surveyLayers.clearLayers();
                
                // โหลดข้อมูลจริงจากเซิร์ฟเวอร์
                allBuildings = data.buildings || [];
                allSigns = data.signs || [];
                
                // แสดงข้อมูลในตาราง
                renderBuildingTable();
                renderSignTable();
                
                const totalMarkers = allBuildings.length + allSigns.length;
                const useOptimizedRendering = totalMarkers > 200;
                
                if (useOptimizedRendering) {
                    map.off('moveend', updateVisibleMarkers);
                    map.off('zoomend', updateVisibleMarkers);
                    map.on('moveend', updateVisibleMarkers);
                    map.on('zoomend', updateVisibleMarkers);
                    updateVisibleMarkers(); // ✅ ฟังก์ชันนี้ยังมีการตรวจสอบ markersBeingMoved (สำหรับการเลื่อนแผนที่ระหว่างย้าย)
                } else {
                    // ✅ สร้างจุดจริงทั้งหมดโดยไม่ตรวจสอบ markersBeingMoved
                    allBuildings.forEach(r => {
                        if (!r.lat_long) return;
                        const coords = r.lat_long.split(',').map(Number);
                        if (coords.length < 2 || isNaN(coords[0]) || isNaN(coords[1])) return;
                        // ❌ ลบบรรทัดนี้ออกทั้งหมด:
                        // if (markersBeingMoved.has(r._row_num)) return;
                        const m = createCircleMarker(L.latLng(coords[0], coords[1]), 'building', isEditMode);
                        setupMarkerPopup(m, r, 'building');
                        m.addTo(surveyLayers);
                        if (isEditMode) enableMarkerDragging(m, r);
                    });
                    
                    allSigns.forEach(r => {
                        if (!r.lat_long) return;
                        const coords = r.lat_long.split(',').map(Number);
                        if (coords.length < 2 || isNaN(coords[0]) || isNaN(coords[1])) return;
                        // ❌ ลบบรรทัดนี้ออกทั้งหมด:
                        // if (markersBeingMoved.has(r._row_num)) return;
                        const m = createCircleMarker(L.latLng(coords[0], coords[1]), 'sign', isEditMode);
                        setupMarkerPopup(m, r, 'sign');
                        m.addTo(surveyLayers);
                        if (isEditMode) enableMarkerDragging(m, r);
                    });
                }
                
                // ✅ เพิ่มจุดชั่วคราวกลับเข้ามา (จะมีทั้งจุดจริงและจุดชั่วคราวชั่วคราว 300ms)
                tempMarkers.forEach(marker => {
                    const m = createCircleMarker(marker.latlng, marker.type, isEditMode);
                    m._popupData = marker.data;
                    setupMarkerPopup(m, marker.data, marker.type);
                    m.addTo(surveyLayers);
                    if (isEditMode) enableMarkerDragging(m, marker.data);
                });
            } catch(e) {
                console.error("Error loading data:", e);
            }
        }

        // ============================================
        // Offline Data Storage System
        // ============================================

        // ตรวจจับสถานะออนไลน์
        let isOnline = navigator.onLine;
        let syncQueue = [];

        // แสดงสถานะการเชื่อมต่อ
        function updateConnectionStatus() {
            const statusDiv = document.getElementById('connection-status');
            if (!statusDiv) {
                const div = document.createElement('div');
                div.id = 'connection-status';
                div.className = 'fixed top-4 left-4 px-4 py-2 rounded-lg text-white font-bold shadow-lg z-[2000]';
                document.body.appendChild(div);
            }
            
            const status = document.getElementById('connection-status');
            if (isOnline) {
                status.textContent = '✓ เชื่อมต่ออินเทอร์เน็ต';
                status.className = 'fixed top-4 left-4 px-4 py-2 rounded-lg text-white font-bold shadow-lg z-[2000] bg-green-500';
            } else {
                status.textContent = '⚠️ โหมดออฟไลน์ - ข้อมูลจะถูกเก็บไว้ในมือถือ';
                status.className = 'fixed top-4 left-4 px-4 py-2 rounded-lg text-white font-bold shadow-lg z-[2000] bg-yellow-500';
            }
            
            // ซ่อนอัตโนมัติหลัง 3 วินาที
            setTimeout(() => {
                status.style.opacity = '0';
                setTimeout(() => status.remove(), 300);
            }, 1000);
        }

        // ฟังก์ชันตรวจสอบการเชื่อมต่อ
        window.addEventListener('online', () => {
            isOnline = true;
            updateConnectionStatus();
            // เมื่อกลับมาออนไลน์ ให้พยายามส่งข้อมูลที่ค้างอยู่
            setTimeout(processSyncQueue, 1000);
        });

        window.addEventListener('offline', () => {
            isOnline = false;
            updateConnectionStatus();
        });

        // ฟังก์ชันเก็บข้อมูลในคิว
        function addToSyncQueue(action, type, data, rowKey = null) {
            const queueItem = {
                id: Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                timestamp: new Date().toISOString(),
                action: action, // 'add', 'update', 'delete', 'updatePosition'
                type: type,     // 'building', 'sign'
                data: data,
                rowKey: rowKey,
                status: 'pending', // pending, success, failed
                retryCount: 0
            };
            
            syncQueue.push(queueItem);
            saveSyncQueueToStorage();
            
            // แสดงแจ้งเตือน
            showNotificationLeft(`บันทึกข้อมูลไว้ในมือถือ (${syncQueue.length} รายการรอซิงค์)`, 'warning');
            
            return queueItem.id;
        }

        // บันทึกคิวลงใน LocalStorage
        function saveSyncQueueToStorage() {
            localStorage.setItem('syncQueue', JSON.stringify(syncQueue));
        }

        // โหลดคิวจาก LocalStorage
        function loadSyncQueueFromStorage() {
            const saved = localStorage.getItem('syncQueue');
            if (saved) {
                syncQueue = JSON.parse(saved);
            }
        }

        // ลบรายการที่สำเร็จแล้ว
        function removeFromSyncQueue(id) {
            syncQueue = syncQueue.filter(item => item.id !== id);
            saveSyncQueueToStorage();
        }

        // ============================================
        // ฟังก์ชันส่งข้อมูลแบบมีการลองใหม่ (Retry Mechanism)
        // ============================================

        async function sendDataWithRetry(action, type, data, rowKey = null, maxRetries = 5) {
            // ถ้าออฟไลน์ → เก็บไว้ในคิวทันที
            if (!isOnline || !navigator.onLine) {
                return addToSyncQueue(action, type, data, rowKey);
            }
            
            let retryCount = 0;
            
            while (retryCount < maxRetries) {
                try {
                    const body = new URLSearchParams();
                    body.append('action', action);
                    body.append('type', type);
                    
                    if (rowKey) {
                        body.append('rowKey', rowKey);
                    }
                    
                    if (data) {
                        // ✅ แยกข้อมูลรูปภาพออก
                        const { image, fileName, ...textData } = data;
                        
                        // ส่งข้อมูลข้อความ
                        if (Object.keys(textData).length > 0) {
                            body.append('payload', JSON.stringify(textData));
                        }
                        
                        // ✅ ส่งรูปภาพไปยังเซิร์ฟเวอร์ทันที
                        if (image && fileName) {
                            body.append('image', image);
                            body.append('fileName', fileName);
                            console.log(`ส่งรูปภาพไปยังเซิร์ฟเวอร์: ${fileName}`);
                        }
                    }
                    
                    const res = await fetch(CONFIG.SCRIPT_URL.trim(), {
                        method: 'POST',
                        body,
                        timeout: action === 'updateImage' || (data && data.image) ? 60000 : 30000
                    });
                    
                    if (res.ok) {
                        // ✅ แก้ไขตรงนี้: เพิ่มชื่อคีย์ 'data'
                        return { success: true, data: await res.json() };
                    } else {
                        throw new Error(`HTTP ${res.status}`);
                    }
                } catch (err) {
                    retryCount++;
                    
                    if (retryCount >= maxRetries) {
                        // ✅ หากล้มเหลวทุกครั้ง ให้บันทึกลงคิว
                        const queueId = addToSyncQueue(action, type, data, rowKey);
                        console.error(`Failed after ${maxRetries} retries. Saved to queue: ${queueId}`);
                        return { success: false, queued: true, queueId: queueId };
                    }
                    
                    const waitTime = 1000 * Math.pow(2, retryCount);
                    console.log(`Retry ${retryCount}/${maxRetries} after ${waitTime}ms...`);
                    
                    // รอเวลาที่กำหนด
                    await new Promise(resolve => setTimeout(resolve, waitTime));
                }
            }
        }

        // ============================================
        // Enhanced Sync Process with Image Support
        // ============================================

        async function processSyncQueue() {
            if (!isOnline || syncQueue.length === 0) return;
            
            showNotificationLeft(`กำลังซิงค์ข้อมูล (${syncQueue.length} รายการ)...`, 'info');
            
            const failedItems = [];
            
            for (let item of syncQueue) {
                if (item.status === 'success') continue;
                
                try {
                    const result = await sendDataWithRetry(
                        item.action,
                        item.type,
                        item.data,
                        item.rowKey,
                        3
                    );
                    
                    if (result.success) {
                        item.status = 'success';
                        removeFromSyncQueue(item.id);
                        console.log(`Synced: ${item.id}`);
                    } else {
                        item.retryCount++;
                        if (item.retryCount >= 5) {
                            item.status = 'failed';
                            failedItems.push(item);
                        }
                    }
                } catch (err) {
                    item.retryCount++;
                    console.error(`Error syncing ${item.id}:`, err);
                    
                    if (item.retryCount >= 5) {
                        item.status = 'failed';
                        failedItems.push(item);
                    }
                }
                
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            
            // ซิงค์รูปภาพที่ยังไม่ได้ส่ง
            await syncPendingImages();
            
            saveSyncQueueToStorage();
            
            // แจ้งผลลัพธ์
            const successCount = syncQueue.filter(i => i.status === 'success').length;
            const pendingCount = syncQueue.filter(i => i.status === 'pending').length;
            
            if (pendingCount === 0 && failedItems.length === 0) {
                showNotificationLeft(`ซิงค์ข้อมูลสำเร็จทั้งหมด!`, 'success');
            } else if (pendingCount > 0) {
                showNotificationLeft(`ซิงค์ข้อมูล ${successCount} รายการ (${pendingCount} รายการรอซิงค์)`, 'warning');
            }
            
            if (failedItems.length > 0) {
                showNotificationLeft(`มี ${failedItems.length} รายการที่ซิงค์ไม่สำเร็จ`, 'error');
            }
        }

        // ============================================
        // ฟังก์ชันซิงค์รูปภาพที่ยังไม่ได้ส่ง (แก้ไขแล้ว)
        // ============================================
        async function syncPendingImages() {
            try {
                const unsyncedImages = await getUnsyncedImages();
                
                if (unsyncedImages.length === 0) return;
                
                showNotificationLeft(`กำลังอัปโหลดรูปภาพ (${unsyncedImages.length} รูป)...`, 'info');
                
                for (const image of unsyncedImages) {
                    try {
                        // ✅ ตรวจสอบว่ารูปภาพถูกส่งแล้วหรือไม่
                        if (image.synced) {
                            console.log(`รูปภาพ ${image.filename} ถูกส่งแล้ว ข้าม...`);
                            continue;
                        }
                        
                        // หาข้อมูลที่เกี่ยวข้อง
                        const relatedData = syncQueue.find(q => q.rowKey === image.relatedId);
                        
                        if (!relatedData) {
                            console.warn(`ไม่พบข้อมูลที่เกี่ยวข้องกับรูปภาพ ${image.id}`);
                            continue;
                        }
                        
                        // ✅ ส่งรูปภาพไปยังเซิร์ฟเวอร์
                        const body = new URLSearchParams();
                        body.append('action', 'updateImage');
                        body.append('type', image.type);
                        body.append('rowKey', image.relatedId);
                        body.append('image', image.data);
                        body.append('fileName', image.filename);
                        
                        const res = await fetch(CONFIG.SCRIPT_URL.trim(), {
                            method: 'POST',
                            body,
                            timeout: 60000 // 60 วินาที (รูปภาพใช้เวลานานกว่า)
                        });
                        
                        if (res.ok) {
                            await markImageAsSynced(image.id);
                            console.log(`อัปโหลดรูปภาพสำเร็จ: ${image.filename}`);
                            showNotificationLeft(`อัปโหลดรูปภาพ ${image.filename} สำเร็จ!`, 'success');
                        } else {
                            image.retryCount = (image.retryCount || 0) + 1;
                            if (image.retryCount >= 5) {
                                console.error(`อัปโหลดรูปภาพล้มเหลวเกิน 5 ครั้ง: ${image.filename}`);
                            }
                        }
                    } catch (err) {
                        console.error(`Error syncing image ${image.id}:`, err);
                        if (!image.retryCount) image.retryCount = 0;
                        image.retryCount++;
                    }
                    
                    // รอ 2 วินาทีระหว่างส่งแต่ละรูป
                    await new Promise(resolve => setTimeout(resolve, 2000));
                }
                
                // ลบรูปภาพที่ซิงค์สำเร็จแล้ว
                await cleanupSyncedImages();
                
            } catch (err) {
                console.error('Error syncing images:', err);
            }
        }

        // โหลดคิวเมื่อแอปเริ่มทำงาน
        loadSyncQueueFromStorage();

        // เพิ่มปุ่มตรวจสอบสถานะซิงค์ในเมนูฟันเฟือง
        // ในฟังก์ชัน toggleSettingsMenu ให้เพิ่มปุ่มใหม่:

        /*
        <button onclick="checkSyncStatus()" class="map-btn p-3 w-48 bg-gradient-to-r from-gray-400 to-gray-600 text-white hover:scale-105 transition-all shadow-lg flex items-center justify-start gap-2 text-left">
            <i data-lucide="sync" class="w-5 h-5"></i>
            <span class="text-xs font-bold">ตรวจสอบสถานะซิงค์</span>
        </button>
        */

        // ฟังก์ชันตรวจสอบสถานะ
        function checkSyncStatus() {
            closeSettingsMenu();
            
            const pending = syncQueue.filter(i => i.status === 'pending').length;
            const failed = syncQueue.filter(i => i.status === 'failed').length;
            const success = syncQueue.filter(i => i.status === 'success').length;
            
            let message = `📊 สถานะการซิงค์ข้อมูล:\n`;
            message += `✅ สำเร็จ: ${success} รายการ\n`;
            message += `⏳ รอซิงค์: ${pending} รายการ\n`;
            message += `❌ ล้มเหลว: ${failed} รายการ`;
            
            if (pending > 0) {
                message += `\n\n⚠️ มีข้อมูลที่ยังไม่ได้ซิงค์!`;
            }
            
            alert(message);
            
            // ถ้ามีข้อมูลรอซิงค์ ถามว่าต้องการซิงค์เลยไหม
            if (pending > 0 && isOnline) {
                if (confirm(`ต้องการซิงค์ข้อมูล ${pending} รายการที่รออยู่เลยหรือไม่?`)) {
                    processSyncQueue();
                }
            }
        }

        // ============================================
        // Auto-check and sync on app startup
        // ============================================

        async function checkAndSyncOnStartup() {
            console.log('ตรวจสอบข้อมูลที่รอซิงค์...');
            
            // โหลดคิวจาก localStorage
            loadSyncQueueFromStorage();
            
            // ตรวจสอบรูปภาพที่ยังไม่ได้ซิงค์
            try {
                const unsyncedImages = await getUnsyncedImages();
                const pendingCount = syncQueue.filter(i => i.status === 'pending').length;
                
                if (pendingCount > 0 || unsyncedImages.length > 0) {
                    const totalPending = pendingCount + unsyncedImages.length;
                    
                    showNotificationLeft(
                        `พบข้อมูลที่รอซิงค์ ${totalPending} รายการ`, 
                        'warning'
                    );
                    
                    // ถ้าออนไลน์ → เริ่มซิงค์ทันที
                    if (isOnline) {
                        setTimeout(() => {
                            showNotificationLeft('กำลังซิงค์ข้อมูล...', 'info');
                            processSyncQueue();
                        }, 1000);
                    } else {
                        showNotificationLeft('⚠️ อยู่ในโหมดออฟไลน์ - รอการเชื่อมต่อ', 'warning');
                    }
                }
            } catch (err) {
                console.error('Error checking pending data:', err);
            }
        }

        // ✅ มีเพียงระบบใหม่
        // ใช้ window.addEventListener แทน  เพื่อป้องกันการทับซ้อน
        window.addEventListener('load', async () => {
            // 1. เริ่มต้นแผนที่และไอคอน
            initMap();
            lucide.createIcons();
            loadExistingData();
            
            // 2. ตรวจสอบและซิงค์ข้อมูลที่ค้างอยู่ (สำคัญสำหรับระบบออฟไลน์)
            await checkAndSyncOnStartup();
            
            // 3. อัปเดตจุดแจ้งเตือนจำนวนข้อมูลที่รอซิงค์
            setInterval(() => {
                updateSyncBadge();
            }, 1000);

        window.addEventListener('beforeunload', () => {
            stopRealtimeAutoUpdate(); // ✅ หยุดระบบใหม่
        });
            
            // 4. ลงทะเบียน Service Worker สำหรับแคชไทล์
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('/sw.js')
                    .then((registration) => {
                        console.log('Service Worker registered:', registration.scope);
                    })
                    .catch((error) => {
                        console.log('Service Worker registration failed:', error);
                    });
            }
        });

        // แสดงจำนวนข้อมูลที่รอซิงค์ในปุ่มฟันเฟือง
        function updateSyncBadge() {
            const pending = syncQueue.filter(i => i.status === 'pending').length;
            const badge = document.getElementById('settings-badge');
            
            if (pending > 0) {
                badge.textContent = pending > 9 ? '9+' : pending;
                badge.classList.remove('hidden');
            } else {
                badge.classList.add('hidden');
            }
        }

        // เรียกใช้ทุกครั้งที่มีการเปลี่ยนแปลงคิว
        setInterval(updateSyncBadge, 1000);

        // ============================================
        // IndexedDB Storage for Images
        // ============================================

        let dbPromise = null;

        // เปิด/สร้าง IndexedDB
        function openDatabase() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('SurveyAppDB', 2);
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    
                    // สร้าง Store สำหรับรูปภาพ
                    if (!db.objectStoreNames.contains('images')) {
                        const imageStore = db.createObjectStore('images', { 
                            keyPath: 'id' 
                        });
                        imageStore.createIndex('timestamp', 'timestamp');
                        imageStore.createIndex('synced', 'synced');
                    }
                    
                    // สร้าง Store สำหรับข้อมูลซิงค์
                    if (!db.objectStoreNames.contains('syncQueue')) {
                        const queueStore = db.createObjectStore('syncQueue', { 
                            keyPath: 'id' 
                        });
                        queueStore.createIndex('status', 'status');
                        queueStore.createIndex('timestamp', 'timestamp');
                    }
                };
                
                request.onsuccess = (event) => {
                    resolve(event.target.result);
                };
                
                request.onerror = (event) => {
                    reject(event.target.error);
                };
            });
        }

        // บันทึกรูปภาพลงใน IndexedDB (พร้อมตรวจสอบพื้นที่และจัดการข้อผิดพลาด)
        async function saveImageToDB(imageData, filename, relatedId, type) {
            try {
                // ✅ ตรวจสอบขนาดรูปภาพก่อนบันทึก
                const estimateSize = Math.ceil(imageData.length * 0.75); // ประมาณขนาดจริง (ลบ 25% จาก base64)
                
                if (estimateSize > 3 * 1024 * 1024) { // เตือนถ้าเกิน 3MB
                    showNotificationLeft('⚠️ รูปภาพใหญ่เกินไป อาจใช้พื้นที่มาก', 'warning');
                }
                
                const db = await openDatabase();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction('images', 'readwrite');
                    const store = transaction.objectStore('images');
                    
                    const imageRecord = {
                        id: Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                        filename: filename,
                         imageData, // base64 string
                        relatedId: relatedId,
                        type: type, // 'building' หรือ 'sign'
                        timestamp: new Date().toISOString(),
                        synced: false,
                        retryCount: 0
                    };
                    
                    const request = store.add(imageRecord);
                    
                    request.onsuccess = () => {
                        console.log(`บันทึกรูปภาพสำเร็จ: ${filename} (${Math.round(estimateSize / 1024)} KB)`);
                        resolve(imageRecord.id);
                    };
                    
                    request.onerror = (event) => {
                        // ✅ ตรวจสอบข้อผิดพลาดพื้นที่เต็ม
                        if (event.target.error && event.target.error.name === 'QuotaExceededError') {
                            showNotificationLeft(
                                '❌ พื้นที่เก็บข้อมูลเต็ม! โปรดซิงค์ข้อมูลก่อนถ่ายรูปเพิ่ม',
                                'error'
                            );
                            reject(new Error('Storage quota exceeded'));
                        } else {
                            console.error('Error saving image to DB:', event.target.error);
                            reject(event.target.error);
                        }
                    };
                });
            } catch (err) {
                console.error('Error in saveImageToDB:', err);
                throw err;
            }
        }

        async function checkStorageSpace() {
            try {
                if ('storage' in navigator && 'estimate' in navigator.storage) {
                    const estimate = await navigator.storage.estimate();
                    const usage = estimate.usage || 0;
                    const quota = estimate.quota || 50 * 1024 * 1024; // 50MB default
                    
                    const usagePercent = (usage / quota) * 100;
                    
                    if (usagePercent > 80) {
                        showNotificationLeft(
                            `⚠️ พื้นที่เก็บข้อมูลเหลือน้อย (${Math.round(100 - usagePercent)}%)`,
                            'warning'
                        );
                    }
                    
                    if (usagePercent > 95) {
                        showNotificationLeft(
                            `❌ พื้นที่เก็บข้อมูลเกือบเต็ม! โปรดซิงค์ข้อมูล`,
                            'error'
                        );
                    }
                }
            } catch (err) {
                console.error('Error checking storage:', err);
            }
        }

        // ดึงรูปภาพที่ยังไม่ได้ซิงค์
        async function getUnsyncedImages() {
            const db = await openDatabase();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction('images', 'readonly');
                const store = transaction.objectStore('images');
                const index = store.index('synced');
                const range = IDBKeyRange.only(false);
                
                const request = index.openCursor(range);
                const images = [];
                
                request.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        images.push(cursor.value);
                        cursor.continue();
                    } else {
                        resolve(images);
                    }
                };
                
                request.onerror = () => {
                    reject(request.error);
                };
            });
        }

        // ทำเครื่องหมายว่ารูปภาพซิงค์สำเร็จแล้ว
        async function markImageAsSynced(imageId) {
            const db = await openDatabase();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction('images', 'readwrite');
                const store = transaction.objectStore('images');
                
                const request = store.get(imageId);
                
                request.onsuccess = (event) => {
                    const image = event.target.result;
                    if (image) {
                        image.synced = true;
                        const updateRequest = store.put(image);
                        updateRequest.onsuccess = () => resolve();
                        updateRequest.onerror = () => reject(updateRequest.error);
                    } else {
                        reject(new Error('Image not found'));
                    }
                };
                
                request.onerror = () => {
                    reject(request.error);
                };
            });
        }

        // ลบรูปภาพที่ซิงค์สำเร็จแล้ว
        async function cleanupSyncedImages() {
            const db = await openDatabase();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction('images', 'readwrite');
                const store = transaction.objectStore('images');
                const index = store.index('synced');
                const range = IDBKeyRange.only(true);
                
                const request = index.openCursor(range);
                
                request.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        store.delete(cursor.primaryKey);
                        cursor.continue();
                    } else {
                        resolve();
                    }
                };
                
                request.onerror = () => {
                    reject(request.error);
                };
            });
        }

        // สร้างฟังก์ชันแสดงแจ้งเตือนฝั่งซ้าย
        function showNotificationLeft(message, type = 'info') {
            // ลบแจ้งเตือนเก่า
            const oldNotif = document.querySelector('.notification-left');
            if (oldNotif) oldNotif.remove();
            
            // กำหนดสีตามประเภท
            let bgColor = 'bg-blue-500';
            let icon = 'loader';
            
            if (type === 'success') {
                bgColor = 'bg-green-500';
                icon = 'check-circle';
            } else if (type === 'error') {
                bgColor = 'bg-red-500';
                icon = 'alert-circle';
            } else if (type === 'warning') {
                bgColor = 'bg-yellow-500';
                icon = 'alert-triangle';
            }
            
            // สร้างแจ้งเตือน
            const notif = document.createElement('div');
            notif.className = `fixed top-4 left-4 px-6 py-3 rounded-lg shadow-lg z-[2000] animate-fade-in notification-left ${bgColor} text-white font-bold flex items-center gap-2`;
            notif.innerHTML = `
                <i data-lucide="${icon}" class="w-5 h-5"></i>
                <span>${message}</span>
            `;
            
            document.body.appendChild(notif);
            lucide.createIcons({ elements: notif.querySelectorAll('[data-lucide]') });
            
            // ซ่อนอัตโนมัติหลัง 3 วินาที
            setTimeout(() => {
                notif.classList.add('animate-fade-out');
                setTimeout(() => notif.remove(), 300);
            }, 500);
        }

 
        // ============================================
        // อัปเดตข้อมูลแบบเรียลไทม์
        // ============================================
        async function realtimeUpdate() {
            if (!navigator.onLine || isUpdating) return;
            
            isUpdating = true;
            try {
                const res = await fetch(`${CONFIG.SCRIPT_URL}?action=getData&t=${Date.now()}`);
                const newData = await res.json();
                
                // ✅ แก้ไข: ลบการตรวจสอบ timestamp ออก (เซิร์ฟเวอร์ไม่ได้ส่งมา)
                if (!newData.buildings || !newData.signs) { // ← ลบ newData.timestamp ||
                    console.warn('ข้อมูลจากเซิร์ฟเวอร์ไม่สมบูรณ์');
                    return;
                }
                
                // ตรวจสอบการเปลี่ยนแปลง
                const buildingChanges = detectChanges(allBuildings, newData.buildings);
                const signChanges = detectChanges(allSigns, newData.signs);
                
                // อัปเดตแผนที่และตาราง
                if (buildingChanges.total > 0) {
                    applyChanges(buildingChanges, 'building');
                    showUpdateNotification(buildingChanges, 'สิ่งปลูกสร้าง');
                }
                
                if (signChanges.total > 0) {
                    applyChanges(signChanges, 'sign');
                    showUpdateNotification(signChanges, 'ป้าย');
                }
                
                // อัปเดตข้อมูลแคช
                allBuildings = newData.buildings;
                allSigns = newData.signs;
                
                console.log('✅ อัปเดตข้อมูลเรียลไทม์สำเร็จ');
            } catch (err) {
                console.error('❌ ข้อผิดพลาดในการอัปเดต:', err);
            } finally {
                isUpdating = false;
            }
        }

        // ตรวจจับการเปลี่ยนแปลง
        function detectChanges(oldData, newData) {
            const oldMap = new Map(oldData.map(item => [item.id || item._row_num, item]));
            const newMap = new Map(newData.map(item => [item.id || item._row_num, item]));
            
            const added = [];
            const updated = [];
            const deleted = [];
            
            // หาข้อมูลที่เพิ่มใหม่
            newData.forEach(item => {
                const id = item.id || item._row_num;
                if (!oldMap.has(id)) added.push(item);
            });
            
            // หาข้อมูลที่อัปเดต
            newData.forEach(item => {
                const id = item.id || item._row_num;
                const oldItem = oldMap.get(id);
                if (oldItem && JSON.stringify(oldItem) !== JSON.stringify(item)) {
                    updated.push(item);
                }
            });
            
            // หาข้อมูลที่ถูกลบ
            oldData.forEach(item => {
                const id = item.id || item._row_num;
                if (!newMap.has(id)) deleted.push(item);
            });
            
            return { 
                added, 
                updated, 
                deleted,
                total: added.length + updated.length + deleted.length
            };
        }

        // ประยุกต์การเปลี่ยนแปลง
        function applyChanges(changes, type) {
            // ลบมาร์กเกอร์ที่ถูกลบ
            changes.deleted.forEach(item => {
                surveyLayers.eachLayer(layer => {
                    if (layer._popupData && 
                        (layer._popupData.id === item.id || layer._popupData._row_num === item._row_num)) {
                        surveyLayers.removeLayer(layer);
                    }
                });
            });
            
            // อัปเดตหรือเพิ่มมาร์กเกอร์ใหม่
            [...changes.added, ...changes.updated].forEach(item => {
                if (!item.lat_long) return;
                
                const coords = item.lat_long.split(',').map(Number);
                if (coords.length < 2 || isNaN(coords[0]) || isNaN(coords[1])) return;
                
                // ค้นหามาร์กเกอร์ที่มีอยู่
                let existingMarker = null;
                surveyLayers.eachLayer(layer => {
                    if (layer._popupData && 
                        (layer._popupData.id === item.id || layer._popupData._row_num === item._row_num)) {
                        existingMarker = layer;
                    }
                });
                
                if (existingMarker) {
                    // อัปเดตมาร์กเกอร์ที่มีอยู่
                    existingMarker.setLatLng(L.latLng(coords[0], coords[1]));
                    existingMarker._popupData = item;
                    setupMarkerPopup(existingMarker, item, type);
                } else {
                    // เพิ่มมาร์กเกอร์ใหม่
                    const marker = createCircleMarker(L.latLng(coords[0], coords[1]), type, isEditMode);
                    marker._popupData = item;
                    setupMarkerPopup(marker, item, type);
                    marker.addTo(surveyLayers);
                    if (isEditMode) enableMarkerDragging(marker, item);
                }
            });
            
            // อัปเดตตาราง
            if (type === 'building') renderBuildingTable();
            else renderSignTable();
        }

        // แสดงการแจ้งเตือน
        function showUpdateNotification(changes, typeName) {
            if (changes.total === 0) return;
            
            let message = `🔄 มีการอัปเดต${typeName} `;
            const parts = [];
            if (changes.added.length > 0) parts.push(`เพิ่ม ${changes.added.length}`);
            if (changes.updated.length > 0) parts.push(`แก้ไข ${changes.updated.length}`);
            if (changes.deleted.length > 0) parts.push(`ลบ ${changes.deleted.length}`);
            
            message += parts.join(', ');
            showNotificationLeft(message, 'info');
        }

        // ============================================
        // เริ่มระบบอัปเดตอัตโนมัติ
        // ============================================
        function startRealtimeAutoUpdate() {
            if (autoUpdateInterval) clearInterval(autoUpdateInterval);
            
            autoUpdateInterval = setInterval(() => {
                if (!isUpdating && navigator.onLine) {
                    realtimeUpdate();
                }
            }, 5000); // 5 วินาที
            
            console.log('✅ เริ่มระบบอัปเดตเรียลไทม์ทุก 5 วินาที');
        }

        // ============================================
















        // ประยุกต์การเปลี่ยนแปลงเฉพาะจุด
        async function applyDeltaUpdates(records, type) {
            for (const record of records) {
                const id = record.id || record._row_num;
                
                // ค้นหามาร์กเกอร์ที่มีอยู่
                let existingMarker = null;
                surveyLayers.eachLayer(layer => {
                    if (layer._popupData && (layer._popupData.id === id || layer._popupData._row_num === id)) {
                        existingMarker = layer;
                    }
                });
                
                if (existingMarker) {
                    // ✅ อัปเดตมาร์กเกอร์ที่มีอยู่ (ไม่ลบรีโหลดใหม่ทั้งหมด)
                    existingMarker._popupData = { ...existingMarker._popupData, ...record };
                    setupMarkerPopup(existingMarker, existingMarker._popupData, type);
                    
                    // อัปเดตพิกัดถ้ามีการเปลี่ยนแปลง
                    if (record.lat_long && record.lat_long !== existingMarker._popupData.lat_long) {
                        const coords = record.lat_long.split(',').map(Number);
                        existingMarker.setLatLng(L.latLng(coords[0], coords[1]));
                    }
                } else {
                    // ✅ เพิ่มมาร์กเกอร์ใหม่
                    if (record.lat_long) {
                        const coords = record.lat_long.split(',').map(Number);
                        const marker = createCircleMarker(L.latLng(coords[0], coords[1]), type, isEditMode);
                        marker._popupData = record;
                        setupMarkerPopup(marker, record, type);
                        marker.addTo(surveyLayers);
                        if (isEditMode) enableMarkerDragging(marker, record);
                    }
                }
            }
            
            // อัปเดตตารางข้อมูล
            if (type === 'building') {
                allBuildings = [...allBuildings.filter(b => !records.some(r => r.id === b.id)), ...records];
                renderBuildingTable();
            } else {
                allSigns = [...allSigns.filter(s => !records.some(r => r.id === s.id)), ...records];
                renderSignTable();
            }
        }

        // ลบมาร์กเกอร์ที่ถูกลบ
        function removeDeletedMarkers(deletedIds) {
            surveyLayers.eachLayer(layer => {
                if (layer._popupData && deletedIds.includes(layer._popupData.id || layer._popupData._row_num)) {
                    surveyLayers.removeLayer(layer);
                }
            });
            
            // อัปเดตตาราง
            allBuildings = allBuildings.filter(b => !deletedIds.includes(b.id));
            allSigns = allSigns.filter(s => !deletedIds.includes(s.id));
            renderBuildingTable();
            renderSignTable();
        }

        // อัปเดตเฉพาะมาร์กเกอร์ที่เปลี่ยนแปลง
        async function updateChangedMarkers(data) {
            const currentMarkers = {};
            
            // เก็บข้อมูลมาร์กเกอร์ปัจจุบัน
            surveyLayers.eachLayer(layer => {
                if (layer._popupData && layer._popupData.id) {
                    currentMarkers[layer._popupData.id] = layer;
                }
            });
            
            // ล้างมาร์กเกอร์ทั้งหมด
            surveyLayers.clearLayers();
            
            // สร้างมาร์กเกอร์ใหม่จากข้อมูล
            const allData = [...(data.buildings || []), ...(data.signs || [])];
            
            for (const item of allData) {
                if (!item.lat_long) continue;
                
                const coords = item.lat_long.split(',').map(Number);
                if (coords.length < 2 || isNaN(coords[0]) || isNaN(coords[1])) continue;
                
                const type = item.building_c ? 'building' : 'sign';
                const latLng = L.latLng(coords[0], coords[1]);
                
                // ตรวจสอบว่ามีมาร์กเกอร์เดิมหรือไม่
                const existingMarker = currentMarkers[item.id];
                
                if (existingMarker) {
                    // อัปเดตข้อมูลในมาร์กเกอร์เดิม
                    existingMarker.setLatLng(latLng);
                    existingMarker._popupData = item;
                    setupMarkerPopup(existingMarker, item, type);
                    existingMarker.addTo(surveyLayers);
                    
                    if (isEditMode) enableMarkerDragging(existingMarker, item);
                } else {
                    // สร้างมาร์กเกอร์ใหม่
                    const m = createCircleMarker(latLng, type, isEditMode);
                    setupMarkerPopup(m, item, type);
                    m.addTo(surveyLayers);
                    
                    if (isEditMode) enableMarkerDragging(m, item);
                }
            }
        }






        // ในฟังก์ชัน realtimeUpdate() หลังจากอัปเดตสำเร็จ
        if (delta.buildings?.length > 0 || delta.signs?.length > 0 || delta.deleted?.length > 0) {
            const count = (delta.buildings?.length || 0) + (delta.signs?.length || 0) + (delta.deleted?.length || 0);
            showNotificationLeft(`🔄 มีการอัปเดตข้อมูล ${count} รายการจากผู้ใช้อื่น`, 'info');
        }


        // ใช้ MarkerCluster สำหรับมาร์กเกอร์จำนวนมาก
        let markerCluster = null;

        function initMarkerClustering() {
            // สร้าง MarkerCluster Group
            markerCluster = L.markerClusterGroup({
                maxClusterRadius: 80, // ระยะห่างที่จะรวมเป็นคลัสเตอร์
                disableClusteringAtZoom: 16, // ปิดคลัสเตอร์เมื่อซูมใกล้
                chunkedLoading: true, // โหลดแบบแบ่งชิ้นส่วน
                chunkInterval: 200, // เวลาในการโหลดแต่ละชิ้น (มิลลิวินาที)
                chunkDelay: 50 // ดีเลย์ระหว่างการโหลด
            });
            
            // เพิ่มมาร์กเกอร์ลงในคลัสเตอร์แทนการเพิ่มลงแผนที่โดยตรง
            markerCluster.addTo(map);
        }

        // เมื่อสร้างมาร์กเกอร์ใหม่
        function createCircleMarker(latlng, type, isDraggable = false) {
            const className = type === 'building' ? 'circle-building' : 'circle-sign';
            const icon = L.divIcon({
                className: `circle-marker ${className}`,
                iconSize: [14, 14],
                iconAnchor: [7, 7]
            });
            const marker = L.marker(latlng, {
                icon: icon,
                draggable: isDraggable, // ✅ ตั้งค่าให้ลากได้
                zIndexOffset: 1000
            });
            
            // เก็บข้อมูลไว้ในมาร์กเกอร์
            marker._popupData = null;
            
            return marker;
        }

        // ฟังก์ชันโหลดมาร์กเกอร์เฉพาะที่มองเห็น + buffer
        function loadVisibleMarkers() {
            // เก็บจุดชั่วคราวทั้งหมดก่อนล้าง
            const pendingMarkers = [];
            if (markerCluster) {
                markerCluster.eachLayer(layer => {
                    if (layer._popupData) {
                        if (layer._popupData.queued || layer._popupData.tempMarker) {
                            pendingMarkers.push({
                                latlng: layer.getLatLng(),
                                data: layer._popupData,
                                type: layer._popupData.type
                            });
                        }
                    }
                });
            } else {
                surveyLayers.eachLayer(layer => {
                    if (layer._popupData) {
                        if (layer._popupData.queued || layer._popupData.tempMarker) {
                            pendingMarkers.push({
                                latlng: layer.getLatLng(),
                                data: layer._popupData,
                                type: layer._popupData.type
                            });
                        }
                    }
                });
            }
            
            const bounds = map.getBounds();
            const bufferRatio = isMobile() ? 0.5 : 1.0;
            const bufferedBounds = bounds.pad(bufferRatio);
            
            // ล้างมาร์กเกอร์ทั้งหมด
            if (markerCluster) {
                markerCluster.clearLayers();
            } else {
                surveyLayers.clearLayers();
            }
            
            // โหลดเฉพาะมาร์กเกอร์ที่อยู่ในขอบเขต + buffer
            allBuildings.forEach(r => {
                if (!r.lat_long) return;
                const coords = r.lat_long.split(',').map(Number);
                if (coords.length < 2 || isNaN(coords[0]) || isNaN(coords[1])) return;
                const latLng = L.latLng(coords[0], coords[1]);
                if (!bufferedBounds.contains(latLng)) return;
                
                // ✅ ตรวจสอบว่าจุดนี้กำลังถูกย้ายหรือไม่
                const recordKey = r._row_num || r.id;
                if (markersBeingMoved.has(recordKey)) {
                    return; // ข้ามการสร้างจุดจริง
                }
                
                const m = createCircleMarker(latLng, 'building', isEditMode);
                setupMarkerPopup(m, r, 'building');
                if (isEditMode) enableMarkerDragging(m, r);
                if (markerCluster) {
                    markerCluster.addLayer(m);
                } else {
                    m.addTo(surveyLayers);
                }
            });
            
            allSigns.forEach(r => {
                if (!r.lat_long) return;
                const coords = r.lat_long.split(',').map(Number);
                if (coords.length < 2 || isNaN(coords[0]) || isNaN(coords[1])) return;
                const latLng = L.latLng(coords[0], coords[1]);
                if (!bufferedBounds.contains(latLng)) return;
                
                // ✅ ตรวจสอบว่าจุดนี้กำลังถูกย้ายหรือไม่
                const recordKey = r._row_num || r.id; // ✅ เพิ่มบรรทัดนี้
                if (markersBeingMoved.has(recordKey)) { // ✅ แก้เป็น recordKey
                    return;
                }
                
                const m = createCircleMarker(latLng, 'sign', isEditMode);
                setupMarkerPopup(m, r, 'sign');
                if (isEditMode) enableMarkerDragging(m, r);
                if (markerCluster) {
                    markerCluster.addLayer(m);
                } else {
                    m.addTo(surveyLayers);
                }
            });
            
            // เพิ่มจุดชั่วคราวกลับเข้ามา
            pendingMarkers.forEach(marker => {
                const m = createCircleMarker(marker.latlng, marker.type, isEditMode);
                m._popupData = marker.data;
                setupMarkerPopup(m, marker.data, marker.type);
                if (markerCluster) {
                    markerCluster.addLayer(m);
                } else {
                    m.addTo(surveyLayers);
                }
                if (isEditMode) enableMarkerDragging(m, marker.data);
            });
        }

        // เรียกใช้เมื่อเลื่อนหรือซูมแผนที่
        map.on('moveend', loadVisibleMarkers);
        map.on('zoomend', loadVisibleMarkers);

        // ============================================
        // 1. แก้ไขฟังก์ชัน refreshData (ใช้ระบบใหม่)
        // ============================================
        function refreshData() {
            const refreshBtn = document.getElementById('btn-refresh');
            const refreshIcon = document.getElementById('refresh-icon');
            
            disableRefreshButton();
            refreshIcon.classList.add('animate-spin');
            
            // ✅ เปลี่ยนจาก smartLoadData() เป็น loadExistingData()
            loadExistingData().finally(() => {
                setTimeout(() => {
                    refreshIcon.classList.remove('animate-spin');
                    enableRefreshButton();
                }, 500);
            });
        }

        // ============================================
        // 2. วาง beforeunload ที่ระดับบนสุด (นอก window.load)
        // ============================================
        window.addEventListener('beforeunload', () => {
            stopRealtimeAutoUpdate(); // ✅ หยุดระบบใหม่
        });

        // ============================================
        // 3. เริ่มต้นแอป (วางด้านล่าง beforeunload)
        // ============================================
        window.addEventListener('load', async () => {
            initMap();
            lucide.createIcons();
            
            // ✅ เพิ่ม await และเริ่มระบบอัปเดต
            await loadExistingData(); // ← เพิ่ม await
            startRealtimeAutoUpdate(); // ← เพิ่มบรรทัดนี้ (สำคัญที่สุด!)
            
            await checkAndSyncOnStartup();
            setInterval(updateSyncBadge, 1000);
            
            // ลงทะเบียน Service Worker
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => console.log('Service Worker registered:', registration.scope))
                    .catch(error => console.log('Service Worker registration failed:', error));
            }
        });
    </script>
</body>

</html>
