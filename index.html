
<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="โนนไทย">

    <meta name="theme-color" content="#2563eb">
    <title>โนนไทย</title>
    <link rel="manifest" href="manifest.json">
    <link rel="icon" href="static/icons/lb.ico" type="image/x-icon"> <!-- แก้เป็นพาธสัมพัทธ์ -->
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <!-- เพิ่มในส่วน <head> ของไฟล์ HTML -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <!-- GeoPackage JS Library (สำหรับอ่านไฟล์ .gpkg) -->
    <script src="https://unpkg.com/@ngageoint/geopackage@4.1.0/dist/geopackage.min.js"></script>
    <!-- Leaflet GeoJSON Layer (สำหรับแสดงข้อมูลจาก GeoPackage) -->
    <script src="https://unpkg.com/leaflet.vectorgrid@1.3.0/dist/Leaflet.VectorGrid.bundled.js"></script>
    <style>
        body, html { height: 100%; margin: 0; padding: 0; overflow: hidden; font-family: sans-serif; }
        #map { height: 100vh; width: 100vw; z-index: 0; }
        
        /* ข้อ 1: ปรับแต่งเป้าเล็งใหม่ (ใหญ่ขึ้น 20%, หนาขึ้น, สูงขึ้น 15%) */
        .crosshair {
            position: absolute;
            top: 35%; /* สูงขึ้นจากกึ่งกลาง (50% - 15%) */
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 1000;
        }
        .crosshair-center {
            width: 6px; height: 6px;
            background-color: #ef4444;
            border-radius: 50%;
            position: absolute;
            top: 50%; left: 50%; transform: translate(-50%, -50%);
        }
        .crosshair-circle {
            width: 60px; height: 60px; /* ใหญ่ขึ้นจาก 50px */
            border: 3px solid rgba(239, 68, 68, 0.9); /* เส้นหนาขึ้น */
            border-radius: 50%;
            position: relative;
        }
        .crosshair-line { position: absolute; background-color: rgba(239, 68, 68, 0.9); }
        .line-v { width: 3px; height: 18px; left: 50%; transform: translateX(-50%); }
        .line-h { height: 3px; width: 18px; top: 50%; transform: translateY(-50%); }
        .v-top { top: -20px; } .v-bottom { bottom: -20px; }
        .h-left { left: -20px; } .h-right { right: -20px; }

        /* สไตล์พิเศษสำหรับสีพื้นหลังช่องกรอกตามเงื่อนไข */
        .bg-custom-green { 
            background-color: rgba(187, 247, 208, 0.9) !important; 
        }
        .bg-custom-pink { 
            background-color: rgba(255, 249, 196, 0.9) !important; 
        }
        .bg-custom-check-status { 
            background-color: rgba(187, 247, 208, 0.9) !important; 
            font-weight: bold;
        }

        /* สไตล์สำหรับฟิลด์ที่อ่านอย่างเดียว */
        .form-input[readonly] {
            background-color: rgba(187, 247, 208, 0.9) !important;
            cursor: not-allowed !important;
            opacity: 0.85;
            border-color: #9ca3af !important;
        }
        .form-input[readonly]:hover {
            border-color: #6b7280 !important;
        }

        /* สีเขียวสำหรับกลุ่มแรก */
        .form-input.green-bg {
            background-color: rgba(187, 247, 208, 0.9) !important;
        }

        /* สีชมพูอ่อนสำหรับกลุ่มสอง */
        .form-input.pink-bg {
            background-color: rgba(255, 204, 204, 0.3) !important; /* ชมพูอ่อน */
        }

        /* สีเขียวสำหรับช่อง "สถานะการตรวจสอบ" */
        .form-input.check-status {
            background-color: rgba(187, 247, 208, 0.9) !important;
            font-weight: bold;
        }

        /* แก้ไขสีพื้นหลังสถานะ "ถ่ายรูปแล้ว" */
        .status-ถ่ายรูปแล้ว { 
            background: rgba(187, 247, 208, 0.9) !important; 
            color: #065f46; 
        }

        /* แก้ไขส่วน .side-panel ให้โปร่งใส */
        .side-panel { 
            transition: transform 0.3s ease-in-out; 
            transform: translateX(100%); 
            background: rgba(200, 200, 200, 1.0); /* โปร่งใส 95% */            
            z-index: 1010;
            box-shadow: -5px 0 25px rgba(0,0,0,0.15); /* เงาให้ดูดีขึ้น */
        }
        .form-label { 
            font-size: 0.85rem; /* ขนาดใหญ่ขึ้น */
            font-weight: 700; 
            color: #dc2626; /* สีแดง */
            margin-bottom: 0.2rem; /* เพิ่มระยะห่าง */
            display: block;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.8); /* เงาสีขาว */
        }
        .form-input { 
            width: 100%; 
            padding: 0.5rem 0.75rem; /* เพิ่ม padding */
            font-size: 0.9rem; /* ขนาดตัวหนังสือใหญ่ขึ้น */
            font-weight: 600; /* ตัวหนา */
            color: #2563eb; /* สีน้ำเงิน */
            background-color: rgba(255, 255, 255, 0.6); /* พื้นหลังโปร่งใส */
            border: 1.5px solid #d1d5db; /* เส้นหนาขึ้น */
            border-radius: 0.5rem; 
            outline: none;
            transition: border-color 0.2s ease;
        }
        .form-input:focus {
            border-color: #2563eb;
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2); /* เงาชัดเจนขึ้น */
        }
        .form-input::placeholder {
            color: #9ca3af; /* สีเทาอ่อนสำหรับ placeholder */
            font-style: italic;
        }
        .side-panel.open { transform: translateX(0); }
        
        .map-btn { background: white; border-radius: 10px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        .active-tool { background-color: #2563eb !important; color: white !important; border: 2px solid white; }
        .active-edit { background-color: #2563eb !important; color: white !important; border: 2px solid white !important; }

        /* ข้อ 2: ปุ่มยืนยันเหนือปุ่มบวก (ระยะห่าง = เส้นผ่าศูนย์กลางปุ่มบวก 70px) */
        .confirm-btn-overlay {
        position: absolute;
        bottom: calc(2.5rem + 4.375rem + 4.375rem); /* bottom-10 (40px) + ความสูงปุ่ม (70px) + ระยะห่าง (70px) */
        left: 50%;
        transform: translateX(-50%);
        z-index: 1005;
        }
        /* สไตล์สำหรับเมนูฟันเฟือง */
        #settings-menu button {
          opacity: 0;
          transform: translateY(-20px);
          transition: all 0.3s ease;
        }

        #settings-menu button:hover {
          transform: translateY(0) scale(1.05) !important;
        }
        /* ============================================
           ซ่อนลูกศรขึ้นลงในช่องกรอกตัวเลขในแผงข้อมูล (เพื่อป้องกันการเปลี่ยนค่าโดยไม่ตั้งใจเมื่อหมุนสกอร์ล)
           ============================================ */
        #side-panel input[type="number"]::-webkit-inner-spin-button,
        #side-panel input[type="number"]::-webkit-outer-spin-button {
          -webkit-appearance: none !important;
          margin: 0 !important;
        }

        #side-panel input[type="number"] {
          -moz-appearance: textfield !important; /* Firefox */
          appearance: textfield !important; /* Standard */
        }

        /* ============================================
        ซ่อนลูกศรขึ้นลงในช่องกรอกตัวเลขในหน้าต่างคำนวณพื้นที่
        ============================================ */
        #calc-width::-webkit-inner-spin-button,
        #calc-width::-webkit-outer-spin-button,
        #calc-length::-webkit-inner-spin-button,
        #calc-length::-webkit-outer-spin-button,
        #calc-result::-webkit-inner-spin-button,
        #calc-result::-webkit-outer-spin-button {
          -webkit-appearance: none !important;
          margin: 0 !important;
        }

        #calc-width,
        #calc-length,
        #calc-result {
          -moz-appearance: textfield !important;
          appearance: textfield !important;
        }

        /* ========== แอนิเมชันเลื่อนขึ้น/ลง + ศูนย์กลางสำหรับเป้าเล็งและปุ่มบวก ========== */
        #crosshair {
          transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275),
                      opacity 0.6s ease;
          transform: translate(-50%, -50%) translateY(100vh); /* รวมศูนย์กลาง + เลื่อนจากล่าง */
          opacity: 0;
          will-change: transform, opacity;
        }
        #crosshair.visible {
          transform: translate(-50%, -50%) translateY(0); /* ศูนย์กลาง + ตำแหน่งปกติ */
          opacity: 1;
        }

        #add-trigger-container {
          transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275),
                      opacity 0.6s ease;
          transform: translateX(-50%) translateY(100vh); /* รวมศูนย์กลาง + เลื่อนจากล่าง */
          opacity: 0;
          will-change: transform, opacity;
        }
        #add-trigger-container.visible {
          transform: translateX(-50%) translateY(0); /* ศูนย์กลาง + ตำแหน่งปกติ */
          opacity: 1;
        }
        /* เพิ่มการเร่งฮาร์ดแวร์สำหรับแผนที่ */
        #map {
          transform: translate3d(0, 0, 0);
          will-change: transform;
        }

        /* ปิดการเรนเดอร์ชั่วคราวเมื่อเลื่อนแผนที่ (เพิ่มความลื่น) */
        .leaflet-zoom-anim .circle-marker,
        .leaflet-zoom-anim .crosshair {
          display: none !important;
        }
        /* ============================================
           ปรับแต่งสำหรับมือถือ (รวมทุกกฎไว้ในบล็อกเดียว)
           ============================================ */
        @media (max-width: 768px) {
            /* ความเร็วแอนิเมชัน */
            #crosshair,
            #add-trigger-container {
                transition-duration: 0.35s;
            }
            
            /* ขนาดตัวอักษรและพื้นที่ในช่องกรอก */
            .side-panel .form-input {
                font-size: 0.8125rem !important; /* 13px */
                padding: 0.4rem 0.6rem !important;
            }
            
            /* ปรับขนาดเลเบลให้สมดุล */
            .side-panel .form-label {
                font-size: 0.8125rem !important;
                margin-bottom: 0.2rem !important;
            }
            
            /* ปรับขนาดปุ่มกล้อง */
            .side-panel button[onclick*="camera"] {
                padding: 0.5rem !important;
                font-size: 0.75rem !important;
            }
        }
        /* แอนิเมชันสำหรับปุ่มฟันเฟือง */
        @keyframes spin {
          from { transform: rotate(0deg); }
          to { transform: rotate(360deg); }
        }
        .animate-spin {
          animation: spin 0.5s linear;
        }

        /* สไตล์สำหรับแกลเลอรี่รูปภาพ */
        #image-gallery-modal {
        }

        #gallery-grid::-webkit-scrollbar {
          width: 8px;
        }

        #gallery-grid::-webkit-scrollbar-track {
          background: #1f2937;
        }

        #gallery-grid::-webkit-scrollbar-thumb {
          background: #4b5563;
          border-radius: 4px;
        }

        #gallery-grid::-webkit-scrollbar-thumb:hover {
          background: #6b7280;
        }
        /* แอนิเมชันสำหรับ Modal */
        @keyframes scale-in {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }
        @keyframes scale-out {
            from { opacity: 1; transform: scale(1); }
            to { opacity: 0; transform: scale(0.9); }
        }
        .animate-scale-in { animation: scale-in 0.2s ease-out; }
        .animate-scale-out { animation: scale-out 0.2s ease-in; }

        /* แอนิเมชันสำหรับแจ้งเตือน */
        @keyframes fade-in {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes fade-out {
            from { opacity: 1; transform: translateY(0); }
            to { opacity: 0; transform: translateY(-20px); }
        }
        .animate-fade-in { animation: fade-in 0.3s ease-out; }
        .animate-fade-out { animation: fade-out 0.3s ease-in; }
        /* สถานะปุ่มรีโหลด */
        @keyframes flash-green {
            0%, 100% { background-color: white; }
            50% { background-color: #22c55e; color: white; }
        }
        .refresh-success { animation: flash-green 0.5s ease 3; }

        /* แอนิเมชันสำหรับแจ้งเตือน */
        @keyframes fade-in {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes fade-out {
            from { opacity: 1; transform: translateY(0); }
            to { opacity: 0; transform: translateY(-20px); }
        }
        .animate-fade-in { animation: fade-in 0.3s ease-out; }
        .animate-fade-out { animation: fade-out 0.3s ease-in; }

        .circle-marker {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            border: 2px solid white;
            cursor: pointer;
        }
        .circle-building { background-color: #f97316; }
        .circle-sign { background-color: #22c55e; }
        
        .user-location-dot {
            width: 14px; height: 14px;
            background-color: #2563eb;
            border: 2px solid white;
            border-radius: 50%;
        }
        
        /* สไตล์สำหรับตาราง */
        .data-table-panel {
            position: fixed;
            bottom: 5px;
            left: 5px;
            width: 90%;
            max-width: 900px;
            max-height: 45vh; /* ✅ เปลี่ยนจาก 60vh เป็น 47vh */
            height: 45vh; /* ✅ เพิ่มบรรทัดนี้เพื่อให้ความสูงคงที่ 47% */
            background: white;
            border-radius: 6px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            z-index: 1003;
            display: none;
            flex-direction: column;
            overflow: hidden;
            transform: translateY(100%);
            transition: transform 0.3s ease;
        }
        .data-table-panel.open {
            display: flex;
            transform: translateY(0);
        }
        .data-table-panel.open {
            display: flex;
            transform: translateY(0);
        }
        .table-header {
            background: linear-gradient(135deg, #667eea 0%, #db2777 100%);
            color: white;
            padding: 0.1rem 0.5rem;
            min-height: 20px;       /* กำหนดความสูงต่ำสุดให้เล็กลง */
            height: 44px;  
            gap: 0.25rem;    
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .table-tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }
        .table-tab {
            padding: 6px 6px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s;
        }
        .table-tab.active {
            background: white;
            color: #667eea;
        }
        .table-tab:hover:not(.active) {
            background: rgba(255,255,255,0.2);
        }
        .table-content {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }
        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }
        .data-table th {
            background: #f3f4f6;
            padding: 6px 8px;
            text-align: left;
            font-weight: 700;
            color: #374151;
            border-bottom: 2px solid #e5e7eb;
            position: sticky;
            top: 0;
            z-index: 1;
        }
        .data-table td {
            padding: 4px;
            border-bottom: 1px solid #e5e7eb;
            vertical-align: middle;
        }
        .data-table tr:hover {
            background: #f9fafb;
        }
        .data-table tr:nth-child(even) {
            background: #f9fafb;
        }
        /* แก้ไข: บังคับให้คลาส text-center ทำงานได้ */
        .data-table th.text-center,
        .data-table td.text-center {
            text-align: center !important; /* ✅ ใช้ !important เพื่อทับกฎเดิม */
        }
        .status-badge {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
        }
        .status-ยังไม่สำรวจ { background: #fef3c7; color: #92400e; }
        .status-ถ่ายรูปแล้ว { background: #d1fae5; color: #065f46; }
        .status-ตรวจสอบแล้ว { background: #fee2e2; color: #991b1b; }
        .zoom-btn {
            padding: 4px 10px;
            background: #2563eb;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 600;
            transition: all 0.2s;
        }
        .zoom-btn:hover {
            background: #1d4ed8;
            transform: scale(1.05);
        }
        .marker-icon {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid white;
        }
        .marker-building { background-color: #f97316; }
        .marker-sign { background-color: #22c55e; }
    </style>
</head>
<!-- Custom Modal Dialogs -->
<!-- Modal ยืนยันการลบ -->
<div id="confirm-delete-modal" class="fixed inset-0 bg-black/50 backdrop-blur-sm z-[2000] hidden items-center justify-center p-4">
    <div class="bg-white rounded-2xl shadow-2xl max-w-md w-full animate-scale-in">
        <div class="p-6">
            <div class="flex items-center justify-center w-16 h-16 bg-red-100 rounded-full mx-auto mb-4">
                <i data-lucide="trash-2" class="w-8 h-8 text-red-600"></i>
            </div>
            <h3 id="delete-modal-title" class="text-xl font-bold text-center text-gray-900 mb-2">ยืนยันการลบ</h3>
            <p id="delete-modal-message" class="text-center text-gray-600 mb-6">คุณแน่ใจว่าต้องการลบสิ่งปลูกสร้างนี้?</p>
            
            <div class="flex gap-3">
                <button onclick="cancelDelete()" class="flex-1 py-3 px-6 bg-gray-200 text-gray-700 rounded-lg font-semibold hover:bg-gray-300 transition-all active:scale-95">
                    ยกเลิก
                </button>
                <button onclick="confirmDeleteAction()" class="flex-1 py-3 px-6 bg-red-600 text-white rounded-lg font-semibold hover:bg-red-700 transition-all active:scale-95 flex items-center justify-center gap-2">
                    <i data-lucide="trash-2" class="w-4 h-4"></i>
                    ลบ
                </button>
            </div>
        </div>
    </div>
</div>
<!-- Modal โหมดแก้ไข -->
<div id="edit-mode-modal" class="fixed inset-0 bg-black/30 backdrop-blur-sm z-[2000] hidden items-center justify-center p-4">
    <div class="bg-white rounded-2xl shadow-2xl max-w-md w-full animate-scale-in">
        <div class="p-6">
            <div class="flex items-center justify-center w-16 h-16 bg-blue-100 rounded-full mx-auto mb-4">
                <i data-lucide="move" class="w-8 h-8 text-blue-600"></i>
            </div>
            <h3 class="text-xl font-bold text-center text-gray-900 mb-2">โหมดแก้ไขตำแหน่ง</h3>
            <p class="text-center text-gray-600 mb-6">คลิกและลากหมุดเพื่อย้ายตำแหน่ง</p>
            
            <div class="flex justify-center">
                <button onclick="closeEditModeModal()" class="py-3 px-8 bg-blue-600 text-white rounded-lg font-semibold hover:bg-blue-700 transition-all active:scale-95">
                    ตกลง
                </button>
            </div>
        </div>
    </div>
</div>
<body class="bg-gray-100">

    <div id="map"></div>

    <!-- เป้าเล็ง -->
    <div id="crosshair" class="crosshair hidden">
        <div class="crosshair-circle">
            <div class="crosshair-line line-v v-top"></div>
            <div class="crosshair-line line-v v-bottom"></div>
            <div class="crosshair-line line-h h-left"></div>
            <div class="crosshair-line line-h h-right"></div>
        </div>
        <div class="crosshair-center"></div>
    </div>

    <!-- ปุ่มคอนเฟิร์ม (ข้อ 2) -->
    <div id="confirm-overlay" class="confirm-btn-overlay hidden">
        <button id="btn-confirm-action" onclick="confirmCapture()" class="flex items-center gap-2 px-6 py-4 rounded-full text-white font-bold shadow-2xl active:scale-95 transition-all text-lg border-4 border-white">
            <i data-lucide="check-circle" class="w-6 h-6"></i>
            <span id="confirm-text">ยืนยันการเพิ่มจุด</span>
        </button>
    </div>

        <!-- ปุ่มฟันเฟืองและรีเฟรช (ด้านบนซ้าย) -->
        <div class="absolute top-4 left-4 z-[1001]">
          <!-- ปุ่มฟันเฟือง (เมนูหลัก) -->
          <button id="btn-settings" onclick="toggleSettingsMenu()" class="map-btn p-3 text-gray-600 hover:text-blue-600 transition-all relative group mb-2">
            <i data-lucide="settings-2" id="settings-icon" class="w-6 h-6"></i>
            <!-- จุดแจ้งเตือน -->
            <span id="settings-badge" class="absolute top-0 right-0 w-2 h-2 bg-red-500 rounded-full hidden"></span>
          </button>
          
          <!-- ปุ่มรีเฟรช -->
          <button id="btn-refresh" onclick="refreshData()" class="map-btn p-3 text-blue-600 transition-all">
            <i data-lucide="refresh-cw" id="refresh-icon" class="w-6 h-6"></i>
          </button>
          
          <!-- ปุ่มย่อยที่เลื่อนลงมา -->
          <div id="settings-menu" class="mt-2 space-y-2 hidden">
            <!-- ปุ่ม 1: ดาวน์โหลดสิ่งปลูกสร้าง -->
            <button onclick="exportBuildingGeoJSON()" class="map-btn p-3 w-48 bg-gradient-to-r from-orange-400 to-orange-600 text-white hover:scale-105 transition-all shadow-lg flex items-center justify-start gap-2 text-left">
              <i data-lucide="home" class="w-5 h-5"></i>
              <span class="text-xs font-bold">ดาวน์โหลดสิ่งปลูกสร้าง</span>
            </button>
            <!-- ปุ่ม 2: ดาวน์โหลดป้าย -->
            <button onclick="exportSignGeoJSON()" class="map-btn p-3 w-48 bg-gradient-to-r from-green-400 to-green-600 text-white hover:scale-105 transition-all shadow-lg flex items-center justify-start gap-2 text-left">
              <i data-lucide="map-pin" class="w-5 h-5"></i>
              <span class="text-xs font-bold">ดาวน์โหลดป้าย</span>
            </button>
            <!-- ปุ่ม 3: ดาวน์โหลดรูปสิ่งปลูกสร้าง -->
            <button onclick="loadBuildingImages()" class="map-btn p-3 w-48 bg-gradient-to-r from-blue-400 to-blue-600 text-white hover:scale-105 transition-all shadow-lg flex items-center justify-start gap-2 text-left">
              <i data-lucide="image" class="w-5 h-5"></i>
              <span class="text-xs font-bold">ดาวน์โหลดรูปสิ่งปลูกสร้าง</span>
            </button>
            <!-- ปุ่ม 4: ดาวน์โหลดรูปป้าย -->
            <button onclick="loadSignImages()" class="map-btn p-3 w-48 bg-gradient-to-r from-purple-400 to-purple-600 text-white hover:scale-105 transition-all shadow-lg flex items-center justify-start gap-2 text-left">
              <i data-lucide="gallery-horizontal" class="w-5 h-5"></i>
              <span class="text-xs font-bold">ดาวน์โหลดรูปป้าย</span>
            </button>
            <!-- ปุ่ม 5: อัปเดตแผนที่ (ใหม่!) -->
            <button onclick="manualUpdateMap()" class="map-btn p-3 w-48 bg-gradient-to-r from-yellow-400 to-yellow-600 text-white hover:scale-105 transition-all shadow-lg flex items-center justify-start gap-2 text-left">
                <i data-lucide="refresh-cw" class="w-5 h-5"></i>
                <span class="text-xs font-bold">อัปเดตแผนที่แปลง</span>
            </button>
          </div>
        </div>

    <!-- ปุ่มเลือกประเภทและแก้ไข -->
    <div class="absolute top-4 right-4 z-[1001] flex flex-row gap-2">
        <button id="btn-building" onclick="activateTool('building')" class="map-btn p-3" title="เพิ่มสิ่งปลูกสร้าง">
            <i data-lucide="home" class="w-6 h-6 text-orange-500"></i>
        </button>
        <button id="btn-sign" onclick="activateTool('sign')" class="map-btn p-3" title="เพิ่มป้าย">
            <i data-lucide="map-pin" class="w-6 h-6 text-green-500"></i>
        </button>
        <button id="btn-edit" onclick="toggleEditMode()" class="map-btn p-3" title="โหมดแก้ไขตำแหน่ง">
            <i data-lucide="move" class="w-6 h-6 text-red-600"></i>
        </button>
    </div>

    <!-- ปุ่มตำแหน่งปัจจุบัน -->
    <div class="absolute bottom-4 left-4 z-[1001]">
    <button onclick="locateUser()" class="map-btn p-3 shadow-lg border-2 border-blue-100">
    <div class="user-location-dot"></div>
    </button>
    </div>

    <!-- ปุ่มบวก (Add Trigger) -->
    <div id="add-trigger-container" class="absolute bottom-10 left-1/2 -translate-x-1/2 z-[1001] hidden">
        <button onclick="showConfirmButton()" class="p-4 bg-blue-600/50 text-white rounded-full shadow-xl border-[3px] border-white active:scale-90 transition-all">
            <i data-lucide="plus" class="w-8 h-8"></i>
        </button>
    </div>

    <!-- ปุ่มแสดงตาราง -->
    <div class="absolute bottom-4 right-4 z-[1002]">
        <button id="btn-show-table" onclick="toggleTable()" class="map-btn p-3 bg-white hover:bg-blue-50">
            <i data-lucide="table" id="table-icon" class="w-6 h-6 text-blue-600"></i>
        </button>
    </div>

    <!-- หน้าต่างตารางข้อมูล -->
    <div id="data-table-panel" class="data-table-panel">
        <div class="table-header">
            <div class="flex items-center gap-2">
                <div class="table-tabs">
                    <div class="table-tab active" onclick="switchTableTab('building')">
                        <span>สิ่งปลูกสร้าง</span>
                        <span id="building-count-badge" class="ml-2 px-2 py-0.5 bg-orange-400 text-white text-xs rounded-full font-medium">0</span>
                    </div>
                    <div class="table-tab" onclick="switchTableTab('sign')">
                        <span>ป้าย</span>
                        <span id="sign-count-badge" class="ml-2 px-2 py-0.5 bg-green-500 text-white text-xs rounded-full font-medium">0</span>
                    </div>
                </div>
            </div>
            <button onclick="toggleTable()" class="p-1.5 hover:bg-white/20 rounded-full">
                <i data-lucide="x" class="w-4 h-4"></i>
            </button>
        </div>
        <div class="table-content">
            <div id="building-table-container" class="table-tab-content">
                <table class="data-table" id="building-table">
                    <thead>
                        <tr>
                            <th style="width: 30px"><i data-lucide="map-pin" class="w-4 h-4"></i></th>
                            <th class="sortable-header" data-sort="building_c">รหัส</th>
                            <th class="sortable-header" data-sort="full_name">เจ้าของ</th>
                            <th class="text-center sortable-header" data-sort="hs_no">เลขที่</th>
                            <th class="text-center sortable-header" data-sort="hs_moo">หมู่</th>
                            <th class="sortable-header" data-sort="b_type">ประเภท</th>
                            <th class="text-center sortable-header" data-sort="b_mat">วัสดุ</th>
                            <th class="text-center sortable-header" data-sort="no_floor">ชั้น</th>
                            <th class="text-center sortable-header" data-sort="b_area">พื้นที่ทั้งหลัง (ตร.ม.)</th>
                            <th class="text-center sortable-header" data-sort="b_year">อายุ</th>
                            <th class="sortable-header" data-sort="b_note">รายละเอียด</th>
                            <th class="sortable-header" data-sort="b_use">ใช้ประโยชน์</th>
                            <th class="sortable-header" data-sort="b_use2">ใช้ประโยชน์ (2)</th>
                            <th class="sortable-header" data-sort="land_use">ใช้ประโยชน์ที่ดิน</th>
                            <th class="sortable-header" data-sort="check">ตรวจสอบ</th>
                            <th style="width: 60px">ซูม</th>
                        </tr>
                    </thead>
                    <tbody id="building-table-body">
                        <tr>
                            <td colspan="15" class="text-center py-8 text-gray-500">กำลังโหลดข้อมูล...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div id="sign-table-container" class="table-tab-content hidden">
                <table class="data-table" id="sign-table">
                    <thead>
                        <tr>
                            <th style="width: 30px"><i data-lucide="map-pin" class="w-4 h-4"></i></th>
                            <th class="sortable-header" data-sort="s_code">รหัส</th>
                            <th class="sortable-header" data-sort="s_characte">ลักษณะ</th>
                            <th class="text-center sortable-header" data-sort="s_wide">กว้าง (ซ.ม.)</th>
                            <th class="text-center sortable-header" data-sort="s_length">ยาว (ซ.ม.)</th>
                            <th class="text-center sortable-header" data-sort="no_side">จำนวนด้าน</th>
                            <th class="sortable-header" data-sort="s_text">ข้อความ</th>
                            <th class="sortable-header" data-sort="check">ตรวจสอบ</th>
                            <th style="width: 60px">ซูม</th>
                        </tr>
                    </thead>
                    <tbody id="sign-table-body">
                        <tr>
                            <td colspan="8" class="text-center py-8 text-gray-500">กำลังโหลดข้อมูล...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- องค์ประกอบแสดงรูปภาพ (มีขนาดและตำแหน่งเดียวกับตาราง) -->
    <div id="image-preview-container" class="data-table-panel" style="display: none; z-index: 1004; bottom: 5px; transform: translateY(0);">
        <div class="table-header" style="background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);">
            <div class="flex items-center justify-between w-full">
                <div class="flex items-center gap-2">
                    <h3 class="font-bold text-white text-sm">รูปภาพ</h3>
                </div>
                <!-- ✅ ปุ่มปิดหน้าต่างรูปภาพ -->
                <button onclick="hideImagePreview()" class="p-2 hover:bg-white/20 rounded-full transition">
                    <i data-lucide="x" class="w-5 h-5 text-white"></i>
                </button>
            </div>
        </div>
        <div class="table-content flex items-center justify-center p-4">
            <img id="image-preview" src="" alt="รูปภาพ" class="max-w-full max-h-full object-contain hidden">
            <div id="image-preview-placeholder" class="text-gray-300 text-sm">
                คลิกที่ชื่อรูปภาพในแผงข้อมูลเพื่อดูรูปใหญ่
            </div>
        </div>
    </div>

    <!-- หน้าต่างกรอกข้อมูล -->
    <div id="side-panel" class="side-panel fixed top-0 right-0 w-[44vw] sm:w-[280px] h-full z-[1002] shadow-2xl flex flex-col">
        <div class="p-4 border-b flex justify-between items-center bg-gray-50">
            <div>
                <h2 id="panel-title" class="font-bold text-blue-900">บันทึกข้อมูล</h2>
                <p id="latlng-display" class="text-[10px] text-gray-500 font-mono"></p>
            </div>
            <button onclick="closePanel()" class="p-2 hover:bg-gray-200 rounded-full"><i data-lucide="x" class="w-5 h-5"></i></button>
        </div>
        <form id="survey-form" class="flex-1 overflow-y-auto p-4 space-y-3"></form>
        <div class="p-4 bg-white border-t">
            <button type="button" onclick="saveSurveyData()" class="w-full bg-blue-600 text-white py-3 rounded-xl font-bold flex items-center justify-center gap-2">
                <i data-lucide="save" class="w-5 h-5"></i> บันทึก
            </button>
        </div>
    </div>

    <script>
        const CONFIG = {
            SCRIPT_URL: 'https://script.google.com/macros/s/AKfycbyFWpmT-X62o3H_leBlJ35qLJv3I57We_DzlvcmQLwm-NcIwLM3k-GFq_namGrG8zylMw/exec'
        };

    // ✅ ประกาศตัวแปร Global ทั้งหมดไว้ที่นี่ที่เดียว
        let map;
        let activeTool = null;
        let isEditMode = false;
        let surveyLayers = L.layerGroup();
        let editingMarker = null;
        let markersBeingMoved = new Set(); // ✅ เพิ่มบรรทัดนี้ - เก็บ rowKey ของจุดที่กำลังถูกย้าย
        // ตัวแปรสำหรับเก็บข้อมูลและ Cache
        let allBuildings = []; 
        let allSigns = [];   
        let movingMarkerId = null; // ✅ เก็บ ID ของจุดที่กำลังถูกลากอยู่  
        
        // ตัวแปรสำหรับระบบอัปเดตอัตโนมัติ

        let autoUpdateInterval = null;
        let isUpdating = false;
        let isUploadingImage = false; // [cite: 71]

        let canvasRenderer; // ✅ ประกาศตัวแปรระดับโกลบอล

        function initMap() {
            // ✅ สร้าง Canvas Renderer 1 ครั้ง
            canvasRenderer = L.canvas({ padding: 0.5 });
            
            const mapOptions = {
                zoomControl: false,
                attributionControl: false,
                preferCanvas: true,
                renderer: canvasRenderer, // ✅ ใช้ renderer เดียวกัน
                zoomSnap: isMobile() ? 0.5 : 1,
                wheelDebounceTime: 40,
                doubleClickZoom: false
            };

          map = L.map('map', {
            zoomControl: false,
            attributionControl: false,
            preferCanvas: true,
            // ✅ อนุญาตให้แผนที่แสดงล้นขอบจอได้
            padding: [50, 50], // เพิ่มพื้นที่ว่างรอบแผนที่ (บน, ล่าง, ซ้าย, ขวา)
            maxBoundsViscosity: 0.5, // ลดความหนืดของขอบเขต (ทำให้เลื่อนลื่นขึ้น)
            inertia: true, // เปิดใช้งานการเลื่อนแบบอินเนอร์เชีย
            inertiaDeceleration: 3000, // ความเร็วการชะลอตัว
            inertiaMaxSpeed: 1500, // ความเร็วสูงสุด
            // ไม่กำหนดขอบเขตแผนที่ (ให้แสดงล้นได้)
            // maxBounds: undefined
          }).setView([15.202, 102.068], 14);

          // Hardware Acceleration
          const container = map.getContainer();
          container.style.transform = 'translate3d(0, 0, 0)';
          
        // Google Hybrid Tile Options - ปรับเพิ่มประสิทธิภาพ
        const tileOptions = {
            subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],
            updateWhenIdle: false, // ✅ โหลดขณะเลื่อน (ไม่รอหยุด)
            updateWhenZooming: true, // ✅ อัปเดตขณะซูม
            keepBuffer: isMobile() ? 6 : 10, // ✅ เพิ่มบัฟเฟอร์ (มือถือ 4, คอม 8)
            maxNativeZoom: 19, // ป้องกันการโหลดไทล์ที่ไม่มี
            reuseTiles: true, // ✅ ใช้ไทล์เก่าซ้ำแทนโหลดใหม่
            className: 'map-tiles-optimized'
        };

        // Low Res / Background Layer
        const lowResLayer = L.tileLayer('https://{s}.google.com/vt/lyrs=y&x={x}&y={y}&z={z}', {
            ...tileOptions,
            maxZoom: 15,
            zIndex: 1
        });

        // High Res Layer
        const highResLayer = L.tileLayer('https://{s}.google.com/vt/lyrs=y&x={x}&y={y}&z={z}', {
            ...tileOptions,
            minZoom: 16,
            maxZoom: 22,
            zIndex: 2
        });

          lowResLayer.addTo(map);
          highResLayer.addTo(map);
          surveyLayers.addTo(map);
        }
        // ตรวจจับอุปกรณ์มือถือ
        function isMobile() {
          return /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        function activateTool(tool) {
          isEditMode = false;
          document.getElementById('btn-edit').classList.remove('active-edit');
          surveyLayers.eachLayer(l => l.dragging && l.dragging.disable());
          
          if (activeTool === tool) {
            // ยกเลิกการเพิ่มจุด - เลื่อนลง
            deactivateTools();
          } else {
            // เปิดใช้งานเครื่องมือใหม่
            activeTool = tool;
            document.getElementById('btn-building').classList.toggle('active-tool', tool === 'building');
            document.getElementById('btn-sign').classList.toggle('active-tool', tool === 'sign');
            
            // แสดงเป้าเล็งและปุ่มบวกด้วยแอนิเมชันเลื่อนขึ้น
            const crosshair = document.getElementById('crosshair');
            const addTrigger = document.getElementById('add-trigger-container');
            
            // ลบคลาส hidden และเพิ่มคลาส visible พร้อมแอนิเมชัน
            crosshair.classList.remove('hidden');
            addTrigger.classList.remove('hidden');
            
            // บังคับให้เบราว์เซอร์คำนวณใหม่ก่อนเริ่มแอนิเมชัน
            void crosshair.offsetWidth;
            void addTrigger.offsetWidth;
            
            // เริ่มแอนิเมชันเลื่อนขึ้น
            crosshair.classList.add('visible');
            addTrigger.classList.add('visible');
            
            // ซ่อนปุ่มคอนเฟิร์มหากมี
            document.getElementById('confirm-overlay').classList.add('hidden');
          }
        }

        // ระบบแคชแผนที่
        let mapCache = {};

        function cacheCurrentView() {
            const bounds = map.getBounds();
            const zoom = map.getZoom();
            
            // สร้างคีย์สำหรับแคช
            const cacheKey = `${bounds.getNorth()},${bounds.getEast()},${bounds.getSouth()},${bounds.getWest()}_${zoom}`;
            
            // บันทึกตำแหน่งปัจจุบันลงในแคช
            mapCache[cacheKey] = {
                timestamp: new Date().toISOString(),
                bounds: bounds,
                zoom: zoom
            };
            
            console.log(`แคชตำแหน่ง: ${cacheKey}`);
        }

        // โหลดแผนที่จากแคชเมื่อเปิดแอป
        function loadCachedMapViews() {
            // โหลดจาก localStorage
            const cached = localStorage.getItem('mapCache');
            if (cached) {
                mapCache = JSON.parse(cached);
                console.log('โหลดแคชแผนที่เรียบร้อย');
            }
        }

        // บันทึกแคชเมื่อปิดแอป
        window.addEventListener('beforeunload', () => {
            localStorage.setItem('mapCache', JSON.stringify(mapCache));
        });

        // เรียกใช้เมื่อเปิดแอป
        loadCachedMapViews();

        function deactivateTools() {
          activeTool = null;
          document.getElementById('btn-building').classList.remove('active-tool');
          document.getElementById('btn-sign').classList.remove('active-tool');
          
          const crosshair = document.getElementById('crosshair');
          const addTrigger = document.getElementById('add-trigger-container');
          
          // เริ่มแอนิเมชันเลื่อนลง
          crosshair.classList.remove('visible');
          addTrigger.classList.remove('visible');
          
          // หลังแอนิเมชันเสร็จ ซ่อนองค์ประกอบจริงๆ
          setTimeout(() => {
            crosshair.classList.add('hidden');
            addTrigger.classList.add('hidden');
            document.getElementById('confirm-overlay').classList.add('hidden');
          }, 400); // ตรงกับระยะเวลาแอนิเมชัน 0.4s
        }

        function toggleEditMode() {
            isEditMode = !isEditMode;
            
            const btnEdit = document.getElementById('btn-edit');
            
            if (isEditMode) {
                // ปิดเครื่องมือเพิ่มจุด
                activeTool = null;
                document.getElementById('btn-building').classList.remove('active-tool');
                document.getElementById('btn-sign').classList.remove('active-tool');
                
                // ✅ เพิ่มคลาส 'active-edit' ให้ปุ่ม "move" เป็นสีน้ำเงิน
                btnEdit.classList.add('active-edit');
                
                // ✅ เปิดใช้งานการลากมาร์กเกอร์ทั้งหมด
                surveyLayers.eachLayer(function(layer) {
                    if (layer._popupData && layer.dragging && layer.dragging.enable) {
                        layer.dragging.enable();
                        
                        // ผูกเหตุการณ์เมื่อลากเสร็จ
                        layer.off('dragend');
                        layer.on('dragend', async function(e) {
                            const newLatLng = e.target.getLatLng();
                            const marker = e.target;
                            const data = marker._popupData;
                            if (data) {
                                await updateMarkerPosition(marker, data, newLatLng);
                            }
                        });
                    }
                });
                
                showEditModeModal();
            } else {
                // ✅ ลบคลาส 'active-edit' ออกจากปุ่ม "move"
                btnEdit.classList.remove('active-edit');
                
                // ✅ ปิดการลากมาร์กเกอร์ทั้งหมด
                surveyLayers.eachLayer(function(layer) {
                    if (layer.dragging && layer.dragging.disable) {
                        layer.dragging.disable();
                    }
                });
            }
        }

        // ฟังก์ชันสำหรับปิด/เปิดการใช้งานปุ่มรีโหลด
        function disableRefreshButton() {
            const btn = document.getElementById('btn-refresh');
            btn.disabled = true;
            btn.style.opacity = '0.5';
            btn.style.cursor = 'not-allowed';
        }

        function enableRefreshButton() {
            const btn = document.getElementById('btn-refresh');
            btn.disabled = false;
            btn.style.opacity = '1';
            btn.style.cursor = 'pointer';
        }


        // ข้อ 2: แสดงปุ่มยืนยัน
        function showConfirmButton() {
            const overlay = document.getElementById('confirm-overlay');
            const btn = document.getElementById('btn-confirm-action');
            const text = document.getElementById('confirm-text');

            if (activeTool === 'building') {
                btn.style.backgroundColor = '#f97316'; 
                text.innerText = "เพิ่มสิ่งปลูกสร้าง";
            } else {
                btn.style.backgroundColor = '#22c55e';
                text.innerText = "ยืนยันเพิ่มป้าย";
            }
            overlay.classList.remove('hidden');
        }

        // ข้อ 2: ยืนยันและบันทึกเบื้องหลัง
        async function confirmCapture() {
            // คำนวณพิกัดตามตำแหน่งเป้า (สูงขึ้น 15%)
            const containerPoint = L.point(map.getSize().x / 2, map.getSize().y * 0.35);
            const latlng = map.containerPointToLatLng(containerPoint);

            document.getElementById('confirm-overlay').classList.add('hidden');
            
            const tempMarker = createCircleMarker(latlng, activeTool);
            tempMarker.addTo(surveyLayers);
            
            backgroundUpload(latlng, activeTool, tempMarker);
        }

        // แก้ไขฟังก์ชัน backgroundUpload
        async function backgroundUpload(latlng, type, marker) {
            const refreshBtn = document.getElementById('btn-refresh');
            const refreshIcon = document.getElementById('refresh-icon');
            
            disableRefreshButton();
            refreshIcon.classList.add('animate-spin');
            
            // สร้างข้อมูลพื้นฐาน
            const data = {
                lat_long: `${latlng.lat.toFixed(6)}, ${latlng.lng.toFixed(6)}`,
                date_added: new Date().toISOString(),
                tempMarker: true
            };
            
            // เพิ่มข้อมูลเริ่มต้น
            if (type === 'sign') {
                data.s_code = `99Z000-S${Date.now().toString().slice(-3)}`;
                data.s_name = '';
                data.s_type = '';
                data.s_wide = '0';
                data.s_length = '0';
            } else {
                data.building_c = `99Z000-B${Date.now().toString().slice(-5)}`;
                data.full_name = '';
                data.b_type = '';
                data.b_area = '0';
            }
            
            // ✅ ทำเครื่องหมายในมาร์กเกอร์ว่าเป็นชั่วคราว
            marker._popupData = { ...data, type: type, tempMarker: true };
            setupMarkerPopup(marker, marker._popupData, type);
            
            try {
                // ✅ สร้างคิวทุกกรณี ไม่ต้องตรวจสอบออนไลน์/ออฟไลน์
                const queueId = addToSyncQueue('quickAdd', type, data);
                marker._popupData = {
                    ...data,
                    type: type,
                    tempMarker: true,
                    queued: true,
                    queueId: queueId
                };
                setupMarkerPopup(marker, marker._popupData, type);
                
                // ✅ เรียกซิงค์ทันที
                await processSyncQueue();
                
                // ✅ รอให้รายการนี้สำเร็จ
                const maxWaitTime = 60000; // 30 วินาที
                const startTime = Date.now();
                let queueItem = syncQueue.find(q => q.id === queueId);
                
                while (queueItem && queueItem.status === 'ยังไม่สำรวจ' && (Date.now() - startTime) < maxWaitTime) {
                    await new Promise(resolve => setTimeout(resolve, 500)); // รอ 500 มิลลิวินาที
                    queueItem = syncQueue.find(q => q.id === queueId);
                }
                
                // ✅ โหลดข้อมูลใหม่ก่อน (เพื่อให้มีข้อมูลจริงแสดงบนแผนที่)
                await loadExistingData();
                
                // ✅ ลบจุดชั่วคราวหลังจากโหลดเสร็จ
                setTimeout(() => {
                    surveyLayers.eachLayer(layer => {
                        if (layer._popupData && layer._popupData.tempMarker) {
                            surveyLayers.removeLayer(layer);
                        }
                    });
                    refreshIcon.classList.remove('animate-spin');
                    refreshBtn.classList.add('refresh-success');
                    setTimeout(() => {
                        refreshBtn.classList.remove('refresh-success');
                        enableRefreshButton();
                    }, 2000);
                    
                    if (queueItem && queueItem.status === 'success') {
                        showNotificationLeft('เพิ่มจุดเรียบร้อยแล้ว!', 'success');
                    } else {
                        showNotificationLeft('เพิ่มจุดเรียบร้อยแล้ว (รอซิงค์)', 'warning');
                    }
                }, 300);
                
            } catch (err) {
                refreshIcon.classList.remove('animate-spin');
                enableRefreshButton();
                showNotificationLeft("การบันทึกล้มเหลว: " + err.message, 'error');
            }
        }

        // ============================================
        // ฟังก์ชันบันทึกข้อมูล (แก้ไขส่วนจัดการรูปภาพ - แยกเก็บลิ้งค์และชื่อไฟล์)
        // ============================================
        async function saveSurveyData() {
            const form = document.getElementById('survey-form');
            if (!form) {
                showNotificationLeft('ไม่พบฟอร์มข้อมูล', 'error');
                return;
            }
            
            // ✅ รวบรวมข้อมูลจากฟอร์ม (ไม่รวมฟิลด์ไฟล์)
            const formData = new FormData(form);
            const data = {};

            for (let [key, value] of formData.entries()) {
                if (key.endsWith('_temp')) continue; // ข้ามฟิลด์ชั่วคราว
                
                const input = form.querySelector(`[name="${key}"]`);
                if (input && input.type === 'checkbox') {
                    data[key] = input.checked ? 'TRUE' : 'FALSE';
                } else if (input && input.type !== 'file') {
                    data[key] = value.trim();
                }
            }

            // ✅ เพิ่มค่าฟิลด์ที่ถูกปิดการใช้งาน (เฉพาะสิ่งปลูกสร้าง) - แก้ไขปัญหาค่าว่างไม่ถูกส่ง
            if (form.querySelector('[name="b_use2"]')) { // ตรวจสอบว่าเป็นฟอร์มสิ่งปลูกสร้าง
                const disabledFields = [
                    'b_use2', 'per_use2', 'buse_floor2', 'buse_area2', 'ment_use2', 'full_area2',
                    'land_use' // เพิ่ม land_use ด้วย (แม้จะคำนวณอัตโนมัติ แต่ต้องส่งค่า)
                ];
                
                disabledFields.forEach(fieldId => {
                    const field = form.querySelector(`[name="${fieldId}"]`);
                    if (field) {
                        // ดึงค่าจากฟิลด์แม้ถูกปิดการใช้งาน + trim ค่าว่าง
                        const rawValue = field.value || '';
                        data[fieldId] = rawValue.trim();
                        console.log(`📤 เพิ่มค่า ${fieldId} (disabled) ใน payload: "${data[fieldId]}"`);
                    }
                });
            }

            // ✅ คำนวณค่า "ใช้ประโยชน์ที่ดิน" ใหม่ทุกครั้งก่อนบันทึก (ไม่พึ่งพาค่าใน UI)
            const bUseField = form.querySelector('select[name="b_use"]');
            const bUse2Field = form.querySelector('select[name="b_use2"]');
            let computedLandUse = '';

            if (bUseField && bUse2Field) {
                const bUseValue = (bUseField.value || '').trim();
                const bUse2Value = (bUse2Field.value || '').trim();
                
                // คำนวณตามเงื่อนไขเดิม
                if (bUseValue && bUse2Value) {
                    computedLandUse = '5-ใช้ประโยชน์หลายประเภท'; // ทั้งสองช่องมีค่า
                } else if (bUseValue) {
                    computedLandUse = bUseValue; // มีค่าจาก b_use เท่านั้น
                } else if (bUse2Value) {
                    computedLandUse = bUse2Value; // มีค่าจาก b_use2 เท่านั้น
                }
                // ถ้าทั้งสองว่าง → ค่าว่าง (ไม่ต้องทำอะไร)
            }

            // ✅ ตั้งค่าในข้อมูลที่จะส่ง (แทนที่ค่าเดิมหรือเพิ่มใหม่)
            data.land_use = computedLandUse;
            console.log('✅ คำนวณค่า land_use ใหม่ก่อนบันทึก:', data.land_use || '(ว่าง)');

            // ✅ ดึงพิกัดจากหลายแหล่ง (สำคัญที่สุด!)
            let latLongValue = '';

            // ลองดึงจากฟิลด์ซ่อนในฟอร์มก่อน (สำคัญที่สุด!)
            const latLongInput = form.querySelector('input[name="lat_long"]');
            if (latLongInput && latLongInput.value.trim() !== '') {
                latLongValue = latLongInput.value.trim();
                console.log('📍 พิกัดจากฟิลด์ซ่อน:', latLongValue);
            }

            // ถ้าไม่มีในฟิลด์ซ่อน ให้ลองดึงจาก #latlng-display
            if (!latLongValue) {
                const latlngDisplay = document.getElementById('latlng-display')?.innerText;
                if (latlngDisplay && latlngDisplay.trim() !== '' && latlngDisplay !== 'กำลังโหลด...') {
                    latLongValue = latlngDisplay.trim();
                    console.log('📍 พิกัดจาก #latlng-display:', latLongValue);
                }
            }

            // ถ้ายังไม่มี ให้ดึงจากมาร์กเกอร์ที่กำลังแก้ไข
            if (!latLongValue && editingMarker && editingMarker._popupData) {
                latLongValue = editingMarker._popupData.lat_long || '';
                console.log('📍 พิกัดจาก _popupData:', latLongValue);
            }

            // ตรวจสอบว่าได้พิกัดหรือไม่
            if (!latLongValue || latLongValue.trim() === '') {
                showNotificationLeft('❌ ไม่พบพิกัดตำแหน่ง กรุณาตรวจสอบอีกครั้ง', 'error');
                console.error('❌ ไม่พบพิกัดในทุกแหล่งที่พยายามดึง');
                console.log('- ฟิลด์ซ่อน:', latLongInput?.value);
                console.log('- #latlng-display:', document.getElementById('latlng-display')?.innerText);
                console.log('- editingMarker._popupData:', editingMarker?._popupData);
                return;
            }

            data.lat_long = latLongValue;
            console.log('✅ ใช้พิกัด:', data.lat_long);
            
            // ✅ ตรวจสอบประเภทและกำหนดรหัสอัตโนมัติ
            let markerType;
            let rowKey = null;
            let action = 'add';
            
            if (editingMarker && editingMarker._popupData) {
                markerType = editingMarker._popupData.type || (editingMarker._popupData.building_c ? 'building' : 'sign');
                rowKey = editingMarker._popupData.id || editingMarker._popupData._row_num;
                action = 'update';
            } else {
                markerType = document.getElementById('marker-type')?.value || 'building';
                action = 'add';
            }
            
            if (!markerType || !['building', 'sign'].includes(markerType)) {
                showNotificationLeft('ไม่พบประเภทข้อมูล', 'error');
                return;
            }

            // ============================================
            // ✅ กำหนดรหัสอัตโนมัติถ้าไม่มี (สำคัญมาก!)
            // ============================================
            if (markerType === 'building') {
                // ตรวจสอบว่ามีรหัสสิ่งปลูกสร้างหรือไม่
                if (!data.building_c || data.building_c.trim() === '') {
                    // สร้างรหัสสิ่งปลูกสร้างอัตโนมัติ (เช่น B001, B002, ...)
                    const existingCodes = allBuildings.map(b => b.building_c).filter(c => c);
                    let maxNum = 0;
                    existingCodes.forEach(code => {
                        const match = code.match(/^B(\d+)$/);
                        if (match) {
                            maxNum = Math.max(maxNum, parseInt(match[1]));
                        }
                    });
                    data.building_c = `B${String(maxNum + 1).padStart(3, '0')}`;
                    console.log(`🏷️ สร้างรหัสสิ่งปลูกสร้างอัตโนมัติ: ${data.building_c}`);
                }
            } else if (markerType === 'sign') {
                // ตรวจสอบว่ามีรหัสป้ายหรือไม่
                if (!data.s_code || data.s_code.trim() === '') {
                    // สร้างรหัสป้ายอัตโนมัติ (เช่น S001, S002, ...)
                    const existingCodes = allSigns.map(s => s.s_code).filter(c => c);
                    let maxNum = 0;
                    existingCodes.forEach(code => {
                        const match = code.match(/^S(\d+)$/);
                        if (match) {
                            maxNum = Math.max(maxNum, parseInt(match[1]));
                        }
                    });
                    data.s_code = `S${String(maxNum + 1).padStart(3, '0')}`;
                    console.log(`🏷️ สร้างรหัสป้ายอัตโนมัติ: ${data.s_code}`);
                }
            }

            // ============================================
            // ✅ จัดการรูปภาพ: เฉพาะเมื่อมีการเลือกไฟล์ใหม่เท่านั้น
            // ============================================
            let imageBase64 = null;
            let fileNameParam = null;
            const fileInput = form.querySelector('input[type="file"]');
            
            // ✅ ตรวจสอบว่ามีการเลือกไฟล์ใหม่หรือไม่
            if (fileInput && fileInput.files[0]) {
                const file = fileInput.files[0];
                const maxSize = markerType === 'building' ? 1500 : 2000;
                
                // ตั้งชื่อไฟล์ใหม่
                const prefix = markerType === 'building' ? 'B' : 'S';
                const code = data.building_c || data.s_code || Date.now().toString().slice(-5);
                const extension = file.name.split('.').pop().toLowerCase() || 'jpg';
                fileNameParam = `${prefix}${code}.${extension}`;
                
                // ปรับขนาดรูปภาพ
                try {
                    const resizedImage = await resizeImage(file, maxSize, maxSize);
                    const base64Data = resizedImage.split(',')[1];
                    imageBase64 = `${file.type};base64,${base64Data}`;
                    
                    // บันทึกลง IndexedDB
                    await saveImageToDB(imageBase64, fileNameParam, rowKey || Date.now(), markerType);
                    console.log(`✅ รูปภาพบันทึกใน IndexedDB: ${fileNameParam}`);
                    
                    // ✅ เก็บชื่อไฟล์ในข้อมูล (สำหรับคอลั่มน์ 'picture')
                    data.picture = fileNameParam;
                } catch (err) {
                    console.error('Error resizing image:', err);
                    try {
                        const arrayBuffer = await file.arrayBuffer();
                        const bytes = [...new Uint8Array(arrayBuffer)];
                        const binary = bytes.map(b => String.fromCharCode(b)).join('');
                        imageBase64 = `${file.type};base64,${btoa(binary)}`;
                        
                        await saveImageToDB(imageBase64, fileNameParam, rowKey || Date.now(), markerType);
                        console.log(`⚠️ รูปภาพบันทึกแบบไม่ปรับขนาด: ${fileNameParam}`);
                        data.picture = fileNameParam;
                    } catch (fallbackErr) {
                        console.error('Fallback failed:', fallbackErr);
                        showNotificationLeft('⚠️ ไม่สามารถบันทึกรูปภาพได้', 'warning');
                        // ✅ ไม่เก็บค่า picture หากบันทึกไม่สำเร็จ
                        delete data.picture;
                        imageBase64 = null;
                        fileNameParam = null;
                    }
                }
            } else {
                // ✅ สำคัญมาก: ไม่เก็บค่า picture ในข้อมูลเมื่อไม่มีการเลือกไฟล์ใหม่
                // เพื่อป้องกันไม่ให้เซิร์ฟเวอร์ทับค่าเดิมด้วย "image.jpg"
                console.log('ℹ️ ไม่มีการเลือกรูปภาพใหม่ - ไม่ส่งค่า picture ไปยังเซิร์ฟเวอร์');
            }
            
            // ✅ วางโค้ดตรวจสอบที่นี่ (หลังจากตั้งค่า data.picture และก่อนสร้างคิว)
            if (data.picture === 'image.jpg' || data.picture === '') {
                delete data.picture;
                console.warn('⚠️ ลบค่า picture ที่ไม่ถูกต้องออกก่อนส่ง: ', data.picture);
            }
            if (fileNameParam === 'image.jpg' || !fileNameParam || fileNameParam.trim() === '') {
                fileNameParam = null;
                imageBase64 = null;
                console.warn('⚠️ ยกเลิกการส่ง fileNameParam ที่ไม่ถูกต้อง');
            }

            // ============================================
            // ✅ สร้างคิวสำหรับอัปโหลด
            // ============================================
            const queueId = addToSyncQueue(action, markerType, data, rowKey, imageBase64, fileNameParam);
            console.log(`✅ สร้างคิวสำเร็จ: ${queueId} (${action})`);
            
            // ✅ อัปเดตมาร์กเกอร์ทันที
            if (editingMarker) {
                editingMarker._popupData = {
                    ...editingMarker._popupData,
                    ...data,
                    queued: true,
                    queueId: queueId
                };
                setupMarkerPopup(editingMarker, editingMarker._popupData, markerType);
            }
            
            // ✅ ปิดแผงและแจ้งเตือน
            closePanel();
            const msg = action === 'update' ? 'อัปเดตข้อมูลเรียบร้อยแล้ว!' : 'บันทึกข้อมูลเรียบร้อยแล้ว!';
            showNotificationLeft(`${msg} (รออัปโหลด)`, 'success');
            
            // ✅ เริ่มซิงค์ทันทีหากออนไลน์
            if (isOnline && navigator.onLine) {
                setTimeout(() => {
                    console.log('🔄 เริ่มซิงค์คิวข้อมูล...');
                    processSyncQueue();
                }, 300);
            }
            
            console.log('✅ บันทึกข้อมูลเสร็จสิ้น');
        }

        async function processDataSyncQueue() {
            console.log('🔄 เริ่มกระบวนการซิงค์ข้อมูล...');
            console.log('สถานะออนไลน์:', isOnline, 'navigator.onLine:', navigator.onLine);
            console.log('จำนวนรายการในคิวข้อมูล:', dataSyncQueue.length);
            
            if (!isOnline || !navigator.onLine) {
                console.log('❌ ออฟไลน์ - รอการเชื่อมต่อ...');
                return;
            }
            
            if (dataSyncQueue.length === 0) {
                console.log('ℹ️ คิวข้อมูลว่าง - ไม่มีข้อมูลให้อัปโหลด');
                return;
            }
            
            console.log(`📦 เริ่มกระบวนการซิงค์ข้อมูล (${dataSyncQueue.length} รายการ)`);
            console.log('CONFIG.SCRIPT_URL:', CONFIG.SCRIPT_URL);
            
            // ประมวลผลคิวทีละรายการ
            for (let i = 0; i < dataSyncQueue.length; i++) {
                const item = dataSyncQueue[i];
                
                if (item.status === 'success') {
                    console.log(`⏭️ รายการ ${i + 1}: สำเร็จแล้ว (ข้าม)`);
                    continue;
                }
                
                try {
                    console.log(`📤 กำลังประมวลผลรายการ ${i + 1}/${dataSyncQueue.length}: ${item.action}`);
                    console.log('ข้อมูล:', JSON.stringify(item, null, 2));
                    
                    let result;
                    
                    // ✅ แก้ไข: เปลี่ยน 'add' เป็น 'quickAdd'
                    switch (item.action) {
                        case 'add':
                        case 'quickAdd':
                            result = await sendDataWithRetry('quickAdd', item.type, item.data);
                            break;
                        case 'update':
                            result = await sendDataWithRetry('update', item.type, item.data, item.rowKey);
                            break;
                        case 'delete':
                            result = await sendDataWithRetry('delete', item.type, {}, item.rowKey);
                            break;
                        case 'updatePosition':
                            result = await sendDataWithRetry('updatePosition', item.type, item.data, item.rowKey);
                            break;
                        default:
                            console.warn(`⚠️ ไม่รู้จัก action: ${item.action}`);
                            continue;
                    }
                    
                    console.log(`📊 ผลลัพธ์รายการ ${i + 1}:`, result);
                    
                    // ✅ ตรวจสอบว่าเซิร์ฟเวอร์ตอบกลับสำเร็จจริงๆ
                    if (result && (result.success || (result.data && result.data.status === 200))) {
                        console.log(`✅ รายการ ${i + 1} สำเร็จ`);
                        
                        // อัปเดตสถานะในคิว
                        item.status = 'success';
                        item.syncedAt = new Date().toISOString();
                        
                        // บันทึกคิวลงใน localStorage
                        saveDataSyncQueueToStorage();
                        
                        // แสดงแจ้งเตือน
                        showNotificationLeft(`อัปโหลดข้อมูลสำเร็จ (${i + 1}/${dataSyncQueue.length})`, 'success');
                        
                    } else {
                        console.warn(`⚠️ รายการ ${i + 1} ล้มเหลว - รอลองใหม่`);
                        console.log('ผลลัพธ์:', result);
                        
                        item.retryCount = (item.retryCount || 0) + 1;
                        
                        if (item.retryCount >= 3) {
                            item.status = 'failed';
                            console.error(`❌ รายการ ${i + 1} ล้มเหลวเกิน 3 ครั้ง`);
                        }
                        
                        // บันทึกคิวลงใน localStorage
                        saveDataSyncQueueToStorage();
                        
                        // หยุดกระบวนการชั่วคราว
                        break;
                    }
                    
                    // รอ 500ms ระหว่างการอัปโหลดแต่ละรายการ
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                } catch (err) {
                    console.error(`❌ ข้อผิดพลาดในการประมวลผลรายการ ${i + 1}:`, err);
                    console.error('Stack trace:', err.stack);
                    
                    item.retryCount = (item.retryCount || 0) + 1;
                    
                    if (item.retryCount >= 3) {
                        item.status = 'failed';
                    }
                    
                    // บันทึกคิวลงใน localStorage
                    saveDataSyncQueueToStorage();
                    
                    // หยุดกระบวนการชั่วคราว
                    break;
                }
            }
            
            // ลบรายการที่สำเร็จแล้วออกจากคิว
            const successItems = dataSyncQueue.filter(item => item.status === 'success');
            for (const item of successItems) {
                removeFromDataSyncQueue(item.id);
            }
            
            // โหลดคิวใหม่จาก localStorage
            loadDataSyncQueueFromStorage();
            
            console.log(`✅ กระบวนการซิงค์ข้อมูลเสร็จสิ้น - คงเหลือ ${dataSyncQueue.length} รายการ`);
            
            // ถ้ายังมีรายการเหลืออยู่ ให้ลองซิงค์อีกครั้งหลังจาก 5 วินาที
            if (dataSyncQueue.length > 0) {
                console.log('⏳ มีรายการเหลืออยู่ - จะลองซิงค์อีกครั้งใน 5 วินาที');
                setTimeout(() => {
                    processDataSyncQueue();
                }, 5000);
            }
        }

        // แก้ไขฟังก์ชัน updateMarkerPosition
        async function updateMarkerPosition(marker, data, newLatLng) {
            const refreshBtn = document.getElementById('btn-refresh');
            const refreshIcon = document.getElementById('refresh-icon');
            disableRefreshButton();
            refreshIcon.classList.add('animate-spin');
            
            const oldLatLng = data.lat_long;
            const newLatLngStr = `${newLatLng.lat.toFixed(6)}, ${newLatLng.lng.toFixed(6)}`;
            const rowKey = data._row_num || data.id;
            const type = data.type || (data.building_c ? 'building' : 'sign');
            
            if (!rowKey) {
                alert("ไม่พบข้อมูลสำหรับอัปเดต");
                refreshIcon.classList.remove('animate-spin');
                enableRefreshButton();
                return;
            }
            
            // ✅ เพิ่มลงในรายการจุดที่กำลังถูกย้าย
            markersBeingMoved.add(rowKey);
            
            // ✅ หาจุดจริงที่กำลังถูกย้าย (ไม่ใช่จุดชั่วคราว)
            let realMarker = null;
            surveyLayers.eachLayer(layer => {
                if (layer._popupData) {
                    const layerId = layer._popupData._row_num || layer._popupData.id;
                    // ✅ ตรวจสอบว่าเป็นจุดจริง (ไม่ใช่จุดชั่วคราว)
                    if (String(layerId) === String(rowKey) && !layer._popupData.tempMarker) {
                        realMarker = layer;
                    }
                }
            });
            
            if (!realMarker) {
                console.warn(`⚠️ ไม่พบจุดจริงที่จะย้าย: ${rowKey}`);
                markersBeingMoved.delete(rowKey);
                refreshIcon.classList.remove('animate-spin');
                enableRefreshButton();
                return;
            }
            
            try {
                // ✅ อัปเดตตำแหน่งในข้อมูลทันที (ไม่ต้องโหลดข้อมูลใหม่ทั้งหมด)
                realMarker._popupData.lat_long = newLatLngStr;
                realMarker.setLatLng(newLatLng);
                
                // ✅ ส่งข้อมูลไปยังเซิร์ฟเวอร์
                const body = new URLSearchParams();
                body.append('action', 'updatePosition');
                body.append('type', type);
                body.append('rowKey', rowKey);
                body.append('lat_long', newLatLngStr);
                
                const res = await fetch(CONFIG.SCRIPT_URL.trim(), {
                    method: 'POST',
                    body,
                    timeout: 10000
                });
                
                const result = await res.json();
                
                if (res.ok && result.status === 200) {
                    // ✅ อัปเดตสำเร็จ - ลบออกจากรายการจุดที่กำลังถูกย้าย
                    markersBeingMoved.delete(rowKey);
                    refreshIcon.classList.remove('animate-spin');
                    refreshBtn.classList.add('refresh-success');
                    
                    setTimeout(() => {
                        refreshBtn.classList.remove('refresh-success');
                        enableRefreshButton();
                    }, 2000);
                    
                    showNotificationLeft('อัปเดตตำแหน่งสำเร็จ!', 'success');
                } else {
                    throw new Error(result.message || "อัปเดตตำแหน่งไม่สำเร็จ");
                }
            } catch (err) {
                // ✅ หากเกิดข้อผิดพลาด ให้คืนค่าจุดเดิม
                console.error('❌ ข้อผิดพลาดในการอัปเดต:', err);
                
                // คืนค่าตำแหน่งเดิม
                const coords = oldLatLng.split(',').map(Number);
                realMarker.setLatLng(L.latLng(coords[0], coords[1]));
                realMarker._popupData.lat_long = oldLatLng;
                
                markersBeingMoved.delete(rowKey);
                refreshIcon.classList.remove('animate-spin');
                enableRefreshButton();
                
                showNotificationLeft("การอัปเดตล้มเหลว: " + err.message, 'error');
            }
        }

        // ข้อ 3: ตั้งค่าป๊อปอัปเพื่อเปิดฟอร์ม (แก้ไขเพิ่มปุ่มลบ + แก้ไขป๊อบอัปไม่ปิดอัตโนมัติ)
        function setupMarkerPopup(marker, data, type) {
            const popupDiv = document.createElement('div');
            popupDiv.className = "p-1 min-w-[160px]";
            popupDiv.innerHTML = `
                <p class="font-bold text-sm text-blue-900">${type === 'building' ? 'สิ่งปลูกสร้าง' : 'ป้าย'}</p>
                <p class="text-[10px] text-gray-500">${data.lat_long}</p>
                <div class="mt-2 space-y-2">
                    <button class="w-full bg-blue-600 text-white text-[11px] py-3 rounded font-bold shadow-sm active:bg-blue-700 hover:bg-blue-700 transition">แก้ข้อมูล</button>
                    <button class="w-full bg-red-600 text-white text-[11px] py-3 rounded font-bold shadow-sm active:bg-red-700 hover:bg-red-700 transition">ลบจุด</button>
                </div>
            `;
            
            // ✅ ผูกป๊อปอัปให้มาร์กเกอร์ (สำคัญที่สุด!)
            marker.bindPopup(popupDiv, {
                minWidth: 190,
                maxWidth: 220,
                autoPan: false, // ปิดการแพนอัตโนมัติ
                closeOnClick: true
            });
            
            // เก็บข้อมูลไว้ในมาร์กเกอร์
            marker._popupData = { ...data, type: type };
            
            // ✅ ผูกปุ่มเมื่อเปิดป๊อปอัป
            marker.on('popupopen', () => {
                const buttons = marker.getPopup().getElement().querySelectorAll('button');
                if (buttons[0]) {
                    buttons[0].onclick = (e) => {
                        e.stopPropagation();
                        openEditPanel(marker._popupData, marker._popupData.type, marker);
                    };
                }
                if (buttons[1]) {
                    buttons[1].onclick = (e) => {
                        e.stopPropagation();
                        showDeleteConfirm(marker, marker._popupData, marker._popupData.type);
                    };
                }
            });
        }

        // ฟังก์ชันลบจุดและข้อมูลจาก Google Sheets (ข้อ 1)
        // แก้ไขฟังก์ชัน deleteMarker
        async function deleteMarker(marker, data, type) {
            const refreshBtn = document.getElementById('btn-refresh');
            const refreshIcon = document.getElementById('refresh-icon');
            
            // ปิดการใช้งานปุ่ม
            disableRefreshButton();
            refreshIcon.classList.add('animate-spin');
            
            // แสดงแจ้งเตือนว่ากำลังลบ (ฝั่งซ้าย)
            const deletingMsg = document.createElement('div');
            deletingMsg.className = 'fixed top-4 left-4 bg-blue-500 text-white px-6 py-3 rounded-lg shadow-lg z-[2000] animate-fade-in';
            deletingMsg.innerHTML = '<i data-lucide="loader" class="w-5 h-5 inline mr-2 animate-spin"></i>กำลังลบข้อมูล...';
            document.body.appendChild(deletingMsg);
            
            const rowKey = data._row_num || data.id;
            
            if (!rowKey) {
                alert("ไม่พบข้อมูลสำหรับลบ");
                refreshIcon.classList.remove('animate-spin');
                enableRefreshButton();
                deletingMsg.classList.add('animate-fade-out');
                setTimeout(() => deletingMsg.remove(), 300);
                return;
            }
            
            const body = new URLSearchParams();
            body.append('action', 'delete');
            body.append('type', type);
            body.append('rowKey', rowKey);
            
            try {
                const res = await fetch(CONFIG.SCRIPT_URL.trim(), { method: 'POST', body });
                
                if (res.ok) {
                    // ซ่อนข้อความ "กำลังลบ"
                    deletingMsg.classList.add('animate-fade-out');
                    setTimeout(() => deletingMsg.remove(), 300);
                    
                    // แสดงแจ้งเตือนสำเร็จ (ฝั่งซ้าย)
                    const successMsg = document.createElement('div');
                    successMsg.className = 'fixed top-4 left-4 bg-green-500 text-white px-6 py-3 rounded-lg shadow-lg z-[2000] animate-fade-in';
                    successMsg.innerHTML = '<i data-lucide="check-circle" class="w-5 h-5 inline mr-2"></i>ลบข้อมูลเรียบร้อยแล้ว!';
                    document.body.appendChild(successMsg);
                    
                    setTimeout(() => {
                        successMsg.classList.add('animate-fade-out');
                        setTimeout(() => successMsg.remove(), 300);
                    }, 500);
                    
                    surveyLayers.removeLayer(marker);
                    await loadExistingData();
                    
                    refreshIcon.classList.remove('animate-spin');
                    refreshBtn.classList.add('refresh-success');
                    setTimeout(() => {
                        refreshBtn.classList.remove('refresh-success');
                        enableRefreshButton();
                    }, 500);
                    
                    console.log("ลบข้อมูลเรียบร้อยแล้ว");
                } else {
                    throw new Error("ลบข้อมูลไม่สำเร็จ");
                }
            } catch (err) {
                // ซ่อนข้อความ "กำลังลบ"
                deletingMsg.classList.add('animate-fade-out');
                setTimeout(() => deletingMsg.remove(), 300);
                
                refreshIcon.classList.remove('animate-spin');
                enableRefreshButton();
                console.error("Error deleting marker:", err);
                
                // แสดงแจ้งเตือนข้อผิดพลาด (ฝั่งซ้าย)
                const errorMsg = document.createElement('div');
                errorMsg.className = 'fixed top-4 left-4 bg-red-500 text-white px-6 py-3 rounded-lg shadow-lg z-[2000] animate-fade-in';
                errorMsg.innerHTML = '<i data-lucide="alert-circle" class="w-5 h-5 inline mr-2"></i>เกิดข้อผิดพลาดในการลบ!';
                document.body.appendChild(errorMsg);
                
                setTimeout(() => {
                    errorMsg.classList.add('animate-fade-out');
                    setTimeout(() => errorMsg.remove(), 300);
                }, 500);
                
                throw err;
            }
        }


        function openEditPanel(data, type, marker) {
            editingMarker = marker;
            const form = document.getElementById('survey-form');
            document.getElementById('latlng-display').innerText = data.lat_long;
            document.getElementById('panel-title').innerText = type === 'building' ? 'รายละเอียดสิ่งปลูกสร้าง' : 'รายละเอียดป้าย';
            // ✅ เพิ่มฟิลด์ประเภทมาร์กเกอร์เป็นบรรทัดแรกของฟอร์ม
            // let html = `<input type="hidden" id="marker-type" name="marker-type" value="${type}">`;

            const buildingFields = [
                { id: 'image', label: 'รูปสิ่งปลูกสร้าง', type: 'file', icon: 'camera' },
                { id: 'full_name', label: 'เจ้าของ', type: 'text' },
                { id: 'address', label: 'ที่อยู่', type: 'text' },
                { id: 'building_c', label: 'รหัสสิ่งปลูกสร้าง', type: 'text' },
                { id: 'b_type', label: 'ประเภทสิ่งปลูกสร้าง', type: 'select', options: [ '000-ไม่ระบุ', '101-บ้านพักอาศัยไม้ชั้นเดียว', '102-บ้านพักอาศัยไม้ชั้นเดียวใต้ถุนสูง', '103-บ้านพักอาศัยตึกชั้นเดียว', '104-บ้านพักอาศัยไม้สองชั้น', '105-บ้านพักอาศัยตึกสองชั้น', '106-บ้านพักอาศัยครึ่งตึกครึ่งไม้สองชั้น', '107-บ้านพักอาศัยตึกสามชั้น', '108-บ้านพักอาศัยแฝดตึกสองชั้น', '109-บ้านพักอาศัยแฝดตึกสามชั้น', '110-บ้านทรงไทยไม้ชั้นเดียวใต้ถุนสูง', '111-บ้านทรงไทยครึ่งตึกครึ่งไม้สองชั้น', '112-บ้านพักอาศัยแฝดตึกชั้นเดียว', '201-บ้านแถว ทาวน์เฮาส์) ชั้นเดียว', '202-บ้านแถว ทาวน์เฮาส์) สองชั้น', '203-บ้านแถว ทาวน์เฮาส์) สามชั้น', '204-บ้านแถว ทาวน์เฮาส์) สี่ชั้น', '301-ห้องแถวไม้ชั้นเดียว', '302-ห้องแถวไม้สองชั้น', '303-ห้องแถวครึ่งตึกครึ่งไม้สองชั้น', '401-ตึกแถวชั้นเดียว', '402-ตึกแถวสองชั้น', '403-ตึกแถวสองชั้นครึ่ง', '404-ตึกแถวสามชั้น', '405-ตึกแถวสามชั้นครึ่ง', '406-ตึกแถวสี่ชั้น', '407-ตึกแถวสี่ชั้นครึ่ง', '408-ตึกแถวห้าชั้น', '409-ตึกแถวหกชั้น', '501-คลังสินค้า พื้นที่ไม่เกิน 300 ตารางเมตร', '502-คลังสินค้าพื้นที่เกินกว่า 300 ตารางเมตรขึ้นไป', '503-เรือนคนใช้ /ครัว', '504-โรงจอดรถ', '505-สถานศึกษา', '506/1-โรงแรม ความสูงไม่เกิน 5 ชั้น', '506/2-โรงแรม ความสูงเกินกว่า 5 ชั้นขึ้นไป', '507-โรงมหรสพ', '508-สถานพยาบาล', '509/1-สำนักงาน ความสูงไม่เกิน 5 ชั้น', '509/2-สำนักงาน ความสูงเกินกว่า 5 ชั้นขึ้นไป', '510-ภัตตาคาร', '511/1-ห้างสรรพสินค้า', '511/2-อาคารพาณิชยกรรม ประเภทค้าปลีกค้าส่ง', '512-สถานีบริการน้ำมันเชื้อเพลิง', '513-โรงงาน', '514-ตลาด พื้นที่ไม่เกิน 1,000 ตารางเมตร', '515-ตลาด พื้นที่เกินกว่า 1,000 ตารางเมตรขึ้นไป', '516-อาคารพาณิชย์ ประเภทโฮมออฟฟิศ', '517-โรงเลี้ยงสัตว์', '518-โรงงานซ่อมรถยนต์', '519-อาคารจอดรถ', '520/1-อาคารอยู่อาศัยรวม ความสูงไม่เกิน 5 ชั้น', '520/2-อาคารอยู่อาศัยรวม ความสูงเกินกว่า 5 ชั้นขึ้นไป', '521-ป้อมยาม', '522-อาคารพาณิชย์ ประเภทโชว์รูมรถยนต์', '523-ห้องน้ำรวม', '601-รั้วคอนกรีต', '602-รั้วลวดหนาม', '603-รั้วสังกะสี', '604-รั้วลวดถัก', '605-รั้วไม้', '606-รั้วเหล็กดัด', '607-รั้วอัลลอยด์', '608-สระว่ายน้ำ', '609-ลานกีฬาอเนกประสงค์', '610-ถนนคอนกรีต', '611-ลานคอนกรีต', '612-ถนนลาดยาง', '613-ป้ายโฆษณา', '614-ท่าเทียบเรือ'] },
                { id: 'b_mat', label: 'วัสดุ', type: 'select', options: ['ไม้', 'ตึก', 'ตึก/ไม้'] },
                { id: 'b_year', label: 'อายุ (ปี)', type: 'select', options: [1, 2, 3, 5, 7, 10, 15, 20, 25, 30, 35, 40, 45, 50, 70, 80, 100], allowCustom: true },
                { id: 'hs_no', label: 'บ้านเลขที่', type: 'text' },
                { id: 'hs_moo', label: 'หมู่', type: 'select', options: ['', 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]},
                { id: 'no_floor', label: 'จำนวนชั้น', type: 'select', options: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], defaultValue: 1 },
                { id: 'b_area', label: 'พื้นที่ทั้งหลัง (ตร.ม.)', type: 'number', defaultValue: '' },
                { id: 'b_note', label: 'รายละเอียด', type: 'select', options: ['', 'ยุ้งข้าว', 'คอกวัว', 'เล้าไก่', 'คอกหมู', 'โรงจอดรถ', 'ห้องน้ำ', 'ร้านค้าของชำ', 'ขายอาหาร', 'มินิมาร์ท', 'กระท่อมนา', 'เพิงพัก', 'โรงเก็บของ', 'เก็บฟาง', 'โรงครัว', 'ศาลาพักผ่อน', 'ตู้เติมเงิน', 'ตู้น้ำมันหยอดเหรียญ', 'ตู้น้ำดื่มหยอดเหรียญ', 'ห้องเช่ารายเดือน', 'รีสอร์ท', 'รื้อ'], allowCustom: true },
                // ✅ กลุ่มที่ 1 - สีเขียว
                { id: 'b_use', label: 'ใช้ประโยชน์', type: 'select', options: ['', '1-เกษตรกรรม', '2-(1)ที่อยู่อาศัย หลังหลัก', '2-(2)ที่อยู่อาศัย หลังหลักไม่เป็นกรรมสิทธิ์ที่ดิน', '2-(3)ที่อยู่อาศัย หลังอื่นๆ เช่น ให้เช่ารายเดือน', '3-อื่นๆ', '4-ทิ้งไว้ว่างเปล่า/รกร้าง'], customClass: 'bg-custom-green' },
                { id: 'per_use', label: 'การเช่า', type: 'select', options: ['ใช้ประโยชน์เอง', 'ให้เช่า', 'ผู้อื่นใช้'], customClass: 'bg-custom-green' },
                { id: 'full_area', label: 'ใช้ทั้งหลัง', type: 'select', options: ['', 'เต็มพื้นที่', 'บางส่วน'], customClass: 'bg-custom-green' },
                { id: 'buse_floor', label: 'ชั้นที่ใช้', type: 'select', options: ['1-1', '1-2', '1-3', '1-4', '1-5'], allowCustom: true, customClass: 'bg-custom-green' },
                { id: 'buse_area', label: 'พื้นที่ใช้ (ตร.ม.)', type: 'number', customClass: 'bg-custom-green' },
                { id: 'ment_use', label: 'รายละเอียด', type: 'select', options: ['', 'ยุ้งข้าว', 'คอกวัว', 'เล้าไก่', 'คอกหมู', 'โรงจอดรถ', 'ห้องน้ำ', 'ร้านค้าของชำ', 'ขายอาหาร', 'มินิมาร์ท', 'กระท่อมนา', 'เพิงพัก', 'โรงเก็บของ', 'เก็บฟาง', 'โรงครัว', 'ศาลาพักผ่อน', 'ตู้เติมเงิน', 'ตู้น้ำมันหยอดเหรียญ', 'ตู้น้ำดื่มหยอดเหรียญ', 'ห้องเช่ารายเดือน', 'รีสอร์ท', 'รื้อ'], allowCustom: true, customClass: 'bg-custom-green' },
                
                // ✅ กลุ่มที่ 2 - สีชมพู
                { id: 'b_use2', label: 'ใช้ประโยชน์ (2)', type: 'select', options: ['', '1-เกษตรกรรม', '2-(1)ที่อยู่อาศัย หลังหลัก', '2-(2)ที่อยู่อาศัย หลังหลักไม่เป็นกรรมสิทธิ์ที่ดิน', '2-(3)ที่อยู่อาศัย หลังอื่นๆ เช่น ให้เช่ารายเดือน', '3-อื่นๆ', '4-ทิ้งไว้ว่างเปล่า/รกร้าง'], customClass: 'bg-custom-pink' },
                { id: 'per_use2', label: 'การเช่า (2)', type: 'select', options: ['ใช้ประโยชน์เอง', 'ให้เช่า', 'ผู้อื่นใช้'], defaultValue: 'ใช้ประโยชน์เอง' , customClass: 'bg-custom-pink' },
                { id: 'buse_floor2', label: 'ชั้นที่ใช้ (2)', type: 'select', options: ['', '1-1', '1-2', '1-3', '1-4', '1-5'], allowCustom: true, customClass: 'bg-custom-pink' },
                {
                  id: 'buse_area2', 
                  label: 'พื้นที่ใช้ (2) (ตร.ม.)', 
                  type: 'number', 
                  customClass: 'bg-custom-pink',
                  withButtons: true // เพิ่มฟลากรูปปุ่ม
                },
                { id: 'ment_use2', label: 'รายละเอียด (2)', type: 'select', options: ['', 'ยุ้งข้าว', 'คอกวัว', 'เล้าไก่', 'คอกหมู', 'โรงจอดรถ', 'ห้องน้ำ', 'ร้านค้าของชำ', 'ขายอาหาร', 'มินิมาร์ท', 'กระท่อมนา', 'เพิงพัก', 'โรงเก็บของ', 'เก็บฟาง', 'โรงครัว', 'ศาลาพักผ่อน', 'ตู้เติมเงิน', 'ตู้น้ำมันหยอดเหรียญ', 'ตู้น้ำดื่มหยอดเหรียญ', 'ห้องเช่ารายเดือน', 'รีสอร์ท', 'รื้อ'], allowCustom: true, customClass: 'bg-custom-pink' },
                { id: 'full_area2', label: 'ใช้ทั้งหลัง (2)', type: 'select', options: ['', 'บางส่วน'], customClass: 'bg-custom-pink' },
                { 
                  id: 'land_use', 
                  label: 'ใช้ประโยชน์ที่ดิน', 
                  type: 'select', 
                  options: ['', '1-เกษตรกรรม', '2-(1)ที่อยู่อาศัย หลังหลัก', '2-(2)ที่อยู่อาศัย หลังหลักไม่เป็นกรรมสิทธิ์ที่ดิน', '2-(3)ที่อยู่อาศัย หลังอื่นๆ เช่น ให้เช่ารายเดือน', '3-อื่นๆ', '4-ทิ้งไว้ว่างเปล่า/รกร้าง', '5-ใช้ประโยชน์หลายประเภท'], 
                  customClass: 'bg-custom-green',
                  computed: true, // ✅ เพิ่มบรรทัดนี้ (แทน readonly: true)
                  disabled: true  // ✅ เพิ่มบรรทัดนี้
                },
                { id: 'check', label: 'สถานะการตรวจสอบ', type: 'select', options: ['ยังไม่สำรวจ', 'ถ่ายรูปแล้ว', 'ตรวจสอบแล้ว'], customClass: 'bg-custom-check-status' }
            ];

            
            const signFields = [
                { id: 'image', label: 'รูปป้าย', type: 'file', icon: 'camera' },
                { id: 's_code', label: 'รหัสป้าย', type: 'text' },
                { id: 's_name', label: 'ชื่อกิจการ', type: 'text' },
                { id: 's_type', label: 'ประเภทป้าย', type: 'select', options: ['ป้าย/แสดงโฆษณาทั่วไป', 'ป้าย/ป้ายภายในอาคาร 3 ตร.ม. ขึ้นไป', 'ป้ายตามกฎหมายทะเบียนพาณิชย์'] },
                { id: 's_wide', label: 'กว้าง (ซ.ม.)', type: 'number', defaultValue: '' },
                { id: 's_length', label: 'ยาว (ซ.ม.)', type: 'number', defaultValue: '' },
                { id: 'no_side', label: 'จำนวนด้าน', type: 'select', options: [1, 2], defaultValue: 1 },
                // ✅ เพิ่ม 2 ฟิลด์ชั่วคราว (ไม่บันทึกลงชีท)
                { 
                    id: 'content_type_temp', 
                    label: 'ลักษณะเนื้อหา', 
                    type: 'select', 
                    options: ['1.ไทยล้วน', '2.ไทยอยู่บนสุด', '3.ไม่มีไทย', '3.ไทยไม่อยู่บนสุด'],
                    tempField: true // หมายเหตุ: ฟิลด์นี้ไม่บันทึกลงชีท
                },
                { 
                    id: 'sign_type_detail_temp', 
                    label: 'ลักษณะตัวป้าย', 
                    type: 'select', 
                    options: ['(ข) ทั่วไป', '(ก) จอ LED', '(ก) มอเตอร์/เคลื่อนไหว'],
                    tempField: true // หมายเหตุ: ฟิลด์นี้ไม่บันทึกลงชีท
                },
                // ✅ ฟิลด์ "ลักษณะ" แบบอ่านอย่างเดียว (สร้างอัตโนมัติ)
                { 
                    id: 's_characte', 
                    label: 'ลักษณะ', 
                    type: 'text',
                    readonly: true,
                    description: 'ค่านี้สร้างอัตโนมัติจาก 2 ฟิลด์ด้านบน'
                },
                { id: 's_text', label: 'ข้อความในป้าย', type: 'text' },
                { id: 'comment', label: 'หมายเหตุ', type: 'text' },
                { id: 'fullname', label: 'เจ้าของ', type: 'text' },
                { id: 'address', label: 'ที่อยู่', type: 'text' },
                { id: 'check', label: 'สถานะการตรวจสอบ', type: 'select', options: ['ยังไม่สำรวจ', 'ถ่ายรูปแล้ว', 'ตรวจสอบแล้ว'], customClass: 'bg-custom-check-status' }
            ];
            
            const fields = type === 'building' ? buildingFields : signFields;

    // ✅ เพิ่มฟิลด์ประเภทมาร์กเกอร์เป็นบรรทัดแรกของฟอร์ม
            let html = `
                <input type="hidden" id="marker-type" name="marker-type" value="${type}">
                <input type="hidden" name="lat_long" value="${data.lat_long || ''}">
            `;
            fields.forEach(f => {
                html += `<div class="mb-2">`;
                
                // ✅ สร้าง <label> เฉพาะฟิลด์ที่ไม่ใช่ 'file'
                if (f.type !== 'file') {
                    html += `<label class="form-label">${f.label}</label>`;
                }
                
                // ✅ ตรวจสอบฟิลด์ "สถานะการตรวจสอบ" และตั้งค่าอัตโนมัติถ้ามีชื่อรูปภาพในคอลั่มน์ 'picture' (แต่ไม่ทับถ้าเป็น 'ตรวจสอบแล้ว')
                let fieldValue = data[f.id] || '';
                if (f.id === 'check') {
                    // ⚠️ ถ้าสถานะปัจจุบันคือ 'ตรวจสอบแล้ว' → คงค่าไว้ทันที (สถานะสูงสุด ไม่ย้อนกลับ)
                    if (fieldValue === 'ตรวจสอบแล้ว') {
                        // ไม่ทำอะไร → คงค่า 'ตรวจสอบแล้ว' ไว้
                    } 
                    // ✅ ถ้าไม่ใช่ 'ตรวจสอบแล้ว' และมีชื่อรูปภาพในคอลั่มน์ 'picture' → ตั้งค่าเป็น 'ถ่ายรูปแล้ว'
                    else if (data.picture && data.picture.trim() !== '') {
                        fieldValue = 'ถ่ายรูปแล้ว';
                    }
                    // ถ้าไม่มีชื่อรูปภาพและไม่ใช่ 'ตรวจสอบแล้ว' → คงค่าเดิม (เช่น 'ยังไม่สำรวจ' หรือค่าว่าง)
                }
                
                if (f.type === 'textarea') {
                    const customClass = f.customClass || '';
                    html += `<textarea name="${f.id}" class="form-input ${customClass}" rows="2"${f.readonly ? ' readonly' : ''}>${fieldValue}</textarea>`;
                } else if (f.type === 'file') {
                    // ✅ ดึงชื่อไฟล์จากคอลั่มน์ 'picture' แทน 'image'
                    let fileName = '';
                    if (type === 'building') {
                        fileName = data.picture || data.image?.split('/').pop()?.split('?')[0] || 'ยังไม่มีรูปภาพ';
                    } else if (type === 'sign') {
                        fileName = data.picture || data.image?.split('/').pop()?.split('?')[0] || 'ยังไม่มีรูปภาพ';
                    }
                    
                    // ✅ แทนที่โค้ดเดิม (ประมาณบรรทัด 1800-1820) ด้วยโค้ดนี้
                    html += `
                    <div class="mb-2">
                        <div class="mb-3">
                            <label class="form-label flex items-center gap-1">
                                <i data-lucide="camera" class="w-3 h-3"></i>
                                ${f.label}
                            </label>
                            <input type="file" name="${f.id}" accept="image/*" capture="environment" class="hidden" id="file-input-${f.id}">
                            <button type="button" onclick="document.getElementById('file-input-${f.id}').click()" 
                                class="w-full bg-gradient-to-r from-blue-500 to-blue-600 text-white py-2 px-2 rounded-md font-semibold text-sm shadow-sm hover:from-blue-600 hover:to-blue-700 transition-all flex items-center justify-center gap-1">
                                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M14.5 4h-4L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-3.5-3z"></path>
                                    <circle cx="12" cy="13" r="3"></circle>
                                    <path d="M12 10v3l1.5 1.5"></path>
                                </svg>
                                <span>เปิดกล้อง</span>
                            </button>
                            
                            <!-- ✅ ป้ายแสดงชื่อรูปภาพที่คลิกได้ -->
                            <div id="filename-container-${f.id}" class="mt-1.5">
                                <span id="filename-badge-${f.id}" 
                                    class="text-[10px] text-blue-600 font-medium px-2 py-0.5 bg-blue-50 rounded-full inline-flex items-center gap-1 cursor-pointer hover:bg-blue-100 transition"
                                    onclick="handleImageBadgeClick('${data.image || ''}', '${data.picture || 'ไม่มีชื่อรูปภาพ'}')">
                                    <i data-lucide="image" class="w-3 h-3"></i>
                                    <span id="filename-text-${f.id}">${fileName}</span>
                                </span>
                            </div>
                        </div>
                    </div>`;
                } else if (f.type === 'select') {
                    const customClass = f.customClass || '';
                    // ✅ เพิ่มเงื่อนไข disabled
                    const isDisabled = f.disabled ? 'disabled' : '';
                    
                    if (f.allowCustom) {
                        const value = fieldValue !== undefined && fieldValue !== null && fieldValue !== '' ? fieldValue : (f.defaultValue !== undefined ? f.defaultValue : '');
                        html += `<input type="text" name="${f.id}" class="form-input ${customClass}" list="${f.id}-options" value="${value}" ${isDisabled}>`;
                        html += `<datalist id="${f.id}-options">`;
                        f.options.forEach(opt => {
                            html += `<option value="${opt}">${opt}</option>`;
                        });
                        html += `</datalist>`;
                    } else {
                        const value = fieldValue !== undefined && fieldValue !== null && fieldValue !== '' ? fieldValue : (f.defaultValue !== undefined ? f.defaultValue : '');
                        html += `<select name="${f.id}" class="form-input ${customClass}" ${isDisabled}>`; // ✅ เพิ่ม ${isDisabled}
                        f.options.forEach(opt => {
                            const selected = String(value) === String(opt) ? 'selected' : '';
                            html += `<option value="${opt}" ${selected}>${opt}</option>`;
                        });
                        html += `</select>`;
                    }

            } else if (f.type === 'number') {
                const customClass = f.customClass || '';
                // ✅ ตรวจสอบว่าเป็นฟิลด์ buse_area2 ที่ต้องการปุ่ม
                if (f.id === 'buse_area2' && f.withButtons) {
                    html += `
                    <div class="flex gap-2 items-center">
                        <input type="number" name="${f.id}" class="form-input ${customClass} flex-1" value="${fieldValue}"${f.readonly ? ' readonly' : ''}>
                        <div class="flex gap-1">
                            <!-- ปุ่มแรก: สีส้ม ข้อความ "B" -->
                            <button type="button" onclick="openAreaCalculator()" 
                                class="px-3 py-2 bg-orange-500 text-white rounded font-bold text-sm hover:bg-orange-600 transition"
                                title="คำนวณพื้นที่">
                                B
                            </button>
                            <!-- ปุ่มที่สอง: สีเขียว ไอคอนสามเหลี่ยม (Δ) -->
                            <button type="button" onclick="calculateDeltaArea()" 
                                class="px-3 py-2 bg-green-500 text-white rounded font-bold text-sm hover:bg-green-600 transition"
                                title="คำนวณผลต่าง">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M12 2L22 22H2L12 2z"></path>
                                </svg>
                            </button>
                        </div>
                    </div>
                    `;
                } else {
                    html += `<input type="${f.type}" name="${f.id}" class="form-input ${customClass}" value="${fieldValue}"${f.readonly ? ' readonly' : ''}>`;
                }
            } else {
                const customClass = f.customClass || '';
                html += `<input type="${f.type}" name="${f.id}" class="form-input ${customClass}" value="${fieldValue}"${f.readonly ? ' readonly' : ''}>`;
            }
                html += `</div>`;
            });
            
            form.innerHTML = html;
            // ✅ เพิ่มหลังจาก form.innerHTML = html; ในฟังก์ชัน openEditPanel()
            // ✅ วางโค้ดผูกเหตุการณ์ที่นี่ (หลัง form.innerHTML)
            // ✅ ผูกเหตุการณ์อัปเดตชื่อรูปภาพเมื่อเลือกไฟล์ใหม่ (วางหลัง form.innerHTML = html;)
            // ✅ ผูกเหตุการณ์อัปเดตชื่อรูปภาพ + สถานะการตรวจสอบเมื่อเลือกไฟล์ใหม่
            const fileInputs = form.querySelectorAll('input[type="file"]');
            fileInputs.forEach(input => {
                input.addEventListener('change', (e) => {
                    const fileId = input.id.replace('file-input-', '');
                    const fileNameBadge = document.getElementById(`filename-text-${fileId}`);
                    const checkSelect = form.querySelector('select[name="check"]'); // ดึงฟิลด์สถานะ
                    
                    if (e.target.files.length > 0) {
                        // สร้างชื่อไฟล์ใหม่
                        const file = e.target.files[0];
                        const prefix = type === 'building' ? 'B' : 'S';
                        const code = data.building_c || data.s_code || Date.now().toString().slice(-5);
                        const extension = file.name.split('.').pop().toLowerCase();
                        const fileName = `${prefix}${code}.${extension}`;
                        
                        // ✅ อัปเดตป้ายชื่อรูปภาพ
                        fileNameBadge.textContent = fileName;
                        
                        // ✅ อัปเดตสถานะการตรวจสอบทันที (ถ้าเป็น "ยังไม่สำรวจ")
                        if (checkSelect && checkSelect.value === 'ยังไม่สำรวจ') {
                            checkSelect.value = 'ถ่ายรูปแล้ว';
                            console.log('✅ สถานะเปลี่ยนเป็น: ถ่ายรูปแล้ว');
                        }
                        // ⚠️ ถ้าเป็น "ตรวจสอบแล้ว" → ไม่ทำอะไร (คงค่าเดิม)
                    } else {
                        fileNameBadge.textContent = 'ยังไม่มีรูปภาพ';
                    }
                });
            });

            // ✅ ผูกเหตุการณ์เมื่อเลือกค่าใน 'ประเภทสิ่งปลูกสร้าง' เพื่อตั้งค่าวัสดุและจำนวนชั้นตามเงื่อนไขใหม่
            if (type === 'building') {
                const bTypeSelect = document.querySelector('select[name="b_type"]');
                const bMatSelect = document.querySelector('select[name="b_mat"]');
                const noFloorSelect = document.querySelector('select[name="no_floor"]'); // ✅ เพิ่มบรรทัดนี้
                
                // ✅ ฟังก์ชันตั้งค่าจำนวนชั้นอัตโนมัติ
                const updateNoFloor = () => {
                    const selectedValue = bTypeSelect.value;
                    
                    // ✅ ตรวจสอบคำที่มีอยู่ในประเภทสิ่งปลูกสร้าง
                    if (selectedValue.includes('ชั้นเดียว')) {
                        noFloorSelect.value = '1';
                    } else if (selectedValue.includes('สองชั้น')) {
                        noFloorSelect.value = '2';
                    } else if (selectedValue.includes('สามชั้น')) {
                        noFloorSelect.value = '3';
                    } else if (selectedValue.includes('สี่ชั้น')) {
                        noFloorSelect.value = '4';
                    } else if (selectedValue.includes('ห้าชั้น')) {
                        noFloorSelect.value = '5';
                    } else if (selectedValue.includes('หกชั้น')) {
                        noFloorSelect.value = '6';
                    }
                    // ถ้าไม่ตรงเงื่อนไขใด ๆ → คงค่าเดิม (ไม่ล้างค่า)
                };
                
                if (bTypeSelect && bMatSelect && noFloorSelect) { // ✅ เพิ่มเงื่อนไขตรวจสอบ noFloorSelect
                    const updateBMat = () => {
                        const selectedValue = bTypeSelect.value;
                        // ✅ ตรวจสอบคำว่า "ครึ่งตึกครึ่งไม้" ก่อน (เพราะมีทั้ง "ตึก" และ "ไม้" ในคำเดียว)
                        if (selectedValue.includes('ครึ่งตึกครึ่งไม้')) {
                            bMatSelect.value = 'ตึก/ไม้'; // ครอบคลุมทุกรายการที่มีคำนี้
                        }
                        // ✅ ตรวจสอบคำว่า "ไม้" (ไม่รวมกรณีพิเศษเพราะตรวจสอบก่อนแล้ว)
                        else if (selectedValue.includes('ไม้')) {
                            bMatSelect.value = 'ไม้';
                        }
                        // ✅ ตรวจสอบคำว่า "ตึก" (ไม่รวมกรณีพิเศษ)
                        else if (selectedValue.includes('ตึก')) {
                            bMatSelect.value = 'ตึก';
                        }
                        // ถ้าไม่ตรงเงื่อนไขใด ๆ → คงค่าเดิม (ไม่ล้างค่า)
                    };
                    
                    // ผูกเหตุการณ์เมื่อเปลี่ยนค่าใน "ประเภทสิ่งปลูกสร้าง"
                    bTypeSelect.addEventListener('change', updateBMat);
                    bTypeSelect.addEventListener('change', updateNoFloor); // ✅ เพิ่มบรรทัดนี้
                    
                    // ตั้งค่าเริ่มต้นเมื่อเปิดแผง (ใช้ข้อมูลที่มีอยู่)
                    updateBMat();
                    updateNoFloor(); // ✅ เพิ่มบรรทัดนี้
                    
                    console.log('✅ ผูกเหตุการณ์ตั้งค่าวัสดุและจำนวนชั้นอัตโนมัติจากประเภทสิ่งปลูกสร้าง');
                }
            }

            // ✅ ผูกเหตุการณ์เมื่อเลือกค่าใน 'ประเภทสิ่งปลูกสร้าง' เพื่อตั้งค่าจำนวนชั้นตามเงื่อนไข
            if (type === 'building') {
                const bTypeSelect = document.querySelector('select[name="b_type"]');
                const noFloorSelect = document.querySelector('select[name="no_floor"]');
                if (bTypeSelect && noFloorSelect) {
                    const updateNoFloor = () => {
                        const selectedValue = bTypeSelect.value;
                        // ✅ ตรวจสอบคำว่า "ชั้นเดียว"
                        if (selectedValue.includes('ชั้นเดียว')) {
                            noFloorSelect.value = '1';
                        }
                        // ✅ ตรวจสอบคำว่า "สองชั้น"
                        else if (selectedValue.includes('สองชั้น')) {
                            noFloorSelect.value = '2';
                        }
                        // ✅ ตรวจสอบคำว่า "สามชั้น"
                        else if (selectedValue.includes('สามชั้น')) {
                            noFloorSelect.value = '3';
                        }
                        // ✅ ตรวจสอบคำว่า "สี่ชั้น"
                        else if (selectedValue.includes('สี่ชั้น')) {
                            noFloorSelect.value = '4';
                        }
                        // ✅ ตรวจสอบคำว่า "ห้าชั้น"
                        else if (selectedValue.includes('ห้าชั้น')) {
                            noFloorSelect.value = '5';
                        }
                        // ✅ ตรวจสอบคำว่า "หกชั้น"
                        else if (selectedValue.includes('หกชั้น')) {
                            noFloorSelect.value = '6';
                        }
                        // ถ้าไม่ตรงเงื่อนไขใด ๆ → คงค่าเดิม (ไม่ล้างค่า)
                    };
                    // ผูกเหตุการณ์เมื่อเปลี่ยนค่าใน "ประเภทสิ่งปลูกสร้าง"
                    bTypeSelect.addEventListener('change', updateNoFloor);
                    // ตั้งค่าเริ่มต้นเมื่อเปิดแผง (ใช้ข้อมูลที่มีอยู่)
                    updateNoFloor();
                    console.log('✅ ผูกเหตุการณ์ตั้งค่าจำนวนชั้นอัตโนมัติจากประเภทสิ่งปลูกสร้าง');
                }
            }

            // ✅ ผูกเหตุการณ์เมื่อเลือกค่าใน 'ใช้ทั้งหลัง' + อัปเดต "ชั้นที่ใช้", "พื้นที่ใช้" และ "ใช้ทั้งหลัง (2)" อัตโนมัติ
            if (type === 'building') {
                const fullAreaSelect = document.querySelector('select[name="full_area"]');
                const noFloorSelect = document.querySelector('select[name="no_floor"]');
                const buseFloorInput = document.querySelector('input[name="buse_floor"]');
                const bAreaInput = document.querySelector('input[name="b_area"]');
                const buseAreaInput = document.querySelector('input[name="buse_area"]');
                const fullArea2Select = document.querySelector('select[name="full_area2"]'); // ✅ เพิ่มการอ้างอิง
                
                if (fullAreaSelect && noFloorSelect && buseFloorInput && bAreaInput && buseAreaInput && fullArea2Select) {
                    // ฟังก์ชันอัปเดต "ชั้นที่ใช้" จาก "จำนวนชั้น" (เฉพาะเมื่อเลือก "เต็มพื้นที่")
                    const updateBuseFloor = () => {
                        if (fullAreaSelect.value === 'เต็มพื้นที่') {
                            const noFloorValue = noFloorSelect.value;
                            buseFloorInput.value = noFloorValue ? `1-${noFloorValue}` : '1-1';
                        }
                    };
                    
                    // ฟังก์ชันอัปเดต "พื้นที่ใช้" จาก "พื้นที่ทั้งหลัง" (เฉพาะเมื่อเลือก "เต็มพื้นที่")
                    const updateBuseArea = () => {
                        if (fullAreaSelect.value === 'เต็มพื้นที่') {
                            buseAreaInput.value = bAreaInput.value || '';
                        }
                    };
                    
                    // ✅ ฟังก์ชันตั้งค่า "ใช้ทั้งหลัง (2)" เมื่อเลือก "บางส่วน"
                    const syncFullArea2 = () => {
                        if (fullAreaSelect.value === 'บางส่วน' && !fullArea2Select.disabled) {
                            fullArea2Select.value = 'บางส่วน';
                        }
                    };
                    
                    // ฟังก์ชันจัดการกลุ่มที่ 2 (ล้างค่า + ปิดการแก้ไขเมื่อเลือก "เต็มพื้นที่")
                    const toggleGroup2 = () => {
                        const isFullArea = fullAreaSelect.value === 'เต็มพื้นที่';
                        
                        // รายการช่องในกลุ่มที่ 2 ที่ต้องล้างค่าและปิดการแก้ไข
                        const group2Fields = [
                            'b_use2', 'per_use2', 'buse_floor2', 'buse_area2', 'ment_use2'
                            // ❌ ไม่รวม 'full_area2' เพราะจัดการแยกต่างหาก
                        ];
                        
                        // จัดการช่องกลุ่มที่ 2 (ยกเว้น full_area2)
                        group2Fields.forEach(fieldId => {
                            const field = document.querySelector(`[name="${fieldId}"]`);
                            if (field) {
                                if (isFullArea) {
                                    field.value = '';
                                    field.disabled = true;
                                    field.style.backgroundColor = '#f3f4f6';
                                    field.style.cursor = 'not-allowed';
                                } else {
                                    field.disabled = false;
                                    field.style.backgroundColor = '';
                                    field.style.cursor = '';
                                }
                            }
                        });
                        
                        // ✅ จัดการ "ใช้ทั้งหลัง (2)" แยกต่างหาก
                        if (isFullArea) {
                            // ล้างค่าและปิดการแก้ไขเมื่อเลือก "เต็มพื้นที่"
                            fullArea2Select.value = '';
                            fullArea2Select.disabled = true;
                            fullArea2Select.style.backgroundColor = '#f3f4f6';
                            fullArea2Select.style.cursor = 'not-allowed';
                            
                            // ✅ ทริกเกอร์เหตุการณ์ change บน b_use2 เพื่ออัปเดต land_use ทันที
                            const bUse2Field = document.querySelector('select[name="b_use2"]');
                            if (bUse2Field) {
                                // ตั้งค่าเป็นว่างก่อน (เพื่อความชัดเจน)
                                bUse2Field.value = '';
                                // สร้างและส่งเหตุการณ์ change
                                const changeEvent = new Event('change', { bubbles: true });
                                bUse2Field.dispatchEvent(changeEvent);
                                console.log('✅ ทริกเกอร์ change event บน b_use2 เพื่ออัปเดต land_use');
                            }
                        } else {
                            // เปิดการแก้ไขเมื่อไม่ได้เลือก "เต็มพื้นที่"
                            fullArea2Select.disabled = false;
                            fullArea2Select.style.backgroundColor = '';
                            fullArea2Select.style.cursor = '';
                            
                            // ✅ ตั้งค่าเป็น "บางส่วน" ทันทีเมื่อเลือก "บางส่วน" ใน full_area
                            syncFullArea2();
                        }
                        
                        // อัปเดต "ชั้นที่ใช้" และ "พื้นที่ใช้"
                        updateBuseFloor();
                        updateBuseArea();
                    };
                    
                    // ผูกเหตุการณ์เมื่อเลือกค่าใน "ใช้ทั้งหลัง"
                    fullAreaSelect.addEventListener('change', toggleGroup2);
                    
                    // ผูกเหตุการณ์เมื่อเปลี่ยน "จำนวนชั้น"
                    noFloorSelect.addEventListener('change', updateBuseFloor);
                    
                    // ผูกเหตุการณ์เมื่อเปลี่ยน "พื้นที่ทั้งหลัง"
                    bAreaInput.addEventListener('input', updateBuseArea);
                    
                    // ✅ ผูกเหตุการณ์เพิ่มเติม: อัปเดต full_area2 เมื่อ full_area เปลี่ยนเป็น "บางส่วน"
                    fullAreaSelect.addEventListener('change', syncFullArea2);
                    
                    // ตั้งค่าเริ่มต้นเมื่อเปิดแผง
                    toggleGroup2();
                }
            }
            // ✅ คำนวณค่า "ใช้ประโยชน์ที่ดิน" อัตโนมัติ (เฉพาะสิ่งปลูกสร้าง)
            if (type === 'building') {
                const updateLandUse = () => {
                    const bUse = document.querySelector('select[name="b_use"]')?.value || '';
                    const bUse2 = document.querySelector('select[name="b_use2"]')?.value || '';
                    const landUseSelect = document.querySelector('select[name="land_use"]');
                    
                    if (!landUseSelect) return;
                    
                    let newValue = '';
                    
                    // เงื่อนไขการคำนวณ
                    if (bUse && bUse2) {
                        newValue = '5-ใช้ประโยชน์หลายประเภท'; // ทั้งสองช่องมีค่า
                    } else if (bUse) {
                        newValue = bUse; // มีค่าจาก b_use เท่านั้น
                    } else if (bUse2) {
                        newValue = bUse2; // มีค่าจาก b_use2 เท่านั้น
                    }
                    
                    // ตั้งค่าและปิดการแก้ไข
                    landUseSelect.value = newValue;
                    landUseSelect.disabled = true; // ป้องกันการแก้ไข
                    landUseSelect.style.backgroundColor = '#f3f4f6'; // สีพื้นหลังเทาอ่อน
                    landUseSelect.style.cursor = 'not-allowed';
                };
                
                // ผูกเหตุการณ์เมื่อเลือกค่า
                const bUseSelect = document.querySelector('select[name="b_use"]');
                const bUse2Select = document.querySelector('select[name="b_use2"]');
                
                if (bUseSelect && bUse2Select) {
                    bUseSelect.addEventListener('change', updateLandUse);
                    bUse2Select.addEventListener('change', updateLandUse);
                    
                    // ตั้งค่าเริ่มต้น
                    updateLandUse();
                }
            }
            // ✅ เชื่อมโยงค่าจาก 'b_note' ไปยัง 'ment_use' และ 'ment_use2' (อัปเดตทุกครั้งที่ b_note เปลี่ยน)
            if (type === 'building') {
                const bNoteInput = document.querySelector('input[name="b_note"]');
                const mentUseInput = document.querySelector('input[name="ment_use"]');
                const mentUse2Input = document.querySelector('input[name="ment_use2"]');
                
                if (bNoteInput && mentUseInput && mentUse2Input) {
                    // ✅ ฟังก์ชันอัปเดตจาก b_note (ทุกครั้งที่เปลี่ยน)
                    const syncFromBNote = () => {
                        const value = bNoteInput.value;
                        
                        // ✅ อัปเดต ment_use เสมอ ไม่มีเงื่อนไข ไม่มีข้อยกเว้น
                        mentUseInput.value = value;
                        console.log(`🔄 b_note เปลี่ยน → ment_use = "${value}"`);
                        
                        // ✅ อัปเดต ment_use2 เฉพาะเมื่อเปิดการแก้ไขอยู่ (ตรวจสอบสถานะปัจจุบันทุกครั้ง)
                        if (!mentUse2Input.disabled) {
                            mentUse2Input.value = value;
                            console.log(`🔄 b_note เปลี่ยน → ment_use2 = "${value}" (เปิดการแก้ไขอยู่)`);
                        } else {
                            console.log(`⏭️ b_note เปลี่ยน แต่ ment_use2 ถูกปิดการแก้ไข → ไม่อัปเดต`);
                        }
                    };
                    
                    // ✅ ใช้เหตุการณ์ 'change' (เมื่อผู้ใช้เสร็จสิ้นการแก้ไข)
                    bNoteInput.addEventListener('change', syncFromBNote);
                    
                    // ✅ ตั้งค่าเริ่มต้นเมื่อเปิดแผง
                    // syncFromBNote();
                    
                    console.log('✅ เชื่อมโยง b_note → ment_use (ทุกครั้งที่เปลี่ยน) + ment_use2 (ถ้าเปิดการแก้ไข)');
                } else {
                    console.warn('⚠️ ไม่พบฟิลด์ b_note, ment_use หรือ ment_use2');
                }
            }
            if (type === 'sign') {
                // ฟังก์ชันอัปเดตค่า s_characte อัตโนมัติ
                const updateSCharacte = () => {
                    const contentTypeEl = document.querySelector('select[name="content_type_temp"]');
                    const signTypeDetailEl = document.querySelector('select[name="sign_type_detail_temp"]');
                    const sCharacteEl = document.querySelector('input[name="s_characte"]');
                    
                    if (!contentTypeEl || !signTypeDetailEl || !sCharacteEl) return;
                    
                    const num = contentTypeEl.value.charAt(0); // ดึงเลขหน้าสุด (1, 2, 3, 4)
                    const letterMatch = signTypeDetailEl.value.match(/\(([^)]+)\)/); // ดึงตัวอักษรในวงเล็บ
                    const letter = letterMatch ? letterMatch[1].charAt(0) : ''; // เอาแค่ตัวแรก (ก หรือ ข)
                    
                    sCharacteEl.value = num && letter ? `${num}(${letter})` : '-';
                };
                
                // ผูกเหตุการณ์เมื่อเลือกค่า
                const contentTypeEl = document.querySelector('select[name="content_type_temp"]');
                const signTypeDetailEl = document.querySelector('select[name="sign_type_detail_temp"]');
                
                if (contentTypeEl && signTypeDetailEl) {
                    contentTypeEl.addEventListener('change', updateSCharacte);
                    signTypeDetailEl.addEventListener('change', updateSCharacte);
                    
                    // ตั้งค่าเริ่มต้นจากข้อมูลเดิม (ถ้ามี)
                    if (data.s_characte) {
                        const match = data.s_characte.match(/^(\d)\(([^)]+)\)$/);
                        if (match) {
                            const num = match[1];
                            const letter = match[2];
                            
                            // ตั้งค่าลักษณะเนื้อหา
                            for (let opt of contentTypeEl.options) {
                                if (opt.value.startsWith(`${num}.`)) {
                                    contentTypeEl.value = opt.value;
                                    break;
                                }
                            }
                            
                            // ตั้งค่าลักษณะตัวป้าย
                            for (let opt of signTypeDetailEl.options) {
                                if (opt.value.includes(`(${letter})`)) {
                                    signTypeDetailEl.value = opt.value;
                                    break;
                                }
                            }
                        }
                    }
                    
                    // อัปเดตค่าเริ่มต้น
                    updateSCharacte();
                }
            }

            // ✅ ตรวจสอบว่าหน้าต่างรูปภาพเปิดอยู่หรือไม่ → อัปเดตรูปภาพอัตโนมัติ
            const imagePreviewContainer = document.getElementById('image-preview-container');
            if (imagePreviewContainer && imagePreviewContainer.style.display === 'flex') {
                console.log('🖼️ หน้าต่างรูปภาพเปิดอยู่ → อัปเดตรูปภาพใหม่');
                if (data.image && data.image.trim() !== '') {
                    showImagePreview(data.image, data.picture || 'รูปภาพ');
                } else {
                    // ถ้าไม่มีรูปภาพ → แสดงข้อความในหน้าต่างรูปภาพแทนการซ่อน
                    const placeholder = document.getElementById('image-preview-placeholder');
                    const img = document.getElementById('image-preview');
                    if (placeholder && img) {
                        img.classList.add('hidden');
                        placeholder.textContent = '⚠️ รายการนี้ยังไม่มีรูปภาพ';
                        placeholder.classList.remove('text-gray-300');
                        placeholder.classList.add('text-yellow-500', 'font-medium');
                    }
                }
            }

            document.getElementById('side-panel').classList.add('open');
            marker.closePopup();
        }

        function closePanel() {
            const panel = document.getElementById('side-panel');
            if (panel) {
                panel.classList.remove('open');
            }
            // ✅ ซ่อนรูปภาพเมื่อปิดแผง (ยังคงต้องการ)
            // hideImagePreview();
        }


        function locateUser() { 
            map.locate({setView: true, maxZoom: 18}); 
            map.once('locationfound', (e) => {
                L.circleMarker(e.latlng, { radius: 8, fillColor: '#2563eb', color: '#fff', weight: 3, fillOpacity: 0.9 }).addTo(map);
            });
        }
        // ตัวแปรเก็บข้อมูลสำหรับการลบ
        let deleteMarkerData = null;
        let deleteMarkerType = null;
        let deleteMarkerRef = null;

        // เปิดหน้าต่างยืนยันการลบ
        function showDeleteConfirm(marker, data, type) {
            deleteMarkerRef = marker;
            deleteMarkerData = data;
            deleteMarkerType = type;
            
            const title = document.getElementById('delete-modal-title');
            const message = document.getElementById('delete-modal-message');
            
            if (type === 'building') {
                title.textContent = 'ลบสิ่งปลูกสร้าง';
                message.textContent = 'คุณแน่ใจว่าต้องการลบสิ่งปลูกสร้างนี้? การกระทำนี้ไม่สามารถยกเลิกได้';
            } else {
                title.textContent = 'ลบป้าย';
                message.textContent = 'คุณแน่ใจว่าต้องการลบป้ายนี้? การกระทำนี้ไม่สามารถยกเลิกได้';
            }
            
            document.getElementById('confirm-delete-modal').classList.remove('hidden');
            document.getElementById('confirm-delete-modal').classList.add('flex');
        }

        // ปิดหน้าต่างยืนยันการลบ
        function cancelDelete() {
            document.getElementById('confirm-delete-modal').classList.add('hidden');
            deleteMarkerData = null;
            deleteMarkerType = null;
            deleteMarkerRef = null;
        }

        // ยืนยันการลบ
        async function confirmDeleteAction() {
            if (!deleteMarkerRef || !deleteMarkerData || !deleteMarkerType) {
                cancelDelete();
                return;
            }
            
            // ปิดหน้าต่างยืนยัน
            document.getElementById('confirm-delete-modal').classList.add('hidden');
            
            try {
                await deleteMarker(deleteMarkerRef, deleteMarkerData, deleteMarkerType);
            } catch (err) {
                console.error("Error in delete action:", err);
            } finally {
                cancelDelete();
            }
        }

        // เปิดหน้าต่างโหมดแก้ไข
        function showEditModeModal() {
            document.getElementById('edit-mode-modal').classList.remove('hidden');
            document.getElementById('edit-mode-modal').classList.add('flex');
            
            // ปิดอัตโนมัติหลัง 3 วินาที
            setTimeout(() => {
                closeEditModeModal();
            }, 4000);
        }

        // ปิดหน้าต่างโหมดแก้ไข
        function closeEditModeModal() {
            document.getElementById('edit-mode-modal').classList.add('hidden');
        }

        // ฟังก์ชันสำหรับแสดง/ซ่อนตาราง
        function toggleTable() {
            const panel = document.getElementById('data-table-panel');
            const imagePreview = document.getElementById('image-preview-container');
            const btn = document.getElementById('btn-show-table');
            
            panel.classList.toggle('open');
            
            // ✅ จัดการตำแหน่งองค์ประกอบแสดงรูปภาพตามสถานะของตาราง
            if (panel.classList.contains('open')) {
                // เปิดตาราง → ย้ายรูปภาพขึ้นเหนือตาราง
                if (imagePreview && imagePreview.style.display !== 'none') {
                    imagePreview.style.bottom = `calc(5px + 45vh + 10px)`;
                }
                btn.innerHTML = '<i data-lucide="x" class="w-6 h-6 text-red-600"></i>';
            } else {
                // ปิดตาราง → ย้ายรูปภาพกลับมาที่ตำแหน่งเดิม (แทนที่ตาราง)
                if (imagePreview && imagePreview.style.display !== 'none') {
                    imagePreview.style.bottom = '5px';
                }
                btn.innerHTML = '<i data-lucide="table" class="w-6 h-6 text-blue-600"></i>';
            }
            
            lucide.createIcons();
        }

        // ฟังก์ชันสลับแท็บตาราง
        function switchTableTab(type) {
            // เปลี่ยนแท็บ
            document.querySelectorAll('.table-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // แสดงตารางที่เลือก
            document.getElementById('building-table-container').classList.toggle('hidden', type !== 'building');
            document.getElementById('sign-table-container').classList.toggle('hidden', type !== 'sign');
        }

        // ฟังก์ชันซูมไปที่ตำแหน่ง
        function zoomToLocation(latlng, zoomLevel = 18) {
            map.setView(latlng, zoomLevel);
            
            // สร้างเอฟเฟกต์กระพริบ
            const blinkMarker = L.circleMarker(latlng, {
                radius: 15,
                fillColor: '#22d3ee',
                color: '#fff',
                weight: 3,
                fillOpacity: 0.8,
                opacity: 1
            }).addTo(map);
            
            // กระพริบ 3 ครั้ง
            let count = 0;
            const blinkInterval = setInterval(() => {
                blinkMarker.setStyle({
                    opacity: blinkMarker.options.opacity === 1 ? 0 : 1,
                    fillOpacity: blinkMarker.options.fillOpacity === 0.8 ? 0 : 0.8
                });
                count++;
                if (count >= 6) {
                    clearInterval(blinkInterval);
                    map.removeLayer(blinkMarker);
                }
            }, 300);
        }

        // ฟังก์ชันสร้างแถวข้อมูลสิ่งปลูกสร้าง
        function renderBuildingTable() {
            const tbody = document.getElementById('building-table-body');
            
            if (!allBuildings || allBuildings.length === 0) {
                tbody.innerHTML = '<tr><td colspan="15" class="text-center py-8 text-gray-500">ไม่มีข้อมูลสิ่งปลูกสร้าง</td></tr>';
                return;
            }
            
            // ✅ เรียงข้อมูลตาม ID (เรียงจากน้อยไปมากตามลำดับอักขระ)
            const sortedBuildings = sortBuildings(allBuildings, buildingSortColumn, buildingSortDirection);

            tbody.innerHTML = sortedBuildings.map(building => {
                if (!building.lat_long) return '';
                
                const [lat, lng] = building.lat_long.split(',').map(Number);
                if (isNaN(lat) || isNaN(lng)) return '';
                
                // ✅ กำหนดสีสถานะการตรวจสอบ
                let statusClass = 'status-ยังไม่สำรวจ';
                let statusText = building.check || 'ยังไม่สำรวจ';
                
                if (building.check === 'ถ่ายรูปแล้ว') {
                    statusClass = 'status-ถ่ายรูปแล้ว';
                } else if (building.check === 'ตรวจสอบแล้ว') {
                    statusClass = 'status-ตรวจสอบแล้ว';
                }
                
                // ✅ ฟังก์ชันช่วยแสดงค่า (ถ้าไม่มีให้แสดง "-")
                const displayValue = (val) => val && val.toString().trim() !== '' ? val : '-';
                
                return `
                    <tr>
                        <td><span class="marker-icon marker-building"></span></td>
                        <td class="font-medium">${displayValue(building.building_c)}</td>
                        <td>${displayValue(building.full_name)}</td>
                        <td class="text-center">${displayValue(building.hs_no)}</td>
                        <td class="text-center">${displayValue(building.hs_moo)}</td>
                        <td>${displayValue(building.b_type)}</td>
                        <td class="text-center">${displayValue(building.b_mat)}</td>
                        <td class="text-center">${displayValue(building.no_floor)}</td>
                        <td class="text-center">${displayValue(building.b_area)}</td>
                        <td class="text-center">${displayValue(building.b_year)}</td>
                        <td>${displayValue(building.b_note)}</td>
                        <td>${displayValue(building.b_use)}</td>
                        <td>${displayValue(building.b_use2)}</td>
                        <td>${displayValue(building.land_use)}</td>
                        <td><span class="status-badge ${statusClass}">${statusText}</span></td>
                        <td>
                            <button class="zoom-btn" onclick="zoomToLocation(L.latLng(${lat}, ${lng}))">
                                <i data-lucide="locate" class="w-3 h-3 inline"></i>
                            </button>
                        </td>
                    </tr>
                `;
            }).join('');
            // ✅ อัปเดตจำนวนที่หัวตาราง
            updateTableCounters();

            // ✅ สร้างไอคอนหลังเรนเดอร์ตารางเสร็จ
            lucide.createIcons();
        }

        // อัปเดตจำนวนสิ่งปลูกสร้างและป้ายที่หัวตาราง
        function updateTableCounters() {
            const buildingCount = allBuildings ? allBuildings.length : 0;
            const signCount = allSigns ? allSigns.length : 0;
            
            const buildingBadge = document.getElementById('building-count-badge');
            const signBadge = document.getElementById('sign-count-badge');
            
            if (buildingBadge) {
                buildingBadge.textContent = buildingCount;
            }
            
            if (signBadge) {
                signBadge.textContent = signCount;
            }
            
            console.log(`📊 จำนวนสิ่งปลูกสร้าง: ${buildingCount}, จำนวนป้าย: ${signCount}`);
        }

        // ============================================
        // ฟังก์ชันเมนูฟันเฟือง
        // ============================================

        /**
         * เปิด/ปิดเมนูฟันเฟือง
         */
        function toggleSettingsMenu() {
          const menu = document.getElementById('settings-menu');
          const icon = document.getElementById('settings-icon');
          const badge = document.getElementById('settings-badge');
          
          if (menu.classList.contains('hidden')) {
            // เปิดเมนู - ปุ่มย่อยเลื่อนลงมาทีละปุ่ม
            menu.classList.remove('hidden');
            icon.classList.add('animate-spin');
            
            // ซ่อนจุดแจ้งเตือน (ถ้ามี)
            badge.classList.add('hidden');
            
            // แอนิเมชันเลื่อนลงมาทีละปุ่ม
            setTimeout(() => {
              const buttons = menu.querySelectorAll('button');
              buttons.forEach((btn, index) => {
                setTimeout(() => {
                  btn.style.transform = 'translateY(0)';
                  btn.style.opacity = '1';
                }, index * 100);
              });
            }, 100);
            
            // ปิดเมนูอัตโนมัติเมื่อคลิกที่อื่น
            setTimeout(() => {
              document.addEventListener('click', closeSettingsMenuOnClickOutside);
            }, 100);
            
          } else {
            // ปิดเมนู
            closeSettingsMenu();
          }
        }

        /**
         * ปิดเมนูเมื่อคลิกที่อื่น
         */
        function closeSettingsMenuOnClickOutside(e) {
          const settingsBtn = document.getElementById('btn-settings');
          const settingsMenu = document.getElementById('settings-menu');
          
          if (!settingsBtn.contains(e.target) && !settingsMenu.contains(e.target)) {
            closeSettingsMenu();
            document.removeEventListener('click', closeSettingsMenuOnClickOutside);
          }
        }

        /**
         * ปิดเมนู
         */
        function closeSettingsMenu() {
          const menu = document.getElementById('settings-menu');
          const icon = document.getElementById('settings-icon');
          
          // แอนิเมชันเลื่อนขึ้นไป
          const buttons = menu.querySelectorAll('button');
          buttons.forEach((btn, index) => {
            setTimeout(() => {
              btn.style.transform = 'translateY(-20px)';
              btn.style.opacity = '0';
            }, (buttons.length - index - 1) * 50);
          });
          
          setTimeout(() => {
            menu.classList.add('hidden');
            icon.classList.remove('animate-spin');
          }, buttons.length * 50 + 100);
        }

        /**
         * ปุ่ม 1: ส่งออกแผนที่สิ่งปลูกสร้าง (GeoJSON)
         */
        async function exportBuildingGeoJSON() {
          closeSettingsMenu();
          
          // แสดงข้อความแจ้งเตือน
          showNotificationLeft('กำลังเตรียมข้อมูลสิ่งปลูกสร้าง...', 'info');
          
          try {
            // ดึงข้อมูลจากเซิร์ฟเวอร์
            const res = await fetch(`${CONFIG.SCRIPT_URL}?action=exportGeoJSON&type=building`);
            const geojsonData = await res.json();
            
            if (geojsonData.type === 'FeatureCollection') {
              // สร้าง Blob และดาวน์โหลดไฟล์
              const blob = new Blob([JSON.stringify(geojsonData, null, 2)], { 
                type: 'application/geo+json' 
              });
              
              const url = window.URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              a.download = `buildings_${new Date().toISOString().slice(0,10)}.geojson`;
              document.body.appendChild(a);
              a.click();
              window.URL.revokeObjectURL(url);
              document.body.removeChild(a);
              
              showNotificationLeft('ดาวน์โหลดไฟล์สิ่งปลูกสร้างสำเร็จ!', 'success');
            } else {
              throw new Error('ข้อมูลไม่ถูกต้อง');
            }
          } catch (err) {
            console.error('Error exporting buildings:', err);
            showNotificationLeft('เกิดข้อผิดพลาดในการส่งออกข้อมูล', 'error');
          }
        }

        /**
         * ปุ่ม 2: ส่งออกแผนที่ป้าย (GeoJSON)
         */
        async function exportSignGeoJSON() {
          closeSettingsMenu();
          
          showNotificationLeft('กำลังเตรียมข้อมูลป้าย...', 'info');
          
          try {
            const res = await fetch(`${CONFIG.SCRIPT_URL}?action=exportGeoJSON&type=sign`);
            const geojsonData = await res.json();
            
            if (geojsonData.type === 'FeatureCollection') {
              const blob = new Blob([JSON.stringify(geojsonData, null, 2)], { 
                type: 'application/geo+json' 
              });
              
              const url = window.URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              a.download = `signs_${new Date().toISOString().slice(0,10)}.geojson`;
              document.body.appendChild(a);
              a.click();
              window.URL.revokeObjectURL(url);
              document.body.removeChild(a);
              
              showNotificationLeft('ดาวน์โหลดไฟล์ป้ายสำเร็จ!', 'success');
            } else {
              throw new Error('ข้อมูลไม่ถูกต้อง');
            }
          } catch (err) {
            console.error('Error exporting signs:', err);
            showNotificationLeft('เกิดข้อผิดพลาดในการส่งออกข้อมูล', 'error');
          }
        }

        /**
         * ปุ่ม 3: โหลดรูปสิ่งปลูกสร้างจากโฟลเดอร์ Google Drive
         */
        async function loadBuildingImages() {
          closeSettingsMenu();
          
          showNotificationLeft('กำลังโหลดรูปภาพสิ่งปลูกสร้าง...', 'info');
          
          try {
            // ดึงข้อมูลสิ่งปลูกสร้างทั้งหมด
            const res = await fetch(`${CONFIG.SCRIPT_URL}?action=getData`);
            const data = await res.json();
            const buildings = data.buildings || [];
            
            // กรองเฉพาะที่มีรูปภาพ
            const buildingsWithImages = buildings.filter(b => b.image && b.image.trim() !== '');
            
            if (buildingsWithImages.length === 0) {
              showNotificationLeft('ไม่พบรูปภาพสิ่งปลูกสร้าง', 'warning');
              return;
            }
            
            // แสดงแกลเลอรี่รูปภาพ
            showImageGallery(buildingsWithImages, 'building');
            
          } catch (err) {
            console.error('Error loading building images:', err);
            showNotificationLeft('เกิดข้อผิดพลาดในการโหลดรูปภาพ', 'error');
          }
        }

        /**
         * ปุ่ม 4: โหลดรูปป้ายจากโฟลเดอร์ Google Drive
         */
        async function loadSignImages() {
          closeSettingsMenu();
          
          showNotificationLeft('กำลังโหลดรูปภาพป้าย...', 'info');
          
          try {
            const res = await fetch(`${CONFIG.SCRIPT_URL}?action=getData`);
            const data = await res.json();
            const signs = data.signs || [];
            
            const signsWithImages = signs.filter(s => s.picture && s.picture.trim() !== '');
            
            if (signsWithImages.length === 0) {
              showNotificationLeft('ไม่พบรูปภาพป้าย', 'warning');
              return;
            }
            
            showImageGallery(signsWithImages, 'sign');
            
          } catch (err) {
            console.error('Error loading sign images:', err);
            showNotificationLeft('เกิดข้อผิดพลาดในการโหลดรูปภาพ', 'error');
          }
        }

        /**
         * แสดงแกลเลอรี่รูปภาพ - เวอร์ชันแก้ไข
         */
        function showImageGallery(items, type) {
            // ✅ ข้อ 1: กรองเฉพาะรูปที่มีลิ้งค์
            const filteredItems = items.filter(item => {
                if (type === 'building') {
                    return item.image && item.image.trim() !== '';
                } else {
                    return item.picture && item.picture.trim() !== '';
                }
            });
            
            if (filteredItems.length === 0) {
                showNotificationLeft('ไม่พบรูปภาพที่มีลิ้งค์', 'warning');
                return;
            }
            
            // สร้างหน้าต่างแกลเลอรี่
            const galleryDiv = document.createElement('div');
            galleryDiv.id = 'image-gallery-modal';
            galleryDiv.className = 'fixed inset-0 bg-black/90 z-[3000] flex flex-col p-4 overflow-hidden';
            
            // ✅ ค่าเริ่มต้น: แสดงเป็นรายชื่อ
            let isGridView = false;
            
            galleryDiv.innerHTML = `
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-white text-xl font-bold">
                    ${type === 'building' ? 'รูปภาพสิ่งปลูกสร้าง' : 'รูปภาพป้าย'} (${filteredItems.length} รูป)
                </h3>
                <div class="flex gap-2">
                    <!-- ✅ ปุ่มสลับมุมมอง (ค่าเริ่มต้น: แสดงเป็นภาพ) -->
                    <button onclick="toggleGalleryView()" id="btn-toggle-view" class="bg-gray-700 text-white px-4 py-2 rounded-lg hover:bg-gray-600 transition flex items-center gap-2">
                        <i data-lucide="grid" id="view-icon" class="w-4 h-4"></i>
                        <span id="view-text">แสดงเป็นภาพ</span>
                    </button>
                    <!-- ✅ ปุ่มดาวน์โหลดทั้งหมด -->
                    <button onclick="downloadAllImagesAsZip()" class="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition flex items-center gap-2">
                        <i data-lucide="download" class="w-4 h-4"></i>
                        <span>ดาวน์โหลดทั้งหมด</span>
                    </button>
                    <button onclick="closeImageGallery()" class="text-white hover:text-gray-300 transition">
                        <i data-lucide="x" class="w-8 h-8"></i>
                    </button>
                </div>
            </div>
            <!-- ✅ คอนเทนเนอร์สำหรับสลับมุมมอง -->
            <div id="gallery-container" class="flex-1 overflow-y-auto">
                <!-- จะถูกแทนที่ด้วยฟังก์ชัน toggleGalleryView() -->
            </div>
            `;
            
            document.body.appendChild(galleryDiv);
            lucide.createIcons();
            
            // ✅ เริ่มต้นด้วยมุมมองรายชื่อ
            renderGalleryListView(filteredItems, type);
        }

        // ✅ ประกาศตัวแปรสำหรับเก็บสถานะมุมมองและข้อมูลปัจจุบัน
        let currentGalleryItems = [];
        let currentGalleryType = '';
        let isGridView = false; // ✅ ค่าเริ่มต้น: false = แสดงเป็นรายชื่อ

        /**
         * ✅ ฟังก์ชันสลับระหว่างมุมมองภาพตัวอย่างกับรายชื่อ
         */
        function toggleGalleryView() {
            isGridView = !isGridView;
            
            const btn = document.getElementById('btn-toggle-view');
            const icon = document.getElementById('view-icon');
            const text = document.getElementById('view-text');
            
            if (isGridView) {
                // สลับไปมุมมองภาพตัวอย่าง
                btn.className = 'bg-gray-700 text-white px-4 py-2 rounded-lg hover:bg-gray-600 transition flex items-center gap-2';
                icon.innerHTML = '<i data-lucide="list" class="w-4 h-4"></i>';
                text.textContent = 'แสดงเป็นรายชื่อ';
                renderGalleryGridView(currentGalleryItems, currentGalleryType);
            } else {
                // สลับไปมุมมองรายชื่อ
                btn.className = 'bg-gray-700 text-white px-4 py-2 rounded-lg hover:bg-gray-600 transition flex items-center gap-2';
                icon.innerHTML = '<i data-lucide="grid" class="w-4 h-4"></i>';
                text.textContent = 'แสดงเป็นภาพ';
                renderGalleryListView(currentGalleryItems, currentGalleryType);
            }
            
            lucide.createIcons();
        }

        /**
         * ✅ แสดงมุมมองภาพตัวอย่าง (Grid View)
         */
        function renderGalleryGridView(items, type) {
            currentGalleryItems = items;
            currentGalleryType = type;
            
            const container = document.getElementById('gallery-container');
            
            container.innerHTML = `
            <div id="gallery-grid" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3">
                ${items.map((item, index) => `
                <div class="relative group cursor-pointer" onclick="openImageViewer(${index}, '${type}')">
                    <img src="${type === 'building' ? item.image : item.picture}"
                        alt="รูปภาพ ${index + 1}"
                        class="w-full h-32 object-cover rounded-lg hover:opacity-75 transition"
                        onerror="this.src='https://via.placeholder.com/150?text=No+Image'">
                    <div class="absolute inset-0 bg-black/50 opacity-0 group-hover:opacity-100 transition-opacity rounded-lg flex items-center justify-center">
                        <span class="text-white text-sm font-bold">ดูรูปใหญ่</span>
                    </div>
                    <div class="mt-1 text-xs text-white truncate">
                        ${type === 'building' ? (item.building_c || item.full_name || '-') : (item.s_code || item.s_name || '-')}
                    </div>
                </div>
                `).join('')}
            </div>
            `;
            
            lucide.createIcons();
        }

        /**
         * ✅ แสดงมุมมองรายชื่อ (List View)
         */
        function renderGalleryListView(items, type) {
            currentGalleryItems = items;
            currentGalleryType = type;
            
            const container = document.getElementById('gallery-container');
            
            container.innerHTML = `
            <div class="bg-gray-800 rounded-lg overflow-hidden">
                <div class="grid grid-cols-[40px_1fr_120px_80px] gap-2 p-3 bg-gray-700 text-white font-bold text-sm">
                    <span>#</span>
                    <span>ชื่อ</span>
                    <span>ขนาด</span>
                    <span>ดาวน์โหลด</span>
                </div>
                <div class="max-h-[calc(100vh-150px)] overflow-y-auto">
                    ${items.map((item, index) => `
                    <div class="grid grid-cols-[40px_1fr_120px_80px] gap-2 p-3 border-b border-gray-700 hover:bg-gray-700/50 transition cursor-pointer" onclick="openImageViewer(${index}, '${type}')">
                        <span class="text-gray-400 text-sm">${index + 1}</span>
                        <div class="flex items-center gap-2">
                            <i data-lucide="image" class="w-4 h-4 text-blue-400"></i>
                            <span class="text-white truncate">
                                ${type === 'building' ? (item.building_c || item.full_name || '-') : (item.s_code || item.s_name || '-')}
                            </span>
                        </div>
                        <span class="text-gray-400 text-xs">-</span>
                        <button onclick="event.stopPropagation(); downloadSingleImage('${type === 'building' ? item.image : item.picture}', '${type === 'building' ? (item.building_c || 'building') : (item.s_code || 'sign')}')" 
                            class="bg-blue-600 text-white px-2 py-1 rounded hover:bg-blue-700 transition text-xs flex items-center justify-center gap-1">
                            <i data-lucide="download" class="w-3 h-3"></i>
                        </button>
                    </div>
                    `).join('')}
                </div>
            </div>
            `;
            
            lucide.createIcons();
        }

        /**
         * ✅ ดาวน์โหลดรูปภาพเดียว
         */
        function downloadSingleImage(url, filename) {
            const link = document.createElement('a');
            link.href = url;
            link.download = `${filename}_${Date.now()}.jpg`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            showNotificationLeft(`ดาวน์โหลด ${filename} สำเร็จ!`, 'success');
        }

        // ============================================
        // ดาวน์โหลดรูปทั้งหมดเป็นไฟล์เดียว (ใช้ JSZip) - เวอร์ชันแก้ไขแล้ว
        // ============================================
        async function downloadAllImagesAsZip() {
            showNotificationLeft('กำลังเตรียมดาวน์โหลด...', 'info');
            
            try {
                const galleryGrid = document.getElementById('gallery-grid');
                if (!galleryGrid) {
                    showNotificationLeft('❌ ไม่พบข้อมูลรูปภาพ', 'error');
                    return;
                }
                
                const items = [];
                const type = document.querySelector('#image-gallery-modal h3')?.innerText.includes('สิ่งปลูกสร้าง') ? 'building' : 'sign';
                
                galleryGrid.querySelectorAll('.relative.group').forEach((el, index) => {
                    const img = el.querySelector('img');
                    const url = img?.src;
                    const codeEl = el.querySelector('p.font-bold');
                    const codeText = codeEl?.innerText || '';
                    const code = codeText.replace(/[^0-9]/g, '');
                    
                    // ✅ แก้ไข: ลบช่องว่างพิเศษในสตริงตรวจสอบ
                    if (url && url !== 'https://via.placeholder.com/150?text=No+Image') {
                        items.push({
                            url: url,
                            filename: `${type === 'building' ? 'B' : 'S'}${code || index + 1}.jpg`
                        });
                    }
                });
                
                if (items.length === 0) {
                    showNotificationLeft('⚠️ ไม่พบรูปภาพให้ดาวน์โหลด', 'warning');
                    return;
                }
                
                showNotificationLeft(`กำลังดาวน์โหลด ${items.length} รูป...`, 'info');
                
                // ✅ แก้ไข: ลบช่องว่างพิเศษใน URL JSZip
                if (typeof JSZip === 'undefined') {
                    await new Promise((resolve, reject) => {
                        const script = document.createElement('script');
                        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js'; // ✅ ลบช่องว่าง
                        script.onload = resolve;
                        script.onerror = () => reject(new Error('Failed to load JSZip'));
                        document.head.appendChild(script);
                    });
                }
                
                const zip = new JSZip();
                const folder = zip.folder(type === 'building' ? 'buildings' : 'signs');
                let successCount = 0;
                
                for (let i = 0; i < items.length; i++) {
                    const item = items[i];
                    try {
                        const response = await fetch(item.url);
                        if (!response.ok) throw new Error(`HTTP ${response.status}`);
                        
                        const blob = await response.blob();
                        folder.file(item.filename, blob);
                        successCount++;
                        
                        if ((i + 1) % 5 === 0 || i === items.length - 1) {
                            showNotificationLeft(`กำลังดาวน์โหลด (${successCount}/${items.length})...`, 'info');
                        }
                    } catch (err) {
                        console.error(`ดาวน์โหลด ${item.filename} ล้มเหลว:`, err);
                    }
                }
                
                if (successCount === 0) {
                    showNotificationLeft('❌ ดาวน์โหลดรูปภาพล้มเหลวทั้งหมด', 'error');
                    return;
                }
                
                const content = await zip.generateAsync({ type: 'blob' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(content);
                link.download = `${type === 'building' ? 'buildings' : 'signs'}_${new Date().toISOString().slice(0, 10)}.zip`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href);
                
                showNotificationLeft(`✅ ดาวน์โหลดรูปภาพทั้งหมด (${successCount} รูป) เสร็จสิ้น!`, 'success');
            } catch (err) {
                console.error('ข้อผิดพลาด:', err);
                showNotificationLeft('❌ ดาวน์โหลดล้มเหลว: ' + err.message, 'error');
            }
        }

        /**
         * เปิดดูรูปภาพขนาดใหญ่ - เวอร์ชันแก้ไข
         */
        function openImageViewer(index, type) {
            const items = currentGalleryItems;
            const item = items[index];
            
            if (!item) return;
            
            // สร้างหน้าต่างดูรูปใหญ่
            const viewerDiv = document.createElement('div');
            viewerDiv.id = 'image-viewer-modal';
            viewerDiv.className = 'fixed inset-0 bg-black/95 z-[3001] flex items-center justify-center p-4';
            viewerDiv.onclick = (e) => {
                if (e.target === viewerDiv) closeImageViewer();
            };
            
            // ✅ ใช้ลิ้งค์ที่ถูกต้องตามประเภท
            const imageUrl = type === 'building' ? item.image : item.picture;
            const code = type === 'building' ? item.building_c : item.s_code;
            const name = type === 'building' ? item.full_name : item.s_name;
            const address = type === 'building' ? item.address : item.comment;
            
            viewerDiv.innerHTML = `
            <div class="relative max-w-4xl w-full">
                <img src="${imageUrl}"
                    alt="รูปภาพ"
                    class="w-full max-h-[80vh] object-contain rounded-lg"
                    onerror="this.src='https://via.placeholder.com/800x600?text=No+Image'">
                <div class="absolute bottom-4 left-4 right-4 bg-black/70 text-white p-3 rounded-lg">
                    <p class="font-bold">${type === 'building' ? 'สิ่งปลูกสร้าง:' : 'ป้าย:'} ${code || '-'}</p>
                    <p class="text-sm">${name || ''}</p>
                    <p class="text-xs mt-1">${address || ''}</p>
                </div>
                <button onclick="closeImageViewer()" class="absolute top-4 right-4 text-white hover:text-gray-300 transition">
                    <i data-lucide="x" class="w-8 h-8"></i>
                </button>
                <button onclick="downloadSingleImage('${imageUrl}', '${code || 'image'}')"
                    class="absolute top-4 left-4 bg-blue-600 text-white p-2 rounded-lg hover:bg-blue-700 transition">
                    <i data-lucide="download" class="w-5 h-5"></i>
                </button>
            </div>
            `;
            
            document.body.appendChild(viewerDiv);
            lucide.createIcons();
        }

        /**
         * ปิดหน้าต่างดูรูปใหญ่
         */
        function closeImageViewer() {
          const viewer = document.getElementById('image-viewer-modal');
          if (viewer) viewer.remove();
        }

        /**
         * ปิดแกลเลอรี่รูปภาพ
         */
        function closeImageGallery() {
          const gallery = document.getElementById('image-gallery-modal');
          if (gallery) gallery.remove();
          closeImageViewer(); // ปิดหน้าต่างดูรูปใหญ่ด้วย (ถ้ามี)
        }

        /**
         * ดาวน์โหลดรูปภาพ
         */
        function downloadImage(url, filename) {
          const link = document.createElement('a');
          link.href = url;
          link.download = `${filename}_${Date.now()}.jpg`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        }

        /**
         * แสดงแจ้งเตือน
         */
        function showNotificationLeft(message, type = 'info') {
          const colors = {
            info: 'bg-blue-500',
            success: 'bg-green-500',
            error: 'bg-red-500',
            warning: 'bg-yellow-500'
          };
          
          const icons = {
            info: 'info',
            success: 'check-circle',
            error: 'alert-circle',
            warning: 'alert-triangle'
          };
          
          const notification = document.createElement('div');
          notification.className = `fixed top-4 left-4 ${colors[type]} text-white px-6 py-3 rounded-lg shadow-lg z-[2000] animate-fade-in`;
          notification.innerHTML = `
            <i data-lucide="${icons[type]}" class="w-5 h-5 inline mr-2"></i>
            ${message}
          `;
          
          document.body.appendChild(notification);
          lucide.createIcons();
          
          setTimeout(() => {
            notification.classList.add('animate-fade-out');
            setTimeout(() => notification.remove(), 300);
          }, 500);
        }
        /**
         * แสดงมาร์กเกอร์ทั้งหมด (สำหรับข้อมูลน้อย)
         */
        function renderAllMarkers() {
          allBuildings.forEach(r => {
            if (!r.lat_long) return;
            const coords = r.lat_long.split(',').map(Number);
            if (coords.length < 2 || isNaN(coords[0]) || isNaN(coords[1])) return;
            const m = createCircleMarker(L.latLng(coords[0], coords[1]), 'building', isEditMode);
            setupMarkerPopup(m, r, 'building');
            m.addTo(surveyLayers);
          });
          
          allSigns.forEach(r => {
            if (!r.lat_long) return;
            const coords = r.lat_long.split(',').map(Number);
            if (coords.length < 2 || isNaN(coords[0]) || isNaN(coords[1])) return;
            const m = createCircleMarker(L.latLng(coords[0], coords[1]), 'sign', isEditMode);
            setupMarkerPopup(m, r, 'sign');
            m.addTo(surveyLayers);
          });
        }

        async function saveLargeFileInChunks(file, fileName) {
            const CHUNK_SIZE = 10 * 1024 * 1024; // 10MB ต่อชิ้น
            const db = await openDatabase();
            const transaction = db.transaction('mapFiles', 'readwrite');
            const store = transaction.objectStore('mapFiles');
            
            for (let start = 0; start < file.size; start += CHUNK_SIZE) {
                const chunk = file.slice(start, start + CHUNK_SIZE);
                const chunkData = await chunk.arrayBuffer();
                
                await store.add({
                    id: `${fileName}_chunk_${start}`,
                    fileName: fileName,
                    chunkIndex: start / CHUNK_SIZE,
                    totalChunks: Math.ceil(file.size / CHUNK_SIZE),
                     chunkData,
                    timestamp: new Date().toISOString()
                });
            }
            
            console.log(`✅ บันทึกไฟล์ ${fileName} สำเร็จ (${file.size} bytes)`);
        }

        async function compressAndSaveMap(file) {
            // ใช้ไลบรารีบีบอัด เช่น pako หรือ zlib
            const compressed = await compressFile(file);
            await saveToIndexedDB(compressed);
        }

        // บันทึกเฉพาะชั้นข้อมูลที่จำเป็น
        const layersToCache = ['parcel', 'boundary']; // ไม่รวม 'building' ถ้าใหญ่เกินไป

        async function downloadMapStreaming(fileId) {
            const response = await fetch(`https://drive.google.com/uc?export=download&id=${fileId}`);
            const reader = response.body.getReader();
            const chunks = [];
            
            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                chunks.push(value);
                
                // บันทึกเป็นระยะเพื่อไม่ให้หน่วยความจำเต็ม
                if (chunks.length > 10) {
                    await saveChunksToDB(chunks);
                    chunks.length = 0;
                }
            }
            
            await saveChunksToDB(chunks);
        }

        async function checkMapFileSize(fileId) {
            const response = await fetch(`https://drive.google.com/uc?export=download&id=${fileId}`, {
                method: 'HEAD'
            });
            
            const size = response.headers.get('content-length');
            const mb = (size / 1024 / 1024).toFixed(2);
            
            console.log(`ขนาดไฟล์แผนที่: ${mb} MB`);
            
            if (size > 50 * 1024 * 1024) {
                alert(`⚠️ ไฟล์แผนที่ใหญ่เกินไป (${mb} MB)\nแนะนำให้แบ่งชั้นข้อมูลหรือบีบอัดไฟล์`);
            }
            
            return size;
        }

        // ============================================
        // อัปเดตมาร์กเกอร์เฉพาะในมุมมอง (GPU Optimized)
        // ============================================
        function updateVisibleMarkers() {
            // ✅ ใช้ requestAnimationFrame สำหรับการเรนเดอร์แบบประสิทธิภาพสูง
            requestAnimationFrame(() => {
                const bounds = map.getBounds();
                const zoom = map.getZoom();
                const bufferRatio = isMobile() ? 1.3 : 1.5; // ลดบัฟเฟอร์สำหรับมือถือ
                const bufferedBounds = bounds.pad(bufferRatio);
                
                // ✅ ล้างมาร์กเกอร์ทั้งหมดในครั้งเดียว (แทนทีละตัว)
                surveyLayers.clearLayers();
                
                // ✅ สร้างมาร์กเกอร์แบบแบตช์
                const markersToRender = [];
                
                // จุดสิ่งปลูกสร้าง
                allBuildings.forEach(r => {
                    if (!r.lat_long) return;
                    const coords = r.lat_long.split(',').map(Number);
                    if (coords.length < 2 || isNaN(coords[0]) || isNaN(coords[1])) return;
                    
                    const latLng = L.latLng(coords[0], coords[1]);
                    if (!bufferedBounds.contains(latLng)) return;
                    
                    // ✅ ข้ามจุดที่กำลังถูกย้าย
                    const recordKey = r._row_num || r.id;
                    if (markersBeingMoved.has(recordKey)) return;
                    
                    markersToRender.push({ latLng, data: r, type: 'building' });
                });
                
                // จุดป้าย
                allSigns.forEach(r => {
                    if (!r.lat_long) return;
                    const coords = r.lat_long.split(',').map(Number);
                    if (coords.length < 2 || isNaN(coords[0]) || isNaN(coords[1])) return;
                    
                    const latLng = L.latLng(coords[0], coords[1]);
                    if (!bufferedBounds.contains(latLng)) return;
                    
                    const recordKey = r._row_num || r.id;
                    if (markersBeingMoved.has(recordKey)) return;
                    
                    markersToRender.push({ latLng, data: r, type: 'sign' });
                });
                
                // ✅ เรนเดอร์ทั้งหมดในครั้งเดียว
                markersToRender.forEach(item => {
                    const m = createCircleMarker(item.latLng, item.type, isEditMode);
                    m._popupData = item.data;
                    m.addTo(surveyLayers);
                });
                
                console.log(`✅ เรนเดอร์มาร์กเกอร์ ${markersToRender.length} จุดด้วย GPU (Canvas)`);
            });
        }

        // ฟังก์ชันสร้างแถวข้อมูลป้าย
        function renderSignTable() {
            const tbody = document.getElementById('sign-table-body');
            if (!allSigns || allSigns.length === 0) {
                tbody.innerHTML = '<tr><td colspan="9" class="text-center py-8 text-gray-500">ไม่มีข้อมูลป้าย</td></tr>';
                return;
            }
            // ในฟังก์ชัน renderSignTable() แก้ไขส่วนสร้างแถว:
            const sortedSigns = sortSigns(allSigns, signSortColumn, signSortDirection);

            tbody.innerHTML = sortedSigns.map(sign => {
                if (!sign.lat_long) return '';
                const [lat, lng] = sign.lat_long.split(',').map(Number);
                if (isNaN(lat) || isNaN(lng)) return '';
                
                // ✅ แสดงสถานะตรวจสอบให้ตรงกับข้อมูลจริง
                const statusClass = sign.check === 'ถ่ายรูปแล้ว' ? 'status-ถ่ายรูปแล้ว' :
                                   sign.check === 'ตรวจสอบแล้ว' ? 'status-ตรวจสอบแล้ว' : 'status-ยังไม่สำรวจ';
                const statusText = sign.check || 'ยังไม่สำรวจ';
                
                return `
                <tr>
                    <td><span class="marker-icon marker-sign"></span></td>
                    <td class="font-medium">${sign.s_code || '-'}</td>      <!-- 1. รหัส -->
                    <td class="text-center">${sign.s_characte || '-'}</td>       <!-- ✅ แก้ไข: บังคับกึ่งกลางด้วย inline style -->
                    <td class="text-center">${sign.s_wide || '-'}</td>        <!-- ✅ เพิ่ม -->
                    <td class="text-center">${sign.s_length || '-'}</td>      <!-- ✅ เพิ่ม -->
                    <td class="text-center">${sign.no_side || '-'}</td>       <!-- ✅ เพิ่ม -->
                    <td>${sign.s_text || '-'}</td>                          <!-- 6. ข้อความ -->
                    <td class="text-center"><span class="status-badge ${statusClass}">${statusText}</span></td> <!-- ✅ เพิ่ม -->
                    <td>
                        <button class="zoom-btn" onclick="zoomToLocation(L.latLng(${lat}, ${lng}))">
                            <i data-lucide="locate" class="w-3 h-3 inline"></i>
                        </button>
                    </td>
                </tr>
                `;
            }).join('');
            lucide.createIcons();
        }

        // ============================================
        // สถานะการเรียงลำดับ (เริ่มต้นเรียงตามรหัส)
        // ============================================
        let buildingSortColumn = 'building_c';
        let buildingSortDirection = 'asc'; // 'asc' หรือ 'desc'
        let signSortColumn = 's_code';
        let signSortDirection = 'asc';

        // คอลั่มน์ที่เป็นตัวเลข (สำหรับการเรียงแบบตัวเลข)
        const buildingNumericColumns = ['b_area', 'b_year', 'hs_no', 'hs_moo', 'no_floor', 'buse_area', 'buse_area2'];
        const signNumericColumns = ['s_wide', 's_length', 'no_side'];

        // ============================================
        // ฟังก์ชันอัปเดตสัญลักษณ์เรียงลำดับในหัวตาราง
        // ============================================
        function updateSortIndicators(tableId, sortColumn, sortDirection) {
            // ลบสัญลักษณ์เก่าทั้งหมด
            document.querySelectorAll(`#${tableId} .sort-indicator`).forEach(el => el.remove());
            
            // เพิ่มสัญลักษณ์ใหม่ในคอลั่มน์ที่เรียง
            const header = document.querySelector(`#${tableId} th.sortable-header[data-sort="${sortColumn}"]`);
            if (header) {
                const indicator = document.createElement('span');
                indicator.className = 'sort-indicator ml-1 text-blue-600 font-bold';
                indicator.innerHTML = sortDirection === 'asc' ? '↑' : '↓';
                header.appendChild(indicator);
            }
        }

        // ============================================
        // ฟังก์ชันเรียงข้อมูลสิ่งปลูกสร้าง
        // ============================================
        function sortBuildings(data, column, direction) {
            return [...data].sort((a, b) => {
                let valA = a[column] || '';
                let valB = b[column] || '';
                
                // จัดการค่าตัวเลข
                if (buildingNumericColumns.includes(column)) {
                    valA = parseFloat(valA) || 0;
                    valB = parseFloat(valB) || 0;
                    return direction === 'asc' ? valA - valB : valB - valA;
                }
                
                // จัดการข้อความ (รองรับภาษาไทย)
                if (typeof valA === 'string' && typeof valB === 'string') {
                    const result = valA.localeCompare(valB, 'th', { numeric: true, sensitivity: 'base' });
                    return direction === 'asc' ? result : -result;
                }
                
                // Fallback
                return direction === 'asc' ? (valA > valB ? 1 : -1) : (valA < valB ? 1 : -1);
            });
        }

        // ============================================
        // ฟังก์ชันเรียงข้อมูลป้าย
        // ============================================
        function sortSigns(data, column, direction) {
            return [...data].sort((a, b) => {
                let valA = a[column] || '';
                let valB = b[column] || '';
                
                // จัดการค่าตัวเลข
                if (signNumericColumns.includes(column)) {
                    valA = parseFloat(valA) || 0;
                    valB = parseFloat(valB) || 0;
                    return direction === 'asc' ? valA - valB : valB - valA;
                }
                
                // จัดการข้อความ (รองรับภาษาไทย)
                if (typeof valA === 'string' && typeof valB === 'string') {
                    const result = valA.localeCompare(valB, 'th', { numeric: true, sensitivity: 'base' });
                    return direction === 'asc' ? result : -result;
                }
                
                // Fallback
                return direction === 'asc' ? (valA > valB ? 1 : -1) : (valA < valB ? 1 : -1);
            });
        }

        // ============================================
        // ผูกเหตุการณ์คลิกหัวตารางเมื่อโหลดหน้าเว็บ
        // ============================================
        document.addEventListener('DOMContentLoaded', () => {
            // ผูกเหตุการณ์กับหัวตารางสิ่งปลูกสร้าง
            document.querySelectorAll('#building-table .sortable-header').forEach(header => {
                header.style.cursor = 'pointer';
                header.style.userSelect = 'none';
                header.addEventListener('click', () => {
                    const column = header.dataset.sort;
                    if (buildingSortColumn === column) {
                        buildingSortDirection = buildingSortDirection === 'asc' ? 'desc' : 'asc';
                    } else {
                        buildingSortColumn = column;
                        buildingSortDirection = 'asc';
                    }
                    updateSortIndicators('building-table', buildingSortColumn, buildingSortDirection);
                    renderBuildingTable(); // เรนเดอร์ใหม่ด้วยการเรียงลำดับใหม่
                });
            });
            
            // ผูกเหตุการณ์กับหัวตารางป้าย
            document.querySelectorAll('#sign-table .sortable-header').forEach(header => {
                header.style.cursor = 'pointer';
                header.style.userSelect = 'none';
                header.addEventListener('click', () => {
                    const column = header.dataset.sort;
                    if (signSortColumn === column) {
                        signSortDirection = signSortDirection === 'asc' ? 'desc' : 'asc';
                    } else {
                        signSortColumn = column;
                        signSortDirection = 'asc';
                    }
                    updateSortIndicators('sign-table', signSortColumn, signSortDirection);
                    renderSignTable(); // เรนเดอร์ใหม่ด้วยการเรียงลำดับใหม่
                });
            });
            
            // ตั้งค่าเริ่มต้น
            updateSortIndicators('building-table', buildingSortColumn, buildingSortDirection);
            updateSortIndicators('sign-table', signSortColumn, signSortDirection);
        });

        async function loadExistingData() {
            try {
                const res = await fetch(`${CONFIG.SCRIPT_URL}?action=getData`);
                const data = await res.json();
                
                // ✅ วางโค้ดตรงนี้ - แปลงค่าชั้นที่ใช้จากวันที่เป็นรูปแบบ "1-1", "1-2"
                if (data.buildings && Array.isArray(data.buildings)) {
                    data.buildings.forEach(b => {
                        b.buse_floor = normalizeFloorValue(b.buse_floor);
                        b.buse_floor2 = normalizeFloorValue(b.buse_floor2); // ใช้ชื่อถูกต้อง
                    });
                }

                // ✅ เก็บเฉพาะจุดชั่วคราวที่ไม่ใช่จุดที่กำลังถูกย้าย
                const tempMarkers = [];
                surveyLayers.eachLayer(layer => {
                    if (layer._popupData && layer._popupData.tempMarker && !layer._popupData.beingMoved) {
                        tempMarkers.push({
                            latlng: layer.getLatLng(),
                            data: layer._popupData,
                            type: layer._popupData.type
                        });
                    }
                });
                
                surveyLayers.clearLayers();
                
                // โหลดข้อมูลจริงจากเซิร์ฟเวอร์
                allBuildings = data.buildings || [];
                allSigns = data.signs || [];
                
                // แสดงข้อมูลในตาราง
                renderBuildingTable();
                renderSignTable();
                
                const totalMarkers = allBuildings.length + allSigns.length;
                const useOptimizedRendering = totalMarkers > 200;
                
                if (useOptimizedRendering) {
                    map.off('moveend', updateVisibleMarkers);
                    map.off('zoomend', updateVisibleMarkers);
                    map.on('moveend', updateVisibleMarkers);
                    map.on('zoomend', updateVisibleMarkers);
                    updateVisibleMarkers();
                } else {
                    // ✅ สร้างจุดจริงทั้งหมด (ไม่เรียก enableMarkerDragging)
                    allBuildings.forEach(r => {
                        if (!r.lat_long) return;
                        const coords = r.lat_long.split(',').map(Number);
                        if (coords.length < 2 || isNaN(coords[0]) || isNaN(coords[1])) return;
                        
                        // ✅ ข้ามจุดที่กำลังถูกย้าย
                        const recordKey = r._row_num || r.id;
                        if (markersBeingMoved.has(String(recordKey))) {
                            return;
                        }
                        
                        const m = createCircleMarker(L.latLng(coords[0], coords[1]), 'building', isEditMode);
                        m._popupData = r;
                        setupMarkerPopup(m, r, 'building');
                        m.addTo(surveyLayers);
                        // ❌ ลบบรรทัดนี้ออก: if (isEditMode) enableMarkerDragging(m, r);
                    });
                    
                    allSigns.forEach(r => {
                        if (!r.lat_long) return;
                        const coords = r.lat_long.split(',').map(Number);
                        if (coords.length < 2 || isNaN(coords[0]) || isNaN(coords[1])) return;
                        
                        // ✅ ข้ามจุดที่กำลังถูกย้าย
                        const recordKey = r._row_num || r.id;
                        if (markersBeingMoved.has(String(recordKey))) {
                            return;
                        }
                        
                        const m = createCircleMarker(L.latLng(coords[0], coords[1]), 'sign', isEditMode);
                        m._popupData = r;
                        setupMarkerPopup(m, r, 'sign');
                        m.addTo(surveyLayers);
                        // ❌ ลบบรรทัดนี้ออก: if (isEditMode) enableMarkerDragging(m, r);
                    });
                }
                
                // ✅ เพิ่มจุดชั่วคราวกลับเข้ามา (ไม่เรียก enableMarkerDragging)
                tempMarkers.forEach(marker => {
                    const m = createCircleMarker(marker.latlng, marker.type, isEditMode);
                    m._popupData = marker.data;
                    setupMarkerPopup(m, marker.data, marker.type);
                    m.addTo(surveyLayers);
                    // ❌ ลบบรรทัดนี้ออก: if (isEditMode) enableMarkerDragging(m, marker.data);
                });
            } catch (e) {
                console.error("Error loading data:", e);
            }
            // ✅ อัปเดตจำนวนที่หัวตารางหลังโหลดข้อมูล
            updateTableCounters();
        }

        // ============================================
        // Offline Data Storage System
        // ============================================

        // ตรวจจับสถานะออนไลน์
        let isOnline = navigator.onLine;
        let syncQueue = [];

        // แสดงสถานะการเชื่อมต่อ
        function updateConnectionStatus() {
            const statusDiv = document.getElementById('connection-status');
            if (!statusDiv) {
                const div = document.createElement('div');
                div.id = 'connection-status';
                div.className = 'fixed top-4 left-4 px-4 py-2 rounded-lg text-white font-bold shadow-lg z-[2000]';
                document.body.appendChild(div);
            }
            
            const status = document.getElementById('connection-status');
            if (isOnline) {
                status.textContent = '✓ เชื่อมต่ออินเทอร์เน็ต';
                status.className = 'fixed top-4 left-4 px-4 py-2 rounded-lg text-white font-bold shadow-lg z-[2000] bg-green-500';
            } else {
                status.textContent = '⚠️ โหมดออฟไลน์ - ข้อมูลจะถูกเก็บไว้ในมือถือ';
                status.className = 'fixed top-4 left-4 px-4 py-2 rounded-lg text-white font-bold shadow-lg z-[2000] bg-yellow-500';
            }
            
            // ซ่อนอัตโนมัติหลัง 3 วินาที
            setTimeout(() => {
                status.style.opacity = '0';
                setTimeout(() => status.remove(), 300);
            }, 1000);
        }

        // ฟังก์ชันตรวจสอบการเชื่อมต่อ
        window.addEventListener('online', () => {
            isOnline = true;
            updateConnectionStatus();
            // เมื่อกลับมาออนไลน์ ให้พยายามส่งข้อมูลที่ค้างอยู่
            setTimeout(processSyncQueue, 1000);
        });

        window.addEventListener('offline', () => {
            isOnline = false;
            updateConnectionStatus();
        });

        // ฟังก์ชันเก็บข้อมูลในคิว
        function addToSyncQueue(action, type, data, rowKey = null) {
            const queueItem = {
                id: Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                timestamp: new Date().toISOString(),
                action: action, // 'add', 'update', 'delete', 'updatePosition'
                type: type,     // 'building', 'sign'
                data: data,
                rowKey: rowKey,
                status: 'ยังไม่สำรวจ', // ยังไม่สำรวจ, success, failed
                retryCount: 0
            };
            
            syncQueue.push(queueItem);
            saveSyncQueueToStorage();
            
            // แสดงแจ้งเตือน
            showNotificationLeft(`บันทึกข้อมูลไว้ในมือถือ (${syncQueue.length} รายการรอซิงค์)`, 'warning');
            
            return queueItem.id;
        }

        // บันทึกคิวลงใน LocalStorage
        function saveSyncQueueToStorage() {
            localStorage.setItem('syncQueue', JSON.stringify(syncQueue));
        }

        // โหลดคิวจาก LocalStorage
        function loadSyncQueueFromStorage() {
            const saved = localStorage.getItem('syncQueue');
            if (saved) {
                syncQueue = JSON.parse(saved);
            }
        }

        // ลบรายการที่สำเร็จแล้ว
        function removeFromSyncQueue(id) {
            syncQueue = syncQueue.filter(item => item.id !== id);
            saveSyncQueueToStorage();
        }

        // ============================================
        // ฟังก์ชันส่งข้อมูลแบบมีการลองใหม่ (Retry Mechanism)
        // ============================================

        async function sendDataWithRetry(action, type, data, rowKey = null, maxRetries = 5) {
            // ถ้าออฟไลน์ → เก็บไว้ในคิวทันที
            if (!isOnline || !navigator.onLine) {
                return addToSyncQueue(action, type, data, rowKey);
            }
            
            let retryCount = 0;
            
            while (retryCount < maxRetries) {
                try {
                    const body = new URLSearchParams();
                    body.append('action', action);
                    body.append('type', type);
                    
                    if (rowKey) {
                        body.append('rowKey', rowKey);
                    }
                    
                    if (data) {
                        // ✅ แยกข้อมูลรูปภาพออก
                        const { image, fileName, ...textData } = data;
                        
                        // ส่งข้อมูลข้อความ
                        if (Object.keys(textData).length > 0) {
                            body.append('payload', JSON.stringify(textData));
                        }
                        
                        // ✅ ส่งรูปภาพไปยังเซิร์ฟเวอร์ทันที
                        if (image && fileName) {
                            body.append('image', image);
                            body.append('fileName', fileName);
                            console.log(`ส่งรูปภาพไปยังเซิร์ฟเวอร์: ${fileName}`);
                        }
                    }
                    
                    const res = await fetch(CONFIG.SCRIPT_URL.trim(), {
                        method: 'POST',
                        body,
                        timeout: action === 'updateImage' || (data && data.image) ? 60000 : 30000
                    });
                    
                    if (res.ok) {
                        // ✅ แก้ไขตรงนี้: เพิ่มชื่อคีย์ 'data'
                        return { success: true, data: await res.json() };
                    } else {
                        throw new Error(`HTTP ${res.status}`);
                    }
                } catch (err) {
                    retryCount++;
                    
                    if (retryCount >= maxRetries) {
                        // ✅ หากล้มเหลวทุกครั้ง ให้บันทึกลงคิว
                        const queueId = addToSyncQueue(action, type, data, rowKey);
                        console.error(`Failed after ${maxRetries} retries. Saved to queue: ${queueId}`);
                        return { success: false, queued: true, queueId: queueId };
                    }
                    
                    const waitTime = 1000 * Math.pow(2, retryCount);
                    console.log(`Retry ${retryCount}/${maxRetries} after ${waitTime}ms...`);
                    
                    // รอเวลาที่กำหนด
                    await new Promise(resolve => setTimeout(resolve, waitTime));
                }
            }
        }

        // ============================================
        // ตั้งค่าไฟล์แผนที่จากกูเกิ้ลไดร์ฟ
        // ============================================
        const MAP_CONFIG = {
            googleDriveFileId: 'YOUR_FILE_ID_HERE', // ✅ แทนที่ด้วยไฟล์ไอดีของคุณ
            fileName: 'ltaxmap_nt.gpkg',
            layers: ['parcel', 'boundary', 'building'],
            localCacheKey: 'ltaxmap_cache',
            lastModifiedKey: 'ltaxmap_last_modified',
            lastCheckKey: 'ltaxmap_last_check', // ✅ เพิ่มสำหรับตรวจสอบเวลา
            checkTime: 8 // ✅ เวลาตรวจสอบ: 08:00 น.
        };

        // ============================================
        // ตรวจสอบและโหลดแผนที่แบบออฟไลน์
        // ============================================
        async function checkAndLoadMap() {
            console.log('🔍 ตรวจสอบแผนที่...');
            
            // ✅ ตรวจสอบว่ามีไฟล์แผนที่ในแคชหรือไม่
            const cachedData = await getCachedMapData();
            
            if (cachedData) {
                console.log('✅ พบแผนที่ในแคช - โหลดจากแคช');
                loadMapFromCache(cachedData);
                
                // ✅ ตรวจสอบการอัปเดตแบบเบื้องหลัง (ทุกวัน 08:00 น.)
                setTimeout(() => checkForMapUpdate(), 1000);
            } else {
                console.log('⚠️ ไม่พบแผนที่ในแคช - ดาวน์โหลดใหม่');
                await downloadAndCacheMap();
            }
        }

        // ============================================
        // ดาวน์โหลดแผนที่จากกูเกิ้ลไดร์ฟ (ใช้สตรีมมิ่ง)
        // ============================================
        async function downloadAndCacheMap() {
            try {
                showNotificationLeft('กำลังดาวน์โหลดแผนที่...', 'info');
                
                // ✅ แสดงความคืบหน้า
                const progressIndicator = document.createElement('div');
                progressIndicator.id = 'map-download-progress';
                progressIndicator.className = 'fixed top-4 right-4 bg-blue-500 text-white px-4 py-2 rounded-lg shadow-lg z-[2001]';
                progressIndicator.innerHTML = 'ดาวน์โหลดแผนที่: 0%';
                document.body.appendChild(progressIndicator);
                
                // ✅ ดาวน์โหลดไฟล์จากกูเกิ้ลไดร์ฟ
                const fileUrl = `https://drive.google.com/uc?export=download&id=${MAP_CONFIG.googleDriveFileId}`;
                const response = await fetch(fileUrl);
                
                if (!response.ok) {
                    throw new Error('ดาวน์โหลดแผนที่ล้มเหลว');
                }
                
                // ✅ ดึงเวลาแก้ไขจริงจากหัวข้อ Last-Modified (สำคัญ!)
                const lastModifiedHeader = response.headers.get('last-modified');
                const lastModified = lastModifiedHeader 
                    ? new Date(lastModifiedHeader).toISOString() 
                    : new Date().toISOString();
                
                // ✅ ดึงขนาดไฟล์
                const contentLength = response.headers.get('content-length');
                const total = parseInt(contentLength, 10);
                let loaded = 0;
                
                // ✅ ใช้สตรีมมิ่งเพื่อโหลดทีละชิ้น
                const reader = response.body.getReader();
                const chunks = [];
                
                while (true) {
                    const { done, value } = await reader.read();
                    
                    if (done) break;
                    
                    chunks.push(value);
                    loaded += value.length;
                    
                    // ✅ อัปเดตความคืบหน้า
                    const percent = Math.round((loaded / total) * 100);
                    progressIndicator.innerHTML = `ดาวน์โหลดแผนที่: ${percent}%`;
                    
                    // ✅ บันทึกชิ้นส่วนทุก 10 ชิ้น (หรือเมื่อถึงขนาด 5MB)
                    if (chunks.length >= 10 || loaded >= 5 * 1024 * 1024) {
                        await saveChunksToDB(chunks);
                        chunks.length = 0; // ล้างชิ้นที่บันทึกแล้ว
                    }
                }
                
                // ✅ บันทึกชิ้นส่วนที่เหลืออยู่
                if (chunks.length > 0) {
                    await saveChunksToDB(chunks);
                }
                
                // ✅ รวมชิ้นส่วนทั้งหมดเป็นไฟล์สมบูรณ์
                console.log('🔄 กำลังรวมชิ้นส่วน...');
                const arrayBuffer = await assembleChunks(MAP_CONFIG.fileName);
                
                // ✅ บันทึกในแคช (ใช้เวลาแก้ไขจริงจากไดร์ฟ!)
                await cacheMapData(arrayBuffer, lastModified);
                
                // ✅ ลบตัวบ่งชี้ความคืบหน้า
                progressIndicator.remove();
                
                console.log(`✅ ดาวน์โหลดและบันทึกแผนที่เรียบร้อย (แก้ไขล่าสุด: ${new Date(lastModified).toLocaleString('th-TH')})`);
                showNotificationLeft('ดาวน์โหลดแผนที่สำเร็จ!', 'success');
                
                // ✅ โหลดแผนที่
                loadMapFromCache(arrayBuffer);
                
            } catch (err) {
                console.error('❌ ข้อผิดพลาดในการดาวน์โหลดแผนที่:', err);
                showNotificationLeft('ดาวน์โหลดแผนที่ล้มเหลว: ' + err.message, 'error');
                
                // ✅ ลบตัวบ่งชี้ความคืบหน้า
                const progressIndicator = document.getElementById('map-download-progress');
                if (progressIndicator) progressIndicator.remove();
                
                // ✅ ลบชิ้นส่วนที่ดาวน์โหลดค้างอยู่
                try {
                    const db = await openMapDatabase();
                    const transaction = db.transaction(['mapChunks'], 'readwrite');
                    const store = transaction.objectStore('mapChunks');
                    const request = store.index('fileName').openCursor(IDBKeyRange.only(MAP_CONFIG.fileName));
                    
                    request.onsuccess = (event) => {
                        const cursor = event.target.result;
                        if (cursor) {
                            store.delete(cursor.key);
                            cursor.continue();
                        }
                    };
                    
                    db.close();
                } catch (cleanupErr) {
                    console.warn('⚠️ ไม่สามารถล้างชิ้นส่วนที่ค้างอยู่ได้:', cleanupErr);
                }
            }
        }

        // ============================================
        // ตรวจสอบการอัปเดตแผนที่ (ใช้ HEAD request - ไม่มีค่าใช้จ่าย)
        // ============================================
        async function checkForMapUpdate() {
            try {
                console.log('🔍 ตรวจสอบการอัปเดตแผนที่...');
                
                // ✅ ตรวจสอบว่าเคยเช็ควันนี้แล้วหรือยัง
                const today = new Date().toDateString();
                const lastCheck = localStorage.getItem(MAP_CONFIG.lastCheckKey);
                if (lastCheck === today) {
                    console.log('✅ ตรวจสอบการอัปเดตแล้ววันนี้ - ข้าม');
                    return;
                }
                
                // ✅ ตรวจสอบว่าถึงเวลา 08:00 น. แล้วหรือยัง
                const now = new Date();
                if (now.getHours() < MAP_CONFIG.checkTime) {
                    console.log(`⏳ ยังไม่ถึงเวลา ${MAP_CONFIG.checkTime}:00 น. - ข้าม`);
                    return;
                }
                
                // ✅ ดึงเวลาแก้ไขล่าสุดจากไฟล์ในเครื่อง
                const localLastModifiedStr = localStorage.getItem(MAP_CONFIG.lastModifiedKey);
                if (!localLastModifiedStr) {
                    console.log('⚠️ ไม่พบข้อมูลเวลาแก้ไขในเครื่อง - ดาวน์โหลดใหม่');
                    await downloadAndCacheMap();
                    localStorage.setItem(MAP_CONFIG.lastCheckKey, today);
                    return;
                }
                
                // ✅ ส่งคำขอ HEAD ไปยังลิงก์ดาวน์โหลด (ไม่ดาวน์โหลดไฟล์จริง!)
                const fileUrl = `https://drive.google.com/uc?export=download&id=${MAP_CONFIG.googleDriveFileId}`;
                const headResponse = await fetch(fileUrl, { method: 'HEAD' });
                
                if (!headResponse.ok) {
                    throw new Error(`HEAD request ล้มเหลว: ${headResponse.status}`);
                }
                
                // ✅ ดึงเวลาแก้ไขล่าสุดจากหัวข้อ Last-Modified
                const remoteLastModifiedStr = headResponse.headers.get('last-modified');
                if (!remoteLastModifiedStr) {
                    console.warn('⚠️ ไม่พบหัวข้อ Last-Modified จากกูเกิ้ลไดร์ฟ');
                    localStorage.setItem(MAP_CONFIG.lastCheckKey, today);
                    return;
                }
                
                const remoteLastModified = new Date(remoteLastModifiedStr);
                const localLastModified = new Date(localLastModifiedStr);
                
                console.log(`🕒 เวลาแก้ไขในเครื่อง: ${localLastModified.toLocaleString('th-TH')}`);
                console.log(`🌐 เวลาแก้ไขบนไดร์ฟ: ${remoteLastModified.toLocaleString('th-TH')}`);
                
                // ✅ เปรียบเทียบเวลา - ดาวน์โหลดเฉพาะเมื่อไฟล์บนไดร์ฟใหม่กว่า
                if (remoteLastModified > localLastModified) {
                    console.log('🔄 พบเวอร์ชันใหม่บนกูเกิ้ลไดร์ฟ - กำลังดาวน์โหลด...');
                    showNotificationLeft('มีแผนที่เวอร์ชันใหม่! กำลังดาวน์โหลด...', 'info');
                    await downloadAndCacheMap();
                } else {
                    console.log('✅ แผนที่ในเครื่องเป็นเวอร์ชันล่าสุดแล้ว');
                    showNotificationLeft('แผนที่เป็นเวอร์ชันล่าสุดแล้ว', 'success');
                }
                
                // ✅ บันทึกว่าตรวจสอบแล้ววันนี้
                localStorage.setItem(MAP_CONFIG.lastCheckKey, today);
                
            } catch (err) {
                console.error('❌ ข้อผิดพลาดในการตรวจสอบการอัปเดต:', err);
                // ไม่แสดงข้อผิดพลาดให้ผู้ใช้ (ไม่รบกวนการทำงานหลัก)
            }
        }

        // ============================================
        // บันทึกข้อมูลแผนที่ในแคช (IndexedDB)
        // ============================================
        async function cacheMapData(arrayBuffer, lastModified) {
            try {
                // ✅ ใช้ IndexedDB สำหรับบันทึกไฟล์ขนาดใหญ่
                const db = await openMapDatabase();
                const transaction = db.transaction(['maps'], 'readwrite');
                const store = transaction.objectStore('maps');
                
                await store.put({
                    id: MAP_CONFIG.fileName,
                    data: arrayBuffer,
                    lastModified: lastModified
                });
                
                // ✅ บันทึกวันที่ใน localStorage สำหรับตรวจสอบง่าย
                localStorage.setItem(MAP_CONFIG.lastModifiedKey, lastModified);
                
                db.close();
                console.log('✅ บันทึกแผนที่ในแคชเรียบร้อย');
                
            } catch (err) {
                console.error('❌ ข้อผิดพลาดในการบันทึกแคช:', err);
                throw err;
            }
        }

        // ============================================
        // บันทึกชิ้นส่วนข้อมูลลงในฐานข้อมูล (สำหรับสตรีมมิ่ง)
        // ============================================
        async function saveChunksToDB(chunks) {
            if (chunks.length === 0) return;
            
            try {
                const db = await openMapDatabase();
                const transaction = db.transaction(['mapChunks'], 'readwrite');
                const store = transaction.objectStore('mapChunks');
                
                // บันทึกแต่ละชิ้น
                for (let i = 0; i < chunks.length; i++) {
                    await store.put({
                        id: `${MAP_CONFIG.fileName}_chunk_${Date.now()}_${i}`,
                        fileName: MAP_CONFIG.fileName,
                        chunkData: chunks[i],
                        chunkIndex: i,
                        timestamp: new Date().toISOString()
                    });
                }
                
                db.close();
                console.log(`✅ บันทึก ${chunks.length} ชิ้นส่วนลงฐานข้อมูล`);
                
            } catch (err) {
                console.error('❌ ข้อผิดพลาดในการบันทึกชิ้นส่วน:', err);
                throw err;
            }
        }

        // ============================================
        // รวมชิ้นส่วนทั้งหมดเป็นไฟล์สมบูรณ์
        // ============================================
        async function assembleChunks(fileName) {
            try {
                const db = await openMapDatabase();
                const transaction = db.transaction(['mapChunks'], 'readonly');
                const store = transaction.objectStore('mapChunks');
                
                // ดึงชิ้นส่วนทั้งหมดที่เกี่ยวข้องกับไฟล์นี้
                const request = store.index('fileName').getAll(fileName);
                
                return new Promise((resolve, reject) => {
                    request.onsuccess = async (event) => {
                        const chunks = event.target.result;
                        
                        if (chunks.length === 0) {
                            db.close();
                            reject(new Error('ไม่พบชิ้นส่วนข้อมูล'));
                            return;
                        }
                        
                        // เรียงลำดับชิ้นส่วนตามดัชนี
                        chunks.sort((a, b) => a.chunkIndex - b.chunkIndex);
                        
                        // รวมชิ้นส่วนทั้งหมด
                        const allData = chunks.map(chunk => chunk.chunkData);
                        const blob = new Blob(allData);
                        const arrayBuffer = await blob.arrayBuffer();
                        
                        // ลบชิ้นส่วนที่รวมแล้ว
                        const deleteTransaction = db.transaction(['mapChunks'], 'readwrite');
                        const deleteStore = deleteTransaction.objectStore('mapChunks');
                        
                        for (const chunk of chunks) {
                            deleteStore.delete(chunk.id);
                        }
                        
                        db.close();
                        resolve(arrayBuffer);
                    };
                    
                    request.onerror = (event) => {
                        db.close();
                        reject(event.target.error);
                    };
                });
                
            } catch (err) {
                console.error('❌ ข้อผิดพลาดในการรวมชิ้นส่วน:', err);
                throw err;
            }
        }

        // ============================================
        // ดึงข้อมูลแผนที่จากแคช
        // ============================================
        async function getCachedMapData() {
            try {
                const db = await openMapDatabase();
                const transaction = db.transaction(['maps'], 'readonly');
                const store = transaction.objectStore('maps');
                const request = store.get(MAP_CONFIG.fileName);
                
                return new Promise((resolve, reject) => {
                    request.onsuccess = (event) => {
                        db.close();
                        resolve(event.target.result ? event.target.result.data : null);
                    };
                    request.onerror = (event) => {
                        db.close();
                        reject(event.target.error);
                    };
                });
                
            } catch (err) {
                console.error('❌ ข้อผิดพลาดในการดึงข้อมูลจากแคช:', err);
                return null;
            }
        }

        // ============================================
        // เปิดฐานข้อมูล IndexedDB สำหรับแผนที่
        // ============================================
        function openMapDatabase() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('MapCacheDB', 3); // เพิ่มเวอร์ชันเป็น 3
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    
                    // สร้าง store สำหรับแผนที่สมบูรณ์
                    if (!db.objectStoreNames.contains('maps')) {
                        const mapStore = db.createObjectStore('maps', { keyPath: 'id' });
                        mapStore.createIndex('lastModified', 'lastModified', { unique: false });
                    }
                    
                    // สร้าง store สำหรับชิ้นส่วน (ใหม่!)
                    if (!db.objectStoreNames.contains('mapChunks')) {
                        const chunkStore = db.createObjectStore('mapChunks', { keyPath: 'id' });
                        chunkStore.createIndex('fileName', 'fileName', { unique: false });
                        chunkStore.createIndex('timestamp', 'timestamp', { unique: false });
                    }
                };
                
                request.onsuccess = (event) => {
                    resolve(event.target.result);
                };
                
                request.onerror = (event) => {
                    reject(event.target.error);
                };
            });
        }

        // ============================================
        // โหลดแผนที่จากข้อมูลแคช
        // ============================================
        async function loadMapFromCache(arrayBuffer) {
            try {
                console.log('🗺️ กำลังโหลดแผนที่จากแคช...');
                
                // ✅ ใช้ไลบรารี GeoPackage เพื่ออ่านไฟล์
                const geoPackage = await GeoPackageAPI.open(arrayBuffer);
                
                // ✅ โหลดแต่ละชั้นข้อมูล
                for (const layerName of MAP_CONFIG.layers) {
                    await loadGeoPackageLayer(geoPackage, layerName);
                }
                
                console.log('✅ โหลดแผนที่เรียบร้อย');
                showNotificationLeft('โหลดแผนที่สำเร็จ!', 'success');
                
            } catch (err) {
                console.error('❌ ข้อผิดพลาดในการโหลดแผนที่:', err);
                showNotificationLeft('โหลดแผนที่ล้มเหลว: ' + err.message, 'error');
            }
        }

        // ============================================
        // โหลดชั้นข้อมูลจาก GeoPackage
        // ============================================
        async function loadGeoPackageLayer(geoPackage, layerName) {
            try {
                console.log(`🗺️ โหลดชั้นข้อมูล: ${layerName}`);
                
                // ✅ ดึงข้อมูลจากชั้นข้อมูล
                const featureDao = geoPackage.getFeatureDao(layerName);
                const features = [];
                
                // ✅ วนลูปดึงข้อมูลทั้งหมด
                await featureDao.queryForEach((feature) => {
                    features.push(feature);
                });
                
                // ✅ แปลงเป็น GeoJSON
                const geoJson = convertToGeoJSON(features, layerName);
                
                // ✅ แสดงบนแผนที่
                displayGeoJSONLayer(geoJson, layerName);
                
                console.log(`✅ โหลดชั้นข้อมูล ${layerName} เรียบร้อย (${features.length} รายการ)`);
                
            } catch (err) {
                console.error(`❌ ข้อผิดพลาดในการโหลดชั้นข้อมูล ${layerName}:`, err);
            }
        }

        // ============================================
        // แปลงข้อมูลเป็น GeoJSON
        // ============================================
        function convertToGeoJSON(features, layerName) {
            const geoJson = {
                type: 'FeatureCollection',
                features: features.map((feature) => {
                    return {
                        type: 'Feature',
                        geometry: feature.geometry,
                        properties: feature.attributes
                    };
                })
            };
            
            return geoJson;
        }

        // ============================================
        // แสดงข้อมูลบนแผนที่
        // ============================================
        function displayGeoJSONLayer(geoJson, layerName) {
            // ✅ สร้างเลเยอร์จากข้อมูล
            const layer = L.geoJSON(geoJson, {
                style: getLayerStyle(layerName),
                onEachFeature: onEachFeature
            });
            
            // ✅ เพิ่มเลเยอร์บนแผนที่
            layer.addTo(map);
            
            // ✅ เก็บอ้างอิงเลเยอร์ (ถ้าต้องการควบคุมการแสดง/ซ่อน)
            if (!window.mapLayers) window.mapLayers = {};
            window.mapLayers[layerName] = layer;
        }

        // ============================================
        // กำหนดสไตล์สำหรับแต่ละชั้นข้อมูล
        // ============================================
        function getLayerStyle(layerName) {
            switch (layerName) {
                case 'parcel':
                    return {
                        color: '#2563eb',
                        weight: 2,
                        fillOpacity: 0.1,
                        fillColor: '#2563eb'
                    };
                case 'boundary':
                    return {
                        color: '#dc2626',
                        weight: 3,
                        fillOpacity: 0,
                        dashArray: '5, 5'
                    };
                case 'building':
                    return {
                        color: '#16a34a',
                        weight: 1,
                        fillOpacity: 0.3,
                        fillColor: '#22c55e'
                    };
                default:
                    return {
                        color: '#6b7280',
                        weight: 1,
                        fillOpacity: 0.1
                    };
            }
        }

        // ============================================
        // จัดการเมื่อคลิกบนฟีเจอร์
        // ============================================
        function onEachFeature(feature, layer) {
            if (feature.properties) {
                // ✅ แสดงป๊อปอัปเมื่อคลิก
                layer.bindPopup(`
                    <div class="map-popup">
                        <h3>${feature.properties.name || 'ข้อมูล'}</h3>
                        <table class="popup-table">
                            ${Object.entries(feature.properties)
                                .map(([key, value]) => 
                                    `<tr><td><strong>${key}:</strong></td><td>${value}</td></tr>`
                                )
                                .join('')}
                        </table>
                    </div>
                `);
            }
        }

        // ============================================
        // เรียกใช้เมื่อโหลดหน้าเว็บ
        // ============================================
        window.addEventListener('load', () => {
            // ✅ ตรวจสอบและโหลดแผนที่
            checkAndLoadMap();
            
            // ✅ ตั้งเวลาตรวจสอบการอัปเดตทุกวัน 08:00 น.
            scheduleDailyUpdateCheck();
        });

        // ============================================
        // ตั้งเวลาตรวจสอบอัปเดตทุกวัน 08:00 น.
        // ============================================
        function scheduleDailyUpdateCheck() {
            // ✅ คำนวณเวลาถัดไปที่จะตรวจสอบ (08:00 น. ของวันนี้หรือพรุ่งนี้)
            const now = new Date();
            const nextCheck = new Date(now);
            nextCheck.setHours(MAP_CONFIG.checkTime, 0, 0, 0); // 08:00:00
            
            // ถ้าเลยเวลา 08:00 น. แล้ว ให้ตั้งเวลาเป็นพรุ่งนี้
            if (now > nextCheck) {
                nextCheck.setDate(nextCheck.getDate() + 1);
            }
            
            // ✅ คำนวณเวลาที่เหลือจนถึงเวลาตรวจสอบ
            const timeUntilCheck = nextCheck - now;
            
            console.log(`⏰ ตั้งเวลาตรวจสอบอัปเดตแผนที่: ${nextCheck.toLocaleString()}`);
            console.log(`⏳ เวลาที่เหลือ: ${Math.floor(timeUntilCheck / 60000)} นาที`);
            
            // ✅ ตั้งเวลาตรวจสอบ
            setTimeout(() => {
                checkForMapUpdate();
                
                // ✅ ตั้งเวลาตรวจสอบใหม่ทุกวัน (24 ชั่วโมง)
                setInterval(checkForMapUpdate, 24 * 60 * 60 * 1000);
            }, timeUntilCheck);
        }

        // ============================================
        // Enhanced Sync Process with Image Support
        // ============================================

        async function processSyncQueue() {
            if (!navigator.onLine || syncQueue.length === 0) {
                console.log('ไม่สามารถซิงค์ได้: ไม่มีอินเทอร์เน็ตหรือไม่มีคิว');
                return;
            }
            
            console.log(`กำลังซิงค์ข้อมูล (${syncQueue.length} รายการ)...`);
            
            const failedItems = [];
            for (let item of syncQueue) {
                if (item.status === 'success') continue;
                
                try {
                    const result = await sendDataWithRetry(
                        item.action,
                        item.type,
                        item.data,
                        item.rowKey,
                        3
                    );
                    
                    if (result.success) {
                        item.status = 'success';
                        removeFromSyncQueue(item.id);
                        console.log(`Synced: ${item.id}`);
                    } else {
                        item.retryCount++;
                        if (item.retryCount >= 5) {
                            item.status = 'failed';
                            failedItems.push(item);
                        }
                    }
                } catch (err) {
                    item.retryCount++;
                    console.error(`Error syncing ${item.id}:`, err);
                    if (item.retryCount >= 5) {
                        item.status = 'failed';
                        failedItems.push(item);
                    }
                }
                
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            
            // ซิงค์รูปภาพที่ยังไม่ได้ส่ง
            await syncPendingImages();
            saveSyncQueueToStorage();
            
            // แจ้งผลลัพธ์
            const successCount = syncQueue.filter(i => i.status === 'success').length;
            const ยังไม่สำรวจCount = syncQueue.filter(i => i.status === 'ยังไม่สำรวจ').length;
            
            if (ยังไม่สำรวจCount === 0 && failedItems.length === 0) {
                console.log('ซิงค์ข้อมูลสำเร็จทั้งหมด!');
            } else if (ยังไม่สำรวจCount > 0) {
                console.log(`ซิงค์ข้อมูล ${successCount} รายการ (${ยังไม่สำรวจCount} รายการรอซิงค์)`);
            }
            
            if (failedItems.length > 0) {
                console.log(`มี ${failedItems.length} รายการที่ซิงค์ไม่สำเร็จ`);
            }
        }


        // โหลดคิวเมื่อแอปเริ่มทำงาน
        loadSyncQueueFromStorage();

        // เพิ่มปุ่มตรวจสอบสถานะซิงค์ในเมนูฟันเฟือง
        // ในฟังก์ชัน toggleSettingsMenu ให้เพิ่มปุ่มใหม่:

        /*
        <button onclick="checkSyncStatus()" class="map-btn p-3 w-48 bg-gradient-to-r from-gray-400 to-gray-600 text-white hover:scale-105 transition-all shadow-lg flex items-center justify-start gap-2 text-left">
            <i data-lucide="sync" class="w-5 h-5"></i>
            <span class="text-xs font-bold">ตรวจสอบสถานะซิงค์</span>
        </button>
        */

        // ฟังก์ชันตรวจสอบสถานะ
        function checkSyncStatus() {
            closeSettingsMenu();
            
            const ยังไม่สำรวจ = syncQueue.filter(i => i.status === 'ยังไม่สำรวจ').length;
            const failed = syncQueue.filter(i => i.status === 'failed').length;
            const success = syncQueue.filter(i => i.status === 'success').length;
            
            let message = `📊 สถานะการซิงค์ข้อมูล:\n`;
            message += `✅ สำเร็จ: ${success} รายการ\n`;
            message += `⏳ รอซิงค์: ${ยังไม่สำรวจ} รายการ\n`;
            message += `❌ ล้มเหลว: ${failed} รายการ`;
            
            if (ยังไม่สำรวจ > 0) {
                message += `\n\n⚠️ มีข้อมูลที่ยังไม่ได้ซิงค์!`;
            }
            
            alert(message);
            
            // ถ้ามีข้อมูลรอซิงค์ ถามว่าต้องการซิงค์เลยไหม
            if (ยังไม่สำรวจ > 0 && isOnline) {
                if (confirm(`ต้องการซิงค์ข้อมูล ${ยังไม่สำรวจ} รายการที่รออยู่เลยหรือไม่?`)) {
                    processSyncQueue();
                }
            }
        }

        // ============================================
        // Auto-check and sync on app startup
        // ============================================

        async function checkAndSyncOnStartup() {
            console.log('ตรวจสอบข้อมูลที่รอซิงค์...');
            
            // โหลดคิวจาก localStorage
            loadSyncQueueFromStorage();
            
            // ตรวจสอบรูปภาพที่ยังไม่ได้ซิงค์
            try {
                const unsyncedImages = await getUnsyncedImages();
                const ยังไม่สำรวจCount = syncQueue.filter(i => i.status === 'ยังไม่สำรวจ').length;
                
                if (ยังไม่สำรวจCount > 0 || unsyncedImages.length > 0) {
                    const totalPending = ยังไม่สำรวจCount + unsyncedImages.length;
                    
                    showNotificationLeft(
                        `พบข้อมูลที่รอซิงค์ ${totalPending} รายการ`, 
                        'warning'
                    );
                    
                    // ถ้าออนไลน์ → เริ่มซิงค์ทันที
                    if (isOnline) {
                        setTimeout(() => {
                            showNotificationLeft('กำลังซิงค์ข้อมูล...', 'info');
                            processSyncQueue();
                        }, 1000);
                    } else {
                        showNotificationLeft('⚠️ อยู่ในโหมดออฟไลน์ - รอการเชื่อมต่อ', 'warning');
                    }
                }
            } catch (err) {
                console.error('Error checking ยังไม่สำรวจ data:', err);
            }
        }

        // ✅ มีเพียงระบบใหม่
        // ใช้ window.addEventListener แทน  เพื่อป้องกันการทับซ้อน
        window.addEventListener('load', async () => {
            // 1. เริ่มต้นแผนที่และไอคอน
            initMap();
            lucide.createIcons();
            loadExistingData();
            
            // 2. ตรวจสอบและซิงค์ข้อมูลที่ค้างอยู่ (สำคัญสำหรับระบบออฟไลน์)
            await checkAndSyncOnStartup();
            
            // 3. อัปเดตจุดแจ้งเตือนจำนวนข้อมูลที่รอซิงค์
            setInterval(() => {
                updateSyncBadge();
            }, 1000);

        window.addEventListener('beforeunload', () => {
            stopRealtimeAutoUpdate(); // ✅ หยุดระบบใหม่
        });
            
            // 4. ลงทะเบียน Service Worker สำหรับแคชไทล์
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('/sw.js')
                    .then((registration) => {
                        console.log('Service Worker registered:', registration.scope);
                    })
                    .catch((error) => {
                        console.log('Service Worker registration failed:', error);
                    });
            }
        });

        // แสดงจำนวนข้อมูลที่รอซิงค์ในปุ่มฟันเฟือง
        function updateSyncBadge() {
            const ยังไม่สำรวจ = syncQueue.filter(i => i.status === 'ยังไม่สำรวจ').length;
            const badge = document.getElementById('settings-badge');
            
            if (ยังไม่สำรวจ > 0) {
                badge.textContent = ยังไม่สำรวจ > 9 ? '9+' : ยังไม่สำรวจ;
                badge.classList.remove('hidden');
            } else {
                badge.classList.add('hidden');
            }
        }

        // เรียกใช้ทุกครั้งที่มีการเปลี่ยนแปลงคิว
        setInterval(updateSyncBadge, 1000);

        // ============================================
        // IndexedDB Storage for Images
        // ============================================

        let dbPromise = null;

        // เปิด/สร้าง IndexedDB
        function openDatabase() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('SurveyAppDB', 2);
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    
                    // สร้าง Store สำหรับรูปภาพ
                    if (!db.objectStoreNames.contains('images')) {
                        const imageStore = db.createObjectStore('images', { 
                            keyPath: 'id' 
                        });
                        imageStore.createIndex('timestamp', 'timestamp');
                        imageStore.createIndex('synced', 'synced');
                    }
                    
                    // สร้าง Store สำหรับข้อมูลซิงค์
                    if (!db.objectStoreNames.contains('syncQueue')) {
                        const queueStore = db.createObjectStore('syncQueue', { 
                            keyPath: 'id' 
                        });
                        queueStore.createIndex('status', 'status');
                        queueStore.createIndex('timestamp', 'timestamp');
                    }
                };
                
                request.onsuccess = (event) => {
                    resolve(event.target.result);
                };
                
                request.onerror = (event) => {
                    reject(event.target.error);
                };
            });
        }

        // บันทึกรูปภาพลงใน IndexedDB (พร้อมตรวจสอบพื้นที่และจัดการข้อผิดพลาด)
        async function saveImageToDB(imageData, filename, relatedId, type) {
            try {
                // ✅ ตรวจสอบขนาดรูปภาพก่อนบันทึก
                const estimateSize = Math.ceil(imageData.length * 0.75); // ประมาณขนาดจริง (ลบ 25% จาก base64)
                
                if (estimateSize > 50 * 1024 * 1024) { // เตือนถ้าเกิน 50MB
                    showNotificationLeft('⚠️ รูปภาพใหญ่เกินไป อาจใช้พื้นที่มาก', 'warning');
                }
                
                const db = await openDatabase();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction('images', 'readwrite');
                    const store = transaction.objectStore('images');
                    
                    const imageRecord = {
                        id: Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                        filename: filename,
                         imageData, // base64 string
                        relatedId: relatedId,
                        type: type, // 'building' หรือ 'sign'
                        timestamp: new Date().toISOString(),
                        synced: false,
                        retryCount: 0
                    };
                    
                    const request = store.add(imageRecord);
                    
                    request.onsuccess = () => {
                        console.log(`บันทึกรูปภาพสำเร็จ: ${filename} (${Math.round(estimateSize / 1024)} KB)`);
                        resolve(imageRecord.id);
                    };
                    
                    request.onerror = (event) => {
                        // ✅ ตรวจสอบข้อผิดพลาดพื้นที่เต็ม
                        if (event.target.error && event.target.error.name === 'QuotaExceededError') {
                            showNotificationLeft(
                                '❌ พื้นที่เก็บข้อมูลเต็ม! โปรดซิงค์ข้อมูลก่อนถ่ายรูปเพิ่ม',
                                'error'
                            );
                            reject(new Error('Storage quota exceeded'));
                        } else {
                            console.error('Error saving image to DB:', event.target.error);
                            reject(event.target.error);
                        }
                    };
                });
            } catch (err) {
                console.error('Error in saveImageToDB:', err);
                throw err;
            }
        }

        async function checkStorageSpace() {
            try {
                if ('storage' in navigator && 'estimate' in navigator.storage) {
                    const estimate = await navigator.storage.estimate();
                    const usage = estimate.usage || 0;
                    const quota = estimate.quota || 50 * 1024 * 1024; // 50MB default
                    
                    const usagePercent = (usage / quota) * 100;
                    
                    if (usagePercent > 80) {
                        showNotificationLeft(
                            `⚠️ พื้นที่เก็บข้อมูลเหลือน้อย (${Math.round(100 - usagePercent)}%)`,
                            'warning'
                        );
                    }
                    
                    if (usagePercent > 95) {
                        showNotificationLeft(
                            `❌ พื้นที่เก็บข้อมูลเกือบเต็ม! โปรดซิงค์ข้อมูล`,
                            'error'
                        );
                    }
                }
            } catch (err) {
                console.error('Error checking storage:', err);
            }
        }

        // ============================================
        // ฟังก์ชันดึงรูปภาพที่ยังไม่ได้ซิงค์ (แก้ไขแล้ว - ไม่ใช้ดัชนี boolean)
        // ============================================
        async function getUnsyncedImages() {
            const db = await openDatabase();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction('images', 'readonly');
                const store = transaction.objectStore('images');
                const request = store.openCursor(); // ✅ ไม่ใช้ดัชนี
                const unsyncedImages = [];
                
                request.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        const image = cursor.value;
                        // ✅ ตรวจสอบค่าโดยตรง
                        if (!image.synced || image.synced === false) {
                            unsyncedImages.push(image);
                        }
                        cursor.continue();
                    } else {
                        resolve(unsyncedImages);
                    }
                };
                
                request.onerror = (event) => {
                    console.error('Error getting unsynced images:', event.target.error);
                    reject(event.target.error);
                };
            });
        }

        // ============================================
        // ฟังก์ชันซิงค์รูปภาพ (แก้ไขแล้ว - ส่งให้ตรงกับเซิร์ฟเวอร์)
        // ============================================
        async function syncPendingImages() {
            try {
                const unsyncedImages = await getUnsyncedImages();
                if (unsyncedImages.length === 0) {
                    console.log('ℹ️ ไม่มีรูปภาพที่รอซิงค์');
                    return;
                }
                
                showNotificationLeft(`กำลังอัปโหลดรูปภาพ (${unsyncedImages.length} รูป)...`, 'info');
                console.log(`📤 เริ่มอัปโหลดรูปภาพ (${unsyncedImages.length} รูป)`);
                
                let successCount = 0;
                
                for (const image of unsyncedImages) {
                    try {
                        console.log(`📤 ส่งรูปภาพ: ${image.filename} (${image.relatedId})`);
                        
                        // ✅ ใช้ชื่อไฟล์ที่บันทึกไว้ใน IndexedDB (ไม่ต้องแยกอีก)
                        const payload = {};
                        
                        const body = new URLSearchParams();
                        body.append('action', 'update');
                        body.append('type', image.type);
                        body.append('rowKey', image.relatedId);
                        body.append('payload', JSON.stringify(payload));
                        body.append('image', image.imageData);
                        body.append('fileName', image.filename); // ✅ ใช้ชื่อที่ตั้งไว้แล้ว
                        
                        const res = await fetch(CONFIG.SCRIPT_URL.trim(), {
                            method: 'POST',
                            body,
                            timeout: 60000
                        });
                        
                        let result = null;
                        try {
                            result = await res.json();
                        } catch (parseErr) {
                            console.error(`❌ ไม่สามารถอ่านคำตอบจากเซิร์ฟเวอร์:`, parseErr);
                        }
                        
                        if (res.ok && result && (result.success === true || result.status === 200)) {
                            await markImageAsSynced(image.id);
                            successCount++;
                            console.log(`✅ อัปโหลดรูปภาพสำเร็จ: ${image.filename}`);
                            showNotificationLeft(`อัปโหลดรูปภาพ ${image.filename} สำเร็จ!`, 'success');
                        } else {
                            const errorMsg = result?.error || result?.message || `HTTP ${res.status}`;
                            console.error(`❌ อัปโหลดรูปภาพล้มเหลว: ${image.filename} - ${errorMsg}`);
                            
                            image.retryCount = (image.retryCount || 0) + 1;
                            if (image.retryCount >= 5) {
                                console.error(`❌ ยกเลิกหลังลอง ${image.retryCount} ครั้ง: ${image.filename}`);
                            }
                            
                            showNotificationLeft(`❌ ล้มเหลว: ${image.filename}`, 'error');
                        }
                    } catch (err) {
                        console.error(`❌ ข้อผิดพลาดในการอัปโหลด ${image.filename}:`, err);
                        image.retryCount = (image.retryCount || 0) + 1;
                        showNotificationLeft(`⚠️ ข้อผิดพลาด: ${image.filename}`, 'error');
                    }
                    
                    // รอ 2 วินาทีระหว่างส่งแต่ละรูป
                    await new Promise(resolve => setTimeout(resolve, 2000));
                }
                
                // ลบรูปภาพที่ซิงค์สำเร็จแล้ว
                await cleanupSyncedImages();
                
                if (successCount > 0) {
                    console.log(`✅ อัปโหลดรูปภาพสำเร็จทั้งหมด ${successCount}/${unsyncedImages.length} รูป`);
                }
            } catch (err) {
                console.error('❌ ข้อผิดพลาดในการซิงค์รูปภาพ:', err);
                showNotificationLeft('เกิดข้อผิดพลาดในการอัปโหลดรูปภาพ', 'error');
            }
        }

        // ============================================
        // ฟังก์ชันลบรูปภาพที่ซิงค์สำเร็จแล้ว (แก้ไขแล้ว - ไม่ใช้ดัชนี)
        // ============================================
        async function cleanupSyncedImages() {
            const db = await openDatabase();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction('images', 'readwrite');
                const store = transaction.objectStore('images');
                const request = store.openCursor(); // ✅ ไม่ใช้ดัชนี
                
                request.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        const image = cursor.value;
                        // ✅ ตรวจสอบค่าโดยตรง
                        if (image.synced === true) {
                            store.delete(cursor.primaryKey);
                        }
                        cursor.continue();
                    } else {
                        resolve();
                    }
                };
                
                request.onerror = (event) => {
                    console.error('Error cleaning up synced images:', event.target.error);
                    reject(event.target.error);
                };
            });
        }


        // ทำเครื่องหมายว่ารูปภาพซิงค์สำเร็จแล้ว
        async function markImageAsSynced(imageId) {
            const db = await openDatabase();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction('images', 'readwrite');
                const store = transaction.objectStore('images');
                
                const request = store.get(imageId);
                
                request.onsuccess = (event) => {
                    const image = event.target.result;
                    if (image) {
                        image.synced = true;
                        const updateRequest = store.put(image);
                        updateRequest.onsuccess = () => resolve();
                        updateRequest.onerror = () => reject(updateRequest.error);
                    } else {
                        reject(new Error('Image not found'));
                    }
                };
                
                request.onerror = () => {
                    reject(request.error);
                };
            });
        }

        // ลบรูปภาพที่ซิงค์สำเร็จแล้ว
        async function cleanupSyncedImages() {
            const db = await openDatabase();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction('images', 'readwrite');
                const store = transaction.objectStore('images');
                
                // ✅ ใช้ openCursor แทนการใช้ดัชนี (แก้ไขปัญหา IDBKeyRange)
                const request = store.openCursor();
                
                request.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        const image = cursor.value;
                        // ✅ ตรวจสอบค่าด้วยตนเอง
                        if (image.synced === true) {
                            store.delete(cursor.primaryKey);
                        }
                        cursor.continue();
                    } else {
                        resolve();
                    }
                };
                
                request.onerror = (event) => {
                    console.error('Error cleaning up synced images:', event.target.error);
                    reject(event.target.error);
                };
            });
        }

        // สร้างฟังก์ชันแสดงแจ้งเตือนฝั่งซ้าย
        function showNotificationLeft(message, type = 'info') {
            // ลบแจ้งเตือนเก่า
            const oldNotif = document.querySelector('.notification-left');
            if (oldNotif) oldNotif.remove();
            
            // กำหนดสีตามประเภท
            let bgColor = 'bg-blue-500';
            let icon = 'loader';
            
            if (type === 'success') {
                bgColor = 'bg-green-500';
                icon = 'check-circle';
            } else if (type === 'error') {
                bgColor = 'bg-red-500';
                icon = 'alert-circle';
            } else if (type === 'warning') {
                bgColor = 'bg-yellow-500';
                icon = 'alert-triangle';
            }
            
            // สร้างแจ้งเตือน
            const notif = document.createElement('div');
            notif.className = `fixed top-4 left-4 px-6 py-3 rounded-lg shadow-lg z-[2000] animate-fade-in notification-left ${bgColor} text-white font-bold flex items-center gap-2`;
            notif.innerHTML = `
                <i data-lucide="${icon}" class="w-5 h-5"></i>
                <span>${message}</span>
            `;
            
            document.body.appendChild(notif);
            lucide.createIcons({ elements: notif.querySelectorAll('[data-lucide]') });
            
            // ซ่อนอัตโนมัติหลัง 3 วินาที
            setTimeout(() => {
                notif.classList.add('animate-fade-out');
                setTimeout(() => notif.remove(), 300);
            }, 500);
        }

        // ============================================
        // อัปเดตแผนที่ด้วยตนเอง (จากเมนูตั้งค่า)
        // ============================================
        async function manualUpdateMap() {
            closeSettingsMenu();
            
            try {
                showNotificationLeft('กำลังตรวจสอบการอัปเดตแผนที่...', 'info');
                
                // ✅ ตรวจสอบว่ามีการเชื่อมต่ออินเทอร์เน็ต
                if (!navigator.onLine) {
                    showNotificationLeft('❌ ไม่มีการเชื่อมต่ออินเทอร์เน็ต', 'error');
                    return;
                }
                
                // ✅ ดาวน์โหลดแผนที่ใหม่ทันที
                await downloadAndCacheMap();
                
                // ✅ บันทึกเวลาตรวจสอบ
                const today = new Date().toDateString();
                localStorage.setItem(MAP_CONFIG.lastCheckKey, today);
                
                showNotificationLeft('✅ อัปเดตแผนที่สำเร็จ!', 'success');
                
            } catch (err) {
                console.error('❌ ข้อผิดพลาดในการอัปเดตแผนที่:', err);
                showNotificationLeft('อัปเดตแผนที่ล้มเหลว: ' + err.message, 'error');
            }
        }
 
        // ============================================
        // อัปเดตข้อมูลแบบเรียลไทม์
        // ============================================
        async function realtimeUpdate() {
            if (!navigator.onLine || isUpdating) return;
            
            isUpdating = true;
            try {
                const res = await fetch(`${CONFIG.SCRIPT_URL}?action=getData&t=${Date.now()}`);
                const newData = await res.json();
                
                // ✅ แก้ไข: ลบการตรวจสอบ timestamp ออก (เซิร์ฟเวอร์ไม่ได้ส่งมา)
                if (!newData.buildings || !newData.signs) { // ← ลบ newData.timestamp ||
                    console.warn('ข้อมูลจากเซิร์ฟเวอร์ไม่สมบูรณ์');
                    return;
                }
                
                // ตรวจสอบการเปลี่ยนแปลง
                const buildingChanges = detectChanges(allBuildings, newData.buildings);
                const signChanges = detectChanges(allSigns, newData.signs);
                
                // อัปเดตแผนที่และตาราง
                if (buildingChanges.total > 0) {
                    applyChanges(buildingChanges, 'building');
                    showUpdateNotification(buildingChanges, 'สิ่งปลูกสร้าง');
                }
                
                if (signChanges.total > 0) {
                    applyChanges(signChanges, 'sign');
                    showUpdateNotification(signChanges, 'ป้าย');
                }
                
                // อัปเดตข้อมูลแคช
                allBuildings = newData.buildings;
                allSigns = newData.signs;
                
                console.log('✅ อัปเดตข้อมูลเรียลไทม์สำเร็จ');
            } catch (err) {
                console.error('❌ ข้อผิดพลาดในการอัปเดต:', err);
            } finally {
                isUpdating = false;
            }
        }

        // ตรวจจับการเปลี่ยนแปลง
        function detectChanges(oldData, newData) {
            const oldMap = new Map(oldData.map(item => [item.id || item._row_num, item]));
            const newMap = new Map(newData.map(item => [item.id || item._row_num, item]));
            
            const added = [];
            const updated = [];
            const deleted = [];
            
            // หาข้อมูลที่เพิ่มใหม่
            newData.forEach(item => {
                const id = item.id || item._row_num;
                if (!oldMap.has(id)) added.push(item);
            });
            
            // หาข้อมูลที่อัปเดต
            newData.forEach(item => {
                const id = item.id || item._row_num;
                const oldItem = oldMap.get(id);
                if (oldItem && JSON.stringify(oldItem) !== JSON.stringify(item)) {
                    updated.push(item);
                }
            });
            
            // หาข้อมูลที่ถูกลบ
            oldData.forEach(item => {
                const id = item.id || item._row_num;
                if (!newMap.has(id)) deleted.push(item);
            });
            
            return { 
                added, 
                updated, 
                deleted,
                total: added.length + updated.length + deleted.length
            };
        }

        // ประยุกต์การเปลี่ยนแปลง
        function applyChanges(changes, type) {
            // ลบมาร์กเกอร์ที่ถูกลบ
            changes.deleted.forEach(item => {
                surveyLayers.eachLayer(layer => {
                    if (layer._popupData && 
                        (layer._popupData.id === item.id || layer._popupData._row_num === item._row_num)) {
                        surveyLayers.removeLayer(layer);
                    }
                });
            });
            
            // อัปเดตหรือเพิ่มมาร์กเกอร์ใหม่
            [...changes.added, ...changes.updated].forEach(item => {
                if (!item.lat_long) return;
                
                const coords = item.lat_long.split(',').map(Number);
                if (coords.length < 2 || isNaN(coords[0]) || isNaN(coords[1])) return;
                
                // ค้นหามาร์กเกอร์ที่มีอยู่
                let existingMarker = null;
                surveyLayers.eachLayer(layer => {
                    if (layer._popupData && 
                        (layer._popupData.id === item.id || layer._popupData._row_num === item._row_num)) {
                        existingMarker = layer;
                    }
                });
                
                if (existingMarker) {
                    // อัปเดตมาร์กเกอร์ที่มีอยู่
                    existingMarker.setLatLng(L.latLng(coords[0], coords[1]));
                    existingMarker._popupData = item;
                    setupMarkerPopup(existingMarker, item, type);
                } else {
                    // เพิ่มมาร์กเกอร์ใหม่
                    const marker = createCircleMarker(L.latLng(coords[0], coords[1]), type, isEditMode);
                    marker._popupData = item;
                    setupMarkerPopup(marker, item, type);
                    marker.addTo(surveyLayers);
                    if (isEditMode) enableMarkerDragging(marker, item);
                }
            });
            
            // อัปเดตตาราง
            if (type === 'building') renderBuildingTable();
            else renderSignTable();
        }

        // แสดงการแจ้งเตือน
        function showUpdateNotification(changes, typeName) {
            if (changes.total === 0) return;
            
            let message = `🔄 มีการอัปเดต${typeName} `;
            const parts = [];
            if (changes.added.length > 0) parts.push(`เพิ่ม ${changes.added.length}`);
            if (changes.updated.length > 0) parts.push(`แก้ไข ${changes.updated.length}`);
            if (changes.deleted.length > 0) parts.push(`ลบ ${changes.deleted.length}`);
            
            message += parts.join(', ');
            showNotificationLeft(message, 'info');
        }

        // ============================================
        // เริ่มระบบอัปเดตอัตโนมัติ
        // ============================================
        function startRealtimeAutoUpdate() {
            if (autoUpdateInterval) clearInterval(autoUpdateInterval);
            
            autoUpdateInterval = setInterval(() => {
                if (!isUpdating && navigator.onLine) {
                    realtimeUpdate();
                }
            }, 5000); // 5 วินาที
            
            console.log('✅ เริ่มระบบอัปเดตเรียลไทม์ทุก 5 วินาที');
        }

        // ============================================

        // ============================================
        // ข้อ 1.1: คำนวณพื้นที่ (กว้าง × ยาว)
        // ============================================
        let areaCalculatorModal = null;

        function openAreaCalculator() {
            // ปิดโมดัลเก่าถ้ามี
            if (areaCalculatorModal) {
                areaCalculatorModal.remove();
            }
            
            // สร้างหน้าต่างคำนวณพื้นที่
            areaCalculatorModal = document.createElement('div');
            areaCalculatorModal.className = 'fixed inset-0 bg-black/20 z-[3000] flex items-center justify-center p-4 pointer-events-none'; // ✅ เพิ่ม pointer-events-none
            areaCalculatorModal.innerHTML = `
            <div class="bg-white/90 backdrop-blur-sm rounded-xl shadow-2xl w-full max-w-md animate-scale-in pointer-events-auto"> <!-- ✅ เพิ่ม pointer-events-auto -->
                <div class="p-4 border-b flex justify-between items-center">
                    <h3 class="font-bold text-lg text-blue-900">คำนวณพื้นที่ประกอบการ</h3>
                    <button onclick="closeAreaCalculator()" class="p-2 hover:bg-gray-200 rounded-full">
                        <i data-lucide="x" class="w-5 h-5"></i>
                    </button>
                </div>
                <div class="p-4 space-y-4">
                    <div class="grid grid-cols-2 gap-3">
                        <div>
                            <label class="form-label">กว้าง (ม.)</label>
                            <input type="number" id="calc-width" class="form-input text-center" placeholder="" step="0.01" oninput="calculateAreaResult()" style="-webkit-appearance: textfield; -moz-appearance: textfield; appearance: textfield;">
                        </div>
                        <div>
                            <label class="form-label">ยาว (ม.)</label>
                            <input type="number" id="calc-length" class="form-input text-center" placeholder="" step="0.01" oninput="calculateAreaResult()" style="-webkit-appearance: textfield; -moz-appearance: textfield; appearance: textfield;">
                        </div>
                    </div>
                    <div>
                        <label class="form-label">ผลลัพธ์ (ตร.ม.)</label>
                        <input type="number" id="calc-result" class="form-input bg-custom-green/80 font-bold text-center" readonly placeholder="ผลลัพธ์พื้นที่ประกอบการ" style="-webkit-appearance: textfield; -moz-appearance: textfield; appearance: textfield;"> <!-- ✅ ลดความทึบของสีเขียว -->
                    </div>
                    <div class="flex gap-2">
                        <button type="button" onclick="clearAreaCalculator()" 
                            class="flex-1 py-2 bg-gray-500 text-white rounded font-bold hover:bg-gray-600 transition">
                            <i data-lucide="trash-2" class="w-4 h-4 inline mr-1"></i>
                            ล้าง
                        </button>
                        <button type="button" onclick="addAreaToField()" 
                            class="flex-1 py-2 bg-blue-600 text-white rounded font-bold hover:bg-blue-700 transition">
                            <i data-lucide="plus" class="w-4 h-4 inline mr-1"></i>
                            บวกเพิ่ม
                        </button>
                    </div>
                </div>
            </div>
            `;
            document.body.appendChild(areaCalculatorModal);
            lucide.createIcons();
            
            // ✅ ป้องกันการเปลี่ยนค่าโดยการหมุนเมาส์ในช่องกรอกตัวเลขของหน้าต่างคำนวณพื้นที่
            const preventWheel = (e) => e.preventDefault();
            ['calc-width', 'calc-length', 'calc-result'].forEach(id => {
                const input = document.getElementById(id);
                if (input) {
                    input.addEventListener('wheel', preventWheel, { passive: false });
                    // ✅ ป้องกันการกดปุ่มลูกศรบน/ล่างด้วย (เพิ่มเติมเพื่อความสมบูรณ์)
                    input.addEventListener('keydown', (e) => {
                        if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                            e.preventDefault();
                        }
                    });
                }
            });
            
            // โฟกัสที่ช่องกว้าง
            document.getElementById('calc-width')?.focus();
        }

        // คำนวณผลลัพธ์เรียลไทม์
        function calculateAreaResult() {
            const width = parseFloat(document.getElementById('calc-width').value) || 0;
            const length = parseFloat(document.getElementById('calc-length').value) || 0;
            const result = width * length;
            document.getElementById('calc-result').value = result.toFixed(2);
        }

        // ล้างค่า
        function clearAreaCalculator() {
            document.getElementById('calc-width').value = '';
            document.getElementById('calc-length').value = '';
            document.getElementById('calc-result').value = '0';
        }

        // บวกเพิ่มค่าในช่อง buse_area2
        function addAreaToField() {
            const result = parseFloat(document.getElementById('calc-result').value) || 0;
            const buseArea2Field = document.querySelector('input[name="buse_area2"]');
            
            if (!buseArea2Field) {
                showNotificationLeft('ไม่พบช่องกรอกพื้นที่ใช้ (2)', 'error');
                return;
            }
            
            const currentValue = parseFloat(buseArea2Field.value) || 0;
            const newValue = currentValue + result;
            
            buseArea2Field.value = newValue.toFixed(2);
            showNotificationLeft(`เพิ่มพื้นที่ ${result.toFixed(2)} ตร.ม. รวมเป็น ${newValue.toFixed(2)} ตร.ม.`, 'success');
            
            // ✅ ล้างค่าช่องกว้างและยาว แต่ไม่ปิดหน้าต่าง เพื่อให้ผู้ใช้สามารถคำนวณเพิ่มได้อีก
            document.getElementById('calc-width').value = '';
            document.getElementById('calc-length').value = '';
            document.getElementById('calc-result').value = '0';
            document.getElementById('calc-width').focus();
        }

        // ปิดหน้าต่าง
        function closeAreaCalculator() {
            if (areaCalculatorModal) {
                areaCalculatorModal.classList.add('animate-scale-out');
                setTimeout(() => {
                    if (areaCalculatorModal && areaCalculatorModal.parentNode) {
                        areaCalculatorModal.remove();
                    }
                    areaCalculatorModal = null;
                }, 200);
            }
        }

        // ============================================
        // ข้อ 1.2: คำนวณผลต่าง (b_area - buse_area2)
        // ============================================
        function calculateDeltaArea() {
            const bAreaField = document.querySelector('input[name="b_area"]');
            const buseArea2Field = document.querySelector('input[name="buse_area2"]');
            const buseAreaField = document.querySelector('input[name="buse_area"]');
            
            if (!bAreaField || !buseArea2Field || !buseAreaField) {
                showNotificationLeft('ไม่พบฟิลด์ที่ต้องการ', 'error');
                return;
            }
            
            const bArea = parseFloat(bAreaField.value) || 0;
            const buseArea2 = parseFloat(buseArea2Field.value) || 0;
            
            if (buseArea2 === 0) {
                showNotificationLeft('⚠️ ช่อง "พื้นที่ใช้ (2)" ยังไม่มีค่า', 'warning');
                return;
            }
            
            const result = bArea - buseArea2;
            
            if (result < 0) {
                showNotificationLeft('❌ ผลลัพธ์ติดลบ ตรวจสอบค่าอีกครั้ง', 'error');
                return;
            }
            
            buseAreaField.value = result.toFixed(2);
            showNotificationLeft(`คำนวณผลต่าง: ${bArea.toFixed(2)} - ${buseArea2.toFixed(2)} = ${result.toFixed(2)} ตร.ม.`, 'success');
        }

        // แปลงค่าวันที่จากชีทกลับเป็นรูปแบบ "1-1", "1-2" ฯลฯ
        function normalizeFloorValue(value) {
            // กรณีเป็นวันที่ (เช่น "2025-12-31T17:00:00.000Z")
            if (typeof value === 'string' && value.includes('T') && value.includes('Z')) {
                try {
                    const date = new Date(value);
                    const month = date.getMonth() + 1;
                    const day = date.getDate();
                    return `${day}-${month}`;
                } catch (e) {
                    return '';
                }
            }
            // กรณีเป็นตัวเลข (serial number ของชีท)
            else if (typeof value === 'number' && value > 365) {
                const baseDate = new Date('1899-12-30');
                baseDate.setDate(baseDate.getDate() + Math.floor(value));
                const month = baseDate.getMonth() + 1;
                const day = baseDate.getDate();
                return `${day}-${month}`;
            }
            // กรณีปกติ
            return value || '';
        }





        // ประยุกต์การเปลี่ยนแปลงเฉพาะจุด
        async function applyDeltaUpdates(records, type) {
            for (const record of records) {
                const id = record.id || record._row_num;
                
                // ค้นหามาร์กเกอร์ที่มีอยู่
                let existingMarker = null;
                surveyLayers.eachLayer(layer => {
                    if (layer._popupData && (layer._popupData.id === id || layer._popupData._row_num === id)) {
                        existingMarker = layer;
                    }
                });
                
                if (existingMarker) {
                    // ✅ อัปเดตมาร์กเกอร์ที่มีอยู่ (ไม่ลบรีโหลดใหม่ทั้งหมด)
                    existingMarker._popupData = { ...existingMarker._popupData, ...record };
                    setupMarkerPopup(existingMarker, existingMarker._popupData, type);
                    
                    // อัปเดตพิกัดถ้ามีการเปลี่ยนแปลง
                    if (record.lat_long && record.lat_long !== existingMarker._popupData.lat_long) {
                        const coords = record.lat_long.split(',').map(Number);
                        existingMarker.setLatLng(L.latLng(coords[0], coords[1]));
                    }
                } else {
                    // ✅ เพิ่มมาร์กเกอร์ใหม่
                    if (record.lat_long) {
                        const coords = record.lat_long.split(',').map(Number);
                        const marker = createCircleMarker(L.latLng(coords[0], coords[1]), type, isEditMode);
                        marker._popupData = record;
                        setupMarkerPopup(marker, record, type);
                        marker.addTo(surveyLayers);
                        if (isEditMode) enableMarkerDragging(marker, record);
                    }
                }
            }
            
            // อัปเดตตารางข้อมูล
            if (type === 'building') {
                allBuildings = [...allBuildings.filter(b => !records.some(r => r.id === b.id)), ...records];
                renderBuildingTable();
            } else {
                allSigns = [...allSigns.filter(s => !records.some(r => r.id === s.id)), ...records];
                renderSignTable();
            }
        }

        // ลบมาร์กเกอร์ที่ถูกลบ
        function removeDeletedMarkers(deletedIds) {
            surveyLayers.eachLayer(layer => {
                if (layer._popupData && deletedIds.includes(layer._popupData.id || layer._popupData._row_num)) {
                    surveyLayers.removeLayer(layer);
                }
            });
            
            // อัปเดตตาราง
            allBuildings = allBuildings.filter(b => !deletedIds.includes(b.id));
            allSigns = allSigns.filter(s => !deletedIds.includes(s.id));
            renderBuildingTable();
            renderSignTable();
        }

        // อัปเดตเฉพาะมาร์กเกอร์ที่เปลี่ยนแปลง
        async function updateChangedMarkers(data) {
            const currentMarkers = {};
            
            // เก็บข้อมูลมาร์กเกอร์ปัจจุบัน
            surveyLayers.eachLayer(layer => {
                if (layer._popupData && layer._popupData.id) {
                    currentMarkers[layer._popupData.id] = layer;
                }
            });
            
            // ล้างมาร์กเกอร์ทั้งหมด
            surveyLayers.clearLayers();
            
            // สร้างมาร์กเกอร์ใหม่จากข้อมูล
            const allData = [...(data.buildings || []), ...(data.signs || [])];
            
            for (const item of allData) {
                if (!item.lat_long) continue;
                
                const coords = item.lat_long.split(',').map(Number);
                if (coords.length < 2 || isNaN(coords[0]) || isNaN(coords[1])) continue;
                
                const type = item.building_c ? 'building' : 'sign';
                const latLng = L.latLng(coords[0], coords[1]);
                
                // ตรวจสอบว่ามีมาร์กเกอร์เดิมหรือไม่
                const existingMarker = currentMarkers[item.id];
                
                if (existingMarker) {
                    // อัปเดตข้อมูลในมาร์กเกอร์เดิม
                    existingMarker.setLatLng(latLng);
                    existingMarker._popupData = item;
                    setupMarkerPopup(existingMarker, item, type);
                    existingMarker.addTo(surveyLayers);
                    
                    if (isEditMode) enableMarkerDragging(existingMarker, item);
                } else {
                    // สร้างมาร์กเกอร์ใหม่
                    const m = createCircleMarker(latLng, type, isEditMode);
                    setupMarkerPopup(m, item, type);
                    m.addTo(surveyLayers);
                    
                    if (isEditMode) enableMarkerDragging(m, item);
                }
            }
        }


        // ใช้ MarkerCluster สำหรับมาร์กเกอร์จำนวนมาก
        let markerCluster = null;

        function initMarkerClustering() {
            // สร้าง MarkerCluster Group
            markerCluster = L.markerClusterGroup({
                maxClusterRadius: 80, // ระยะห่างที่จะรวมเป็นคลัสเตอร์
                disableClusteringAtZoom: 16, // ปิดคลัสเตอร์เมื่อซูมใกล้
                chunkedLoading: true, // โหลดแบบแบ่งชิ้นส่วน
                chunkInterval: 200, // เวลาในการโหลดแต่ละชิ้น (มิลลิวินาที)
                chunkDelay: 50 // ดีเลย์ระหว่างการโหลด
            });
            
            // เพิ่มมาร์กเกอร์ลงในคลัสเตอร์แทนการเพิ่มลงแผนที่โดยตรง
            markerCluster.addTo(map);
        }

        // แปลงลิงก์ Google Drive เป็นลิงก์썸เนลที่ใช้ได้กับ <img> (วิธีที่ใช้งานได้จริง)
        function convertDriveUrlToDirect(url) {
            if (!url) return url;
            url = url.trim();
            
            // ✅ กรณีที่เป็นลิงก์썸เนลแล้ว → คืนค่าเดิม
            if (url.includes('drive.google.com/thumbnail')) {
                return url;
            }
            
            // ✅ กรณีที่เป็นลิงก์ตรงจาก Googleusercontent → คืนค่าเดิม
            if (url.includes('googleusercontent.com')) {
                return url;
            }
            
            // ✅ ดึง FILE_ID จากลิงก์รูปแบบต่างๆ
            let fileId = '';
            
            // รูปแบบที่ 1: /file/d/FILE_ID/view
            const pattern1 = /\/file\/d\/([a-zA-Z0-9_-]+)/;
            const match1 = url.match(pattern1);
            if (match1 && match1[1]) {
                fileId = match1[1];
            }
            
            // รูปแบบที่ 2: /uc?export=view&id=FILE_ID
            if (!fileId) {
                const pattern2 = /id=([a-zA-Z0-9_-]+)/;
                const match2 = url.match(pattern2);
                if (match2 && match2[1]) {
                    fileId = match2[1];
                }
            }
            
            // รูปแบบที่ 3: /open?id=FILE_ID
            if (!fileId) {
                const pattern3 = /open\?id=([a-zA-Z0-9_-]+)/;
                const match3 = url.match(pattern3);
                if (match3 && match3[1]) {
                    fileId = match3[1];
                }
            }
            
            // ✅ สร้างลิงก์썸เนล (ใช้งานได้จริงกับ <img>)
            if (fileId) {
                // sz=w1000 → ความกว้าง 1000px (ปรับอัตโนมัติ), ใช้ w2000 สำหรับความละเอียดสูงขึ้น
                return `https://drive.google.com/thumbnail?id=${fileId}&sz=w1000`;
            }
            
            // ✅ ถ้าไม่ใช่ลิงก์ Google Drive → คืนค่าเดิม
            return url;
        }

        // แสดงรูปภาพในองค์ประกอบแสดงผล
        function showImagePreview(imageUrl, fileName) {
            const container = document.getElementById('image-preview-container');
            const img = document.getElementById('image-preview');
            const placeholder = document.getElementById('image-preview-placeholder');
            
            if (!imageUrl || !imageUrl.trim()) {
                hideImagePreview();
                return;
            }
            
            // ✅ แสดงองค์ประกอบ
            container.style.display = 'flex';
            
            // ✅ แปลงลิงก์ Google Drive เป็นลิงก์ดาวน์โหลดตรง (สำคัญที่สุด!)
            const directUrl = convertDriveUrlToDirect(imageUrl);
            console.log('🖼️ ลิงก์รูปภาพ (หลังแปลง):', directUrl);
            
            // โหลดรูปภาพด้วยลิงก์ที่แปลงแล้ว
            img.src = directUrl; // ✅ ใช้ directUrl แทน imageUrl
            img.alt = fileName || 'รูปภาพ';
            img.classList.remove('hidden');
            placeholder.classList.add('hidden');
            
            // จัดการกรณีโหลดรูปภาพล้มเหลว
            img.onerror = () => {
                img.classList.add('hidden');
                placeholder.textContent = '❌ ไม่สามารถโหลดรูปภาพได้';
                placeholder.classList.remove('hidden');
                placeholder.classList.add('text-red-400');
                console.error('❌ โหลดรูปภาพล้มเหลว:', directUrl);
            };
            
            // ✅ ปรับตำแหน่งตามสถานะของตาราง
            const tablePanel = document.getElementById('data-table-panel');
            if (tablePanel && tablePanel.classList.contains('open')) {
                container.style.bottom = `calc(5px + 45vh + 10px)`;
            } else {
                container.style.bottom = '5px';
            }
            
            // ✅ สร้างไอคอน Lucide สำหรับปุ่มปิด
            lucide.createIcons();
        }

        // ซ่อนองค์ประกอบแสดงรูปภาพ (เมื่อผู้ใช้คลิกปุ่มปิด)
        function hideImagePreview() {
            const container = document.getElementById('image-preview-container');
            if (container) {
                container.style.display = 'none';
                console.log('🖼️ ซ่อนหน้าต่างรูปภาพ');
            }
        }

        // จัดการการคลิกที่ป้ายชื่อรูปภาพ
        function handleImageBadgeClick(imageUrl, fileName) {
            if (!imageUrl || imageUrl.trim() === '') {
                showNotificationLeft('ไม่มีรูปภาพให้แสดง', 'warning');
                return;
            }
            
            // แสดงรูปภาพในองค์ประกอบแสดงผล
            showImagePreview(imageUrl, fileName);
        }


        // เมื่อสร้างมาร์กเกอร์ใหม่
        function createCircleMarker(latlng, type, isDraggable = false) {
            const className = type === 'building' ? 'circle-building' : 'circle-sign';
            
            const icon = L.divIcon({
                className: `circle-marker ${className}`,
                iconSize: [14, 14],
                iconAnchor: [7, 7]
            });
            
            const marker = L.marker(latlng, {
                icon: icon,
                draggable: isDraggable, // ✅ ตั้งค่าตอนสร้าง
                zIndexOffset: 1000
            });
            
            // ✅ ลบการผูกคลิกออกทั้งหมด - Leaflet จะจัดการอัตโนมัติเมื่อใช้ bindPopup
            
            // ✅ ผูกเหตุการณ์ลากเฉพาะเมื่อเป็นโหมดแก้ไข
            if (isDraggable) {
                marker.on('dragstart', function(e) {
                    if (e.originalEvent) L.DomEvent.stopPropagation(e.originalEvent);
                    if (marker.getPopup()) marker.closePopup();
                });
                
                marker.on('dragend', async function(e) {
                    const newLatLng = e.target.getLatLng();
                    const data = e.target._popupData;
                    if (data && typeof updateMarkerPosition === 'function') {
                        await updateMarkerPosition(e.target, data, newLatLng);
                    }
                });
            }
            
            return marker;
        }

        // ============================================
        // ดาวน์โหลดรูปทั้งหมดจากสเปรดชีต
        // ============================================
        document.addEventListener('DOMContentLoaded', function() {
            const downloadBtn = document.getElementById('download-all-images');
            if (downloadBtn) {
                downloadBtn.addEventListener('click', async function() {
                    try {
                        showNotificationLeft('กำลังโหลดข้อมูลรูปภาพ...', 'info');
                        
                        // ดึงข้อมูลจากสเปรดชีต
                        const response = await fetch(CONFIG.SCRIPT_URL + '?action=getData');
                        const data = await response.json();
                        
                        // รวมรูปจากทั้งอาคารและป้าย
                        const allImages = [
                            ...data.buildings.filter(b => b.image && b.image.includes('http')),
                            ...data.signs.filter(s => s.image && s.image.includes('http'))
                        ];
                        
                        if (allImages.length === 0) {
                            showNotificationLeft('⚠️ ไม่พบรูปภาพในระบบ', 'warning');
                            return;
                        }
                        
                        showNotificationLeft(`กำลังดาวน์โหลด ${allImages.length} รูปภาพ...`, 'info');
                        
                        // ดาวน์โหลดทีละรูป
                        for (let i = 0; i < allImages.length; i++) {
                            const item = allImages[i];
                            const imageUrl = item.image;
                            const fileName = item.picture || `image_${i + 1}.jpg`;
                            
                            try {
                                // ดาวน์โหลดรูป
                                const imgResponse = await fetch(imageUrl);
                                const blob = await imgResponse.blob();
                                
                                // สร้างลิงก์ดาวน์โหลด
                                const link = document.createElement('a');
                                link.href = URL.createObjectURL(blob);
                                link.download = fileName;
                                document.body.appendChild(link);
                                link.click();
                                document.body.removeChild(link);
                                URL.revokeObjectURL(link.href);
                                
                                console.log(`✅ ดาวน์โหลด: ${fileName}`);
                                
                                // รอ 500ms ระหว่างดาวน์โหลดแต่ละรูป
                                if (i < allImages.length - 1) {
                                    await new Promise(resolve => setTimeout(resolve, 500));
                                }
                            } catch (err) {
                                console.error(`❌ ดาวน์โหลด ${fileName} ล้มเหลว:`, err);
                                showNotificationLeft(`⚠️ ดาวน์โหลด ${fileName} ล้มเหลว`, 'error');
                            }
                        }
                        
                        showNotificationLeft(`✅ ดาวน์โหลดรูปภาพทั้งหมด (${allImages.length} รูป) เสร็จสิ้น!`, 'success');
                    } catch (err) {
                        console.error('❌ ข้อผิดพลาด:', err);
                        showNotificationLeft('❌ ดาวน์โหลดล้มเหลว: ' + err.message, 'error');
                    }
                });
            }
        });

        // ============================================
        // ป้องกันการเปลี่ยนค่าช่องตัวเลขโดยไม่ตั้งใจเมื่อหมุนสกอร์ลเมาส์
        // ============================================
        document.addEventListener('DOMContentLoaded', function() {
          const surveyForm = document.getElementById('survey-form');
          if (surveyForm) {
            // ใช้ event delegation ครอบคลุมทุกช่องตัวเลขแม้สร้างแบบไดนามิก
            surveyForm.addEventListener('wheel', function(e) {
              if (e.target.tagName === 'INPUT' && e.target.type === 'number') {
                e.preventDefault(); // ป้องกันการเปลี่ยนค่าเมื่อหมุนสกอร์ล
              }
            }, { passive: false }); // ต้องตั้ง passive: false เพื่อเรียก preventDefault()
            
            console.log('✅ เปิดใช้งานการป้องกันการเปลี่ยนค่าช่องตัวเลขโดยไม่ตั้งใจ');
          }
        });

        // ฟังก์ชันโหลดมาร์กเกอร์เฉพาะที่มองเห็น + buffer
        function loadVisibleMarkers() {
            // เก็บจุดชั่วคราวทั้งหมดก่อนล้าง
            const ยังไม่สำรวจMarkers = [];
            if (markerCluster) {
                markerCluster.eachLayer(layer => {
                    if (layer._popupData) {
                        if (layer._popupData.queued || layer._popupData.tempMarker) {
                            ยังไม่สำรวจMarkers.push({
                                latlng: layer.getLatLng(),
                                data: layer._popupData,
                                type: layer._popupData.type
                            });
                        }
                    }
                });
            } else {
                surveyLayers.eachLayer(layer => {
                    if (layer._popupData) {
                        if (layer._popupData.queued || layer._popupData.tempMarker) {
                            ยังไม่สำรวจMarkers.push({
                                latlng: layer.getLatLng(),
                                data: layer._popupData,
                                type: layer._popupData.type
                            });
                        }
                    }
                });
            }
            
            const bounds = map.getBounds();
            const bufferRatio = isMobile() ? 1.5 : 2.0;
            const bufferedBounds = bounds.pad(bufferRatio);
            
            // ล้างมาร์กเกอร์ทั้งหมด
            if (markerCluster) {
                markerCluster.clearLayers();
            } else {
                surveyLayers.clearLayers();
            }
            
            // โหลดเฉพาะมาร์กเกอร์ที่อยู่ในขอบเขต + buffer
            allBuildings.forEach(r => {
                if (!r.lat_long) return;
                const coords = r.lat_long.split(',').map(Number);
                if (coords.length < 2 || isNaN(coords[0]) || isNaN(coords[1])) return;
                const latLng = L.latLng(coords[0], coords[1]);
                if (!bufferedBounds.contains(latLng)) return;
                
                // ✅ ตรวจสอบว่าจุดนี้กำลังถูกย้ายหรือไม่
                const recordKey = r._row_num || r.id;
                if (markersBeingMoved.has(recordKey)) {
                    return; // ข้ามการสร้างจุดจริง
                }
                
                const m = createCircleMarker(latLng, 'building', isEditMode);
                setupMarkerPopup(m, r, 'building');
                if (markerCluster) {
                    markerCluster.addLayer(m);
                } else {
                    m.addTo(surveyLayers);
                }
            });
            
            allSigns.forEach(r => {
                if (!r.lat_long) return;
                const coords = r.lat_long.split(',').map(Number);
                if (coords.length < 2 || isNaN(coords[0]) || isNaN(coords[1])) return;
                const latLng = L.latLng(coords[0], coords[1]);
                if (!bufferedBounds.contains(latLng)) return;
                
                // ✅ ตรวจสอบว่าจุดนี้กำลังถูกย้ายหรือไม่
                const recordKey = r._row_num || r.id; // ✅ เพิ่มบรรทัดนี้
                if (markersBeingMoved.has(recordKey)) { // ✅ แก้เป็น recordKey
                    return;
                }
                
                const m = createCircleMarker(latLng, 'sign', isEditMode);
                setupMarkerPopup(m, r, 'sign');
                if (markerCluster) {
                    markerCluster.addLayer(m);
                } else {
                    m.addTo(surveyLayers);
                }
            });
            
            // เพิ่มจุดชั่วคราวกลับเข้ามา
            ยังไม่สำรวจMarkers.forEach(marker => {
                const m = createCircleMarker(marker.latlng, marker.type, isEditMode);
                m._popupData = marker.data;
                setupMarkerPopup(m, marker.data, marker.type);
                if (markerCluster) {
                    markerCluster.addLayer(m);
                } else {
                    m.addTo(surveyLayers);
                }
                if (isEditMode) enableMarkerDragging(m, marker.data);
            });
        }

        // เรียกใช้เมื่อเลื่อนหรือซูมแผนที่
        map.on('moveend', loadVisibleMarkers);
        map.on('zoomend', loadVisibleMarkers);

        // ============================================
        // 1. แก้ไขฟังก์ชัน refreshData (ใช้ระบบใหม่)
        // ============================================
        function refreshData() {
            const refreshBtn = document.getElementById('btn-refresh');
            const refreshIcon = document.getElementById('refresh-icon');
            
            disableRefreshButton();
            refreshIcon.classList.add('animate-spin');
            
            // ✅ เปลี่ยนจาก smartLoadData() เป็น loadExistingData()
            loadExistingData().finally(() => {
                setTimeout(() => {
                    refreshIcon.classList.remove('animate-spin');
                    enableRefreshButton();
                }, 500);
            });
        }

        // ============================================
        // 1. วางก่อน `window.addEventListener('load')` ทั้งหมด
        // ============================================

        // หยุดระบบอัปเดตเมื่อปิดหน้าต่าง
        window.addEventListener('beforeunload', () => {
            stopRealtimeAutoUpdate();
        });

        // ตรวจจับการเชื่อมต่อออนไลน์
        window.addEventListener('online', () => {
            isOnline = true;
            updateConnectionStatus();
            // เมื่อกลับมาออนไลน์ ให้พยายามส่งข้อมูลที่ค้างอยู่
            setTimeout(processSyncQueue, 1000);
        });

        // ตรวจจับการออฟไลน์
        window.addEventListener('offline', () => {
            isOnline = false;
            updateConnectionStatus();
        });

        // ============================================
        // 2. เริ่มต้นแอป (มีเพียง 1 ครั้งเดียว)
        // ============================================
        window.addEventListener('load', async () => {
            // 1. เริ่มต้นแผนที่และไอคอน
            initMap();
            lucide.createIcons();
            
            // 2. โหลดข้อมูลและเริ่มระบบอัปเดต
            await loadExistingData();           // ← โหลดข้อมูลครั้งแรก
            startRealtimeAutoUpdate();          // ← เริ่มระบบอัปเดตอัตโนมัติ (สำคัญที่สุด!)
            
            // 3. ตรวจสอบและซิงค์ข้อมูลที่ค้างอยู่
            await checkAndSyncOnStartup();
            
            // 4. อัปเดตจุดแจ้งเตือนจำนวนข้อมูลที่รอซิงค์
            setInterval(updateSyncBadge, 1000);
            
            // 5. ลงทะเบียน Service Worker
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => console.log('Service Worker registered:', registration.scope))
                    .catch(error => console.log('Service Worker registration failed:', error));
            }
        });

        // ฟังก์ชันแสดงชื่อไฟล์ที่เลือก
        function updateFileName(input, fieldId) {
        const filenameSpan = document.getElementById(`filename-${fieldId}`);
        if (!filenameSpan) return;
        if (input.files && input.files[0]) {
        const filename = input.files[0].name;
        filenameSpan.textContent = filename;
        filenameSpan.classList.remove('hidden');
        filenameSpan.classList.add('bg-blue-100', 'text-blue-800');
        } else {
        filenameSpan.classList.add('hidden');
        }
        }

    </script>
</body>

</html>
<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="โนนไทย">

    <meta name="theme-color" content="#2563eb">
    <title>โนนไทย</title>
    <link rel="manifest" href="manifest.json">
    <link rel="icon" href="static/icons/lb.ico" type="image/x-icon"> <!-- แก้เป็นพาธสัมพัทธ์ -->
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <!-- เพิ่มในส่วน <head> ของไฟล์ HTML -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <!-- GeoPackage JS Library (สำหรับอ่านไฟล์ .gpkg) -->
    <script src="https://unpkg.com/@ngageoint/geopackage@4.1.0/dist/geopackage.min.js"></script>
    <!-- Leaflet GeoJSON Layer (สำหรับแสดงข้อมูลจาก GeoPackage) -->
    <script src="https://unpkg.com/leaflet.vectorgrid@1.3.0/dist/Leaflet.VectorGrid.bundled.js"></script>
    <style>
        body, html { height: 100%; margin: 0; padding: 0; overflow: hidden; font-family: sans-serif; }
        #map { height: 100vh; width: 100vw; z-index: 0; }
        
        /* ข้อ 1: ปรับแต่งเป้าเล็งใหม่ (ใหญ่ขึ้น 20%, หนาขึ้น, สูงขึ้น 15%) */
        .crosshair {
            position: absolute;
            top: 35%; /* สูงขึ้นจากกึ่งกลาง (50% - 15%) */
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 1000;
        }
        .crosshair-center {
            width: 6px; height: 6px;
            background-color: #ef4444;
            border-radius: 50%;
            position: absolute;
            top: 50%; left: 50%; transform: translate(-50%, -50%);
        }
        .crosshair-circle {
            width: 60px; height: 60px; /* ใหญ่ขึ้นจาก 50px */
            border: 3px solid rgba(239, 68, 68, 0.9); /* เส้นหนาขึ้น */
            border-radius: 50%;
            position: relative;
        }
        .crosshair-line { position: absolute; background-color: rgba(239, 68, 68, 0.9); }
        .line-v { width: 3px; height: 18px; left: 50%; transform: translateX(-50%); }
        .line-h { height: 3px; width: 18px; top: 50%; transform: translateY(-50%); }
        .v-top { top: -20px; } .v-bottom { bottom: -20px; }
        .h-left { left: -20px; } .h-right { right: -20px; }

        /* สไตล์พิเศษสำหรับสีพื้นหลังช่องกรอกตามเงื่อนไข */
        .bg-custom-green { 
            background-color: rgba(187, 247, 208, 0.9) !important; 
        }
        .bg-custom-pink { 
            background-color: rgba(255, 249, 196, 0.9) !important; 
        }
        .bg-custom-check-status { 
            background-color: rgba(187, 247, 208, 0.9) !important; 
            font-weight: bold;
        }

        /* สไตล์สำหรับฟิลด์ที่อ่านอย่างเดียว */
        .form-input[readonly] {
            background-color: rgba(187, 247, 208, 0.9) !important;
            cursor: not-allowed !important;
            opacity: 0.85;
            border-color: #9ca3af !important;
        }
        .form-input[readonly]:hover {
            border-color: #6b7280 !important;
        }

        /* สีเขียวสำหรับกลุ่มแรก */
        .form-input.green-bg {
            background-color: rgba(187, 247, 208, 0.9) !important;
        }

        /* สีชมพูอ่อนสำหรับกลุ่มสอง */
        .form-input.pink-bg {
            background-color: rgba(255, 204, 204, 0.3) !important; /* ชมพูอ่อน */
        }

        /* สีเขียวสำหรับช่อง "สถานะการตรวจสอบ" */
        .form-input.check-status {
            background-color: rgba(187, 247, 208, 0.9) !important;
            font-weight: bold;
        }

        /* แก้ไขสีพื้นหลังสถานะ "ถ่ายรูปแล้ว" */
        .status-ถ่ายรูปแล้ว { 
            background: rgba(187, 247, 208, 0.9) !important; 
            color: #065f46; 
        }

        /* แก้ไขส่วน .side-panel ให้โปร่งใส */
        .side-panel { 
            transition: transform 0.3s ease-in-out; 
            transform: translateX(100%); 
            background: rgba(200, 200, 200, 1.0); /* โปร่งใส 95% */            
            z-index: 1010;
            box-shadow: -5px 0 25px rgba(0,0,0,0.15); /* เงาให้ดูดีขึ้น */
        }
        .form-label { 
            font-size: 0.85rem; /* ขนาดใหญ่ขึ้น */
            font-weight: 700; 
            color: #dc2626; /* สีแดง */
            margin-bottom: 0.2rem; /* เพิ่มระยะห่าง */
            display: block;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.8); /* เงาสีขาว */
        }
        .form-input { 
            width: 100%; 
            padding: 0.5rem 0.75rem; /* เพิ่ม padding */
            font-size: 0.9rem; /* ขนาดตัวหนังสือใหญ่ขึ้น */
            font-weight: 600; /* ตัวหนา */
            color: #2563eb; /* สีน้ำเงิน */
            background-color: rgba(255, 255, 255, 0.6); /* พื้นหลังโปร่งใส */
            border: 1.5px solid #d1d5db; /* เส้นหนาขึ้น */
            border-radius: 0.5rem; 
            outline: none;
            transition: border-color 0.2s ease;
        }
        .form-input:focus {
            border-color: #2563eb;
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.2); /* เงาชัดเจนขึ้น */
        }
        .form-input::placeholder {
            color: #9ca3af; /* สีเทาอ่อนสำหรับ placeholder */
            font-style: italic;
        }
        .side-panel.open { transform: translateX(0); }
        
        .map-btn { background: white; border-radius: 10px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        .active-tool { background-color: #2563eb !important; color: white !important; border: 2px solid white; }
        .active-edit { background-color: #2563eb !important; color: white !important; border: 2px solid white !important; }

        /* ข้อ 2: ปุ่มยืนยันเหนือปุ่มบวก (ระยะห่าง = เส้นผ่าศูนย์กลางปุ่มบวก 70px) */
        .confirm-btn-overlay {
        position: absolute;
        bottom: calc(2.5rem + 4.375rem + 4.375rem); /* bottom-10 (40px) + ความสูงปุ่ม (70px) + ระยะห่าง (70px) */
        left: 50%;
        transform: translateX(-50%);
        z-index: 1005;
        }
        /* สไตล์สำหรับเมนูฟันเฟือง */
        #settings-menu button {
          opacity: 0;
          transform: translateY(-20px);
          transition: all 0.3s ease;
        }

        #settings-menu button:hover {
          transform: translateY(0) scale(1.05) !important;
        }
        /* ============================================
           ซ่อนลูกศรขึ้นลงในช่องกรอกตัวเลขในแผงข้อมูล (เพื่อป้องกันการเปลี่ยนค่าโดยไม่ตั้งใจเมื่อหมุนสกอร์ล)
           ============================================ */
        #side-panel input[type="number"]::-webkit-inner-spin-button,
        #side-panel input[type="number"]::-webkit-outer-spin-button {
          -webkit-appearance: none !important;
          margin: 0 !important;
        }

        #side-panel input[type="number"] {
          -moz-appearance: textfield !important; /* Firefox */
          appearance: textfield !important; /* Standard */
        }

        /* ============================================
        ซ่อนลูกศรขึ้นลงในช่องกรอกตัวเลขในหน้าต่างคำนวณพื้นที่
        ============================================ */
        #calc-width::-webkit-inner-spin-button,
        #calc-width::-webkit-outer-spin-button,
        #calc-length::-webkit-inner-spin-button,
        #calc-length::-webkit-outer-spin-button,
        #calc-result::-webkit-inner-spin-button,
        #calc-result::-webkit-outer-spin-button {
          -webkit-appearance: none !important;
          margin: 0 !important;
        }

        #calc-width,
        #calc-length,
        #calc-result {
          -moz-appearance: textfield !important;
          appearance: textfield !important;
        }

        /* ========== แอนิเมชันเลื่อนขึ้น/ลง + ศูนย์กลางสำหรับเป้าเล็งและปุ่มบวก ========== */
        #crosshair {
          transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275),
                      opacity 0.6s ease;
          transform: translate(-50%, -50%) translateY(100vh); /* รวมศูนย์กลาง + เลื่อนจากล่าง */
          opacity: 0;
          will-change: transform, opacity;
        }
        #crosshair.visible {
          transform: translate(-50%, -50%) translateY(0); /* ศูนย์กลาง + ตำแหน่งปกติ */
          opacity: 1;
        }

        #add-trigger-container {
          transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275),
                      opacity 0.6s ease;
          transform: translateX(-50%) translateY(100vh); /* รวมศูนย์กลาง + เลื่อนจากล่าง */
          opacity: 0;
          will-change: transform, opacity;
        }
        #add-trigger-container.visible {
          transform: translateX(-50%) translateY(0); /* ศูนย์กลาง + ตำแหน่งปกติ */
          opacity: 1;
        }
        /* เพิ่มการเร่งฮาร์ดแวร์สำหรับแผนที่ */
        #map {
          transform: translate3d(0, 0, 0);
          will-change: transform;
        }

        /* ปิดการเรนเดอร์ชั่วคราวเมื่อเลื่อนแผนที่ (เพิ่มความลื่น) */
        .leaflet-zoom-anim .circle-marker,
        .leaflet-zoom-anim .crosshair {
          display: none !important;
        }
        /* ============================================
           ปรับแต่งสำหรับมือถือ (รวมทุกกฎไว้ในบล็อกเดียว)
           ============================================ */
        @media (max-width: 768px) {
            /* ความเร็วแอนิเมชัน */
            #crosshair,
            #add-trigger-container {
                transition-duration: 0.35s;
            }
            
            /* ขนาดตัวอักษรและพื้นที่ในช่องกรอก */
            .side-panel .form-input {
                font-size: 0.8125rem !important; /* 13px */
                padding: 0.4rem 0.6rem !important;
            }
            
            /* ปรับขนาดเลเบลให้สมดุล */
            .side-panel .form-label {
                font-size: 0.8125rem !important;
                margin-bottom: 0.2rem !important;
            }
            
            /* ปรับขนาดปุ่มกล้อง */
            .side-panel button[onclick*="camera"] {
                padding: 0.5rem !important;
                font-size: 0.75rem !important;
            }
        }
        /* แอนิเมชันสำหรับปุ่มฟันเฟือง */
        @keyframes spin {
          from { transform: rotate(0deg); }
          to { transform: rotate(360deg); }
        }
        .animate-spin {
          animation: spin 0.5s linear;
        }

        /* สไตล์สำหรับแกลเลอรี่รูปภาพ */
        #image-gallery-modal {
        }

        #gallery-grid::-webkit-scrollbar {
          width: 8px;
        }

        #gallery-grid::-webkit-scrollbar-track {
          background: #1f2937;
        }

        #gallery-grid::-webkit-scrollbar-thumb {
          background: #4b5563;
          border-radius: 4px;
        }

        #gallery-grid::-webkit-scrollbar-thumb:hover {
          background: #6b7280;
        }
        /* แอนิเมชันสำหรับ Modal */
        @keyframes scale-in {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }
        @keyframes scale-out {
            from { opacity: 1; transform: scale(1); }
            to { opacity: 0; transform: scale(0.9); }
        }
        .animate-scale-in { animation: scale-in 0.2s ease-out; }
        .animate-scale-out { animation: scale-out 0.2s ease-in; }

        /* แอนิเมชันสำหรับแจ้งเตือน */
        @keyframes fade-in {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes fade-out {
            from { opacity: 1; transform: translateY(0); }
            to { opacity: 0; transform: translateY(-20px); }
        }
        .animate-fade-in { animation: fade-in 0.3s ease-out; }
        .animate-fade-out { animation: fade-out 0.3s ease-in; }
        /* สถานะปุ่มรีโหลด */
        @keyframes flash-green {
            0%, 100% { background-color: white; }
            50% { background-color: #22c55e; color: white; }
        }
        .refresh-success { animation: flash-green 0.5s ease 3; }

        /* แอนิเมชันสำหรับแจ้งเตือน */
        @keyframes fade-in {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes fade-out {
            from { opacity: 1; transform: translateY(0); }
            to { opacity: 0; transform: translateY(-20px); }
        }
        .animate-fade-in { animation: fade-in 0.3s ease-out; }
        .animate-fade-out { animation: fade-out 0.3s ease-in; }

        .circle-marker {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            border: 2px solid white;
            cursor: pointer;
        }
        .circle-building { background-color: #f97316; }
        .circle-sign { background-color: #22c55e; }
        
        .user-location-dot {
            width: 14px; height: 14px;
            background-color: #2563eb;
            border: 2px solid white;
            border-radius: 50%;
        }
        
        /* สไตล์สำหรับตาราง */
        .data-table-panel {
            position: fixed;
            bottom: 5px;
            left: 5px;
            width: 90%;
            max-width: 900px;
            max-height: 45vh; /* ✅ เปลี่ยนจาก 60vh เป็น 47vh */
            height: 45vh; /* ✅ เพิ่มบรรทัดนี้เพื่อให้ความสูงคงที่ 47% */
            background: white;
            border-radius: 6px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            z-index: 1003;
            display: none;
            flex-direction: column;
            overflow: hidden;
            transform: translateY(100%);
            transition: transform 0.3s ease;
        }
        .data-table-panel.open {
            display: flex;
            transform: translateY(0);
        }
        .data-table-panel.open {
            display: flex;
            transform: translateY(0);
        }
        .table-header {
            background: linear-gradient(135deg, #667eea 0%, #db2777 100%);
            color: white;
            padding: 0.1rem 0.5rem;
            min-height: 20px;       /* กำหนดความสูงต่ำสุดให้เล็กลง */
            height: 44px;  
            gap: 0.25rem;    
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .table-tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }
        .table-tab {
            padding: 6px 6px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s;
        }
        .table-tab.active {
            background: white;
            color: #667eea;
        }
        .table-tab:hover:not(.active) {
            background: rgba(255,255,255,0.2);
        }
        .table-content {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }
        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }
        .data-table th {
            background: #f3f4f6;
            padding: 6px 8px;
            text-align: left;
            font-weight: 700;
            color: #374151;
            border-bottom: 2px solid #e5e7eb;
            position: sticky;
            top: 0;
            z-index: 1;
        }
        .data-table td {
            padding: 4px;
            border-bottom: 1px solid #e5e7eb;
            vertical-align: middle;
        }
        .data-table tr:hover {
            background: #f9fafb;
        }
        .data-table tr:nth-child(even) {
            background: #f9fafb;
        }
        /* แก้ไข: บังคับให้คลาส text-center ทำงานได้ */
        .data-table th.text-center,
        .data-table td.text-center {
            text-align: center !important; /* ✅ ใช้ !important เพื่อทับกฎเดิม */
        }
        .status-badge {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
        }
        .status-ยังไม่สำรวจ { background: #fef3c7; color: #92400e; }
        .status-ถ่ายรูปแล้ว { background: #d1fae5; color: #065f46; }
        .status-ตรวจสอบแล้ว { background: #fee2e2; color: #991b1b; }
        .zoom-btn {
            padding: 4px 10px;
            background: #2563eb;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 600;
            transition: all 0.2s;
        }
        .zoom-btn:hover {
            background: #1d4ed8;
            transform: scale(1.05);
        }
        .marker-icon {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid white;
        }
        .marker-building { background-color: #f97316; }
        .marker-sign { background-color: #22c55e; }
    </style>
</head>
<!-- Custom Modal Dialogs -->
<!-- Modal ยืนยันการลบ -->
<div id="confirm-delete-modal" class="fixed inset-0 bg-black/50 backdrop-blur-sm z-[2000] hidden items-center justify-center p-4">
    <div class="bg-white rounded-2xl shadow-2xl max-w-md w-full animate-scale-in">
        <div class="p-6">
            <div class="flex items-center justify-center w-16 h-16 bg-red-100 rounded-full mx-auto mb-4">
                <i data-lucide="trash-2" class="w-8 h-8 text-red-600"></i>
            </div>
            <h3 id="delete-modal-title" class="text-xl font-bold text-center text-gray-900 mb-2">ยืนยันการลบ</h3>
            <p id="delete-modal-message" class="text-center text-gray-600 mb-6">คุณแน่ใจว่าต้องการลบสิ่งปลูกสร้างนี้?</p>
            
            <div class="flex gap-3">
                <button onclick="cancelDelete()" class="flex-1 py-3 px-6 bg-gray-200 text-gray-700 rounded-lg font-semibold hover:bg-gray-300 transition-all active:scale-95">
                    ยกเลิก
                </button>
                <button onclick="confirmDeleteAction()" class="flex-1 py-3 px-6 bg-red-600 text-white rounded-lg font-semibold hover:bg-red-700 transition-all active:scale-95 flex items-center justify-center gap-2">
                    <i data-lucide="trash-2" class="w-4 h-4"></i>
                    ลบ
                </button>
            </div>
        </div>
    </div>
</div>
<!-- Modal โหมดแก้ไข -->
<div id="edit-mode-modal" class="fixed inset-0 bg-black/30 backdrop-blur-sm z-[2000] hidden items-center justify-center p-4">
    <div class="bg-white rounded-2xl shadow-2xl max-w-md w-full animate-scale-in">
        <div class="p-6">
            <div class="flex items-center justify-center w-16 h-16 bg-blue-100 rounded-full mx-auto mb-4">
                <i data-lucide="move" class="w-8 h-8 text-blue-600"></i>
            </div>
            <h3 class="text-xl font-bold text-center text-gray-900 mb-2">โหมดแก้ไขตำแหน่ง</h3>
            <p class="text-center text-gray-600 mb-6">คลิกและลากหมุดเพื่อย้ายตำแหน่ง</p>
            
            <div class="flex justify-center">
                <button onclick="closeEditModeModal()" class="py-3 px-8 bg-blue-600 text-white rounded-lg font-semibold hover:bg-blue-700 transition-all active:scale-95">
                    ตกลง
                </button>
            </div>
        </div>
    </div>
</div>
<body class="bg-gray-100">

    <div id="map"></div>

    <!-- เป้าเล็ง -->
    <div id="crosshair" class="crosshair hidden">
        <div class="crosshair-circle">
            <div class="crosshair-line line-v v-top"></div>
            <div class="crosshair-line line-v v-bottom"></div>
            <div class="crosshair-line line-h h-left"></div>
            <div class="crosshair-line line-h h-right"></div>
        </div>
        <div class="crosshair-center"></div>
    </div>

    <!-- ปุ่มคอนเฟิร์ม (ข้อ 2) -->
    <div id="confirm-overlay" class="confirm-btn-overlay hidden">
        <button id="btn-confirm-action" onclick="confirmCapture()" class="flex items-center gap-2 px-6 py-4 rounded-full text-white font-bold shadow-2xl active:scale-95 transition-all text-lg border-4 border-white">
            <i data-lucide="check-circle" class="w-6 h-6"></i>
            <span id="confirm-text">ยืนยันการเพิ่มจุด</span>
        </button>
    </div>

        <!-- ปุ่มฟันเฟืองและรีเฟรช (ด้านบนซ้าย) -->
        <div class="absolute top-4 left-4 z-[1001]">
          <!-- ปุ่มฟันเฟือง (เมนูหลัก) -->
          <button id="btn-settings" onclick="toggleSettingsMenu()" class="map-btn p-3 text-gray-600 hover:text-blue-600 transition-all relative group mb-2">
            <i data-lucide="settings-2" id="settings-icon" class="w-6 h-6"></i>
            <!-- จุดแจ้งเตือน -->
            <span id="settings-badge" class="absolute top-0 right-0 w-2 h-2 bg-red-500 rounded-full hidden"></span>
          </button>
          
          <!-- ปุ่มรีเฟรช -->
          <button id="btn-refresh" onclick="refreshData()" class="map-btn p-3 text-blue-600 transition-all">
            <i data-lucide="refresh-cw" id="refresh-icon" class="w-6 h-6"></i>
          </button>
          
          <!-- ปุ่มย่อยที่เลื่อนลงมา -->
          <div id="settings-menu" class="mt-2 space-y-2 hidden">
            <!-- ปุ่ม 1: ดาวน์โหลดสิ่งปลูกสร้าง -->
            <button onclick="exportBuildingGeoJSON()" class="map-btn p-3 w-48 bg-gradient-to-r from-orange-400 to-orange-600 text-white hover:scale-105 transition-all shadow-lg flex items-center justify-start gap-2 text-left">
              <i data-lucide="home" class="w-5 h-5"></i>
              <span class="text-xs font-bold">ดาวน์โหลดสิ่งปลูกสร้าง</span>
            </button>
            <!-- ปุ่ม 2: ดาวน์โหลดป้าย -->
            <button onclick="exportSignGeoJSON()" class="map-btn p-3 w-48 bg-gradient-to-r from-green-400 to-green-600 text-white hover:scale-105 transition-all shadow-lg flex items-center justify-start gap-2 text-left">
              <i data-lucide="map-pin" class="w-5 h-5"></i>
              <span class="text-xs font-bold">ดาวน์โหลดป้าย</span>
            </button>
            <!-- ปุ่ม 3: ดาวน์โหลดรูปสิ่งปลูกสร้าง -->
            <button onclick="loadBuildingImages()" class="map-btn p-3 w-48 bg-gradient-to-r from-blue-400 to-blue-600 text-white hover:scale-105 transition-all shadow-lg flex items-center justify-start gap-2 text-left">
              <i data-lucide="image" class="w-5 h-5"></i>
              <span class="text-xs font-bold">ดาวน์โหลดรูปสิ่งปลูกสร้าง</span>
            </button>
            <!-- ปุ่ม 4: ดาวน์โหลดรูปป้าย -->
            <button onclick="loadSignImages()" class="map-btn p-3 w-48 bg-gradient-to-r from-purple-400 to-purple-600 text-white hover:scale-105 transition-all shadow-lg flex items-center justify-start gap-2 text-left">
              <i data-lucide="gallery-horizontal" class="w-5 h-5"></i>
              <span class="text-xs font-bold">ดาวน์โหลดรูปป้าย</span>
            </button>
            <!-- ปุ่ม 5: อัปเดตแผนที่ (ใหม่!) -->
            <button onclick="manualUpdateMap()" class="map-btn p-3 w-48 bg-gradient-to-r from-yellow-400 to-yellow-600 text-white hover:scale-105 transition-all shadow-lg flex items-center justify-start gap-2 text-left">
                <i data-lucide="refresh-cw" class="w-5 h-5"></i>
                <span class="text-xs font-bold">อัปเดตแผนที่แปลง</span>
            </button>
          </div>
        </div>

    <!-- ปุ่มเลือกประเภทและแก้ไข -->
    <div class="absolute top-4 right-4 z-[1001] flex flex-row gap-2">
        <button id="btn-building" onclick="activateTool('building')" class="map-btn p-3" title="เพิ่มสิ่งปลูกสร้าง">
            <i data-lucide="home" class="w-6 h-6 text-orange-500"></i>
        </button>
        <button id="btn-sign" onclick="activateTool('sign')" class="map-btn p-3" title="เพิ่มป้าย">
            <i data-lucide="map-pin" class="w-6 h-6 text-green-500"></i>
        </button>
        <button id="btn-edit" onclick="toggleEditMode()" class="map-btn p-3" title="โหมดแก้ไขตำแหน่ง">
            <i data-lucide="move" class="w-6 h-6 text-red-600"></i>
        </button>
    </div>

    <!-- ปุ่มตำแหน่งปัจจุบัน -->
    <div class="absolute bottom-4 left-4 z-[1001]">
    <button onclick="locateUser()" class="map-btn p-3 shadow-lg border-2 border-blue-100">
    <div class="user-location-dot"></div>
    </button>
    </div>

    <!-- ปุ่มบวก (Add Trigger) -->
    <div id="add-trigger-container" class="absolute bottom-10 left-1/2 -translate-x-1/2 z-[1001] hidden">
        <button onclick="showConfirmButton()" class="p-4 bg-blue-600/50 text-white rounded-full shadow-xl border-[3px] border-white active:scale-90 transition-all">
            <i data-lucide="plus" class="w-8 h-8"></i>
        </button>
    </div>

    <!-- ปุ่มแสดงตาราง -->
    <div class="absolute bottom-4 right-4 z-[1002]">
        <button id="btn-show-table" onclick="toggleTable()" class="map-btn p-3 bg-white hover:bg-blue-50">
            <i data-lucide="table" id="table-icon" class="w-6 h-6 text-blue-600"></i>
        </button>
    </div>

    <!-- หน้าต่างตารางข้อมูล -->
    <div id="data-table-panel" class="data-table-panel">
        <div class="table-header">
            <div class="flex items-center gap-2">
                <div class="table-tabs">
                    <div class="table-tab active" onclick="switchTableTab('building')">
                        <span>สิ่งปลูกสร้าง</span>
                        <span id="building-count-badge" class="ml-2 px-2 py-0.5 bg-orange-400 text-white text-xs rounded-full font-medium">0</span>
                    </div>
                    <div class="table-tab" onclick="switchTableTab('sign')">
                        <span>ป้าย</span>
                        <span id="sign-count-badge" class="ml-2 px-2 py-0.5 bg-green-500 text-white text-xs rounded-full font-medium">0</span>
                    </div>
                </div>
            </div>
            <button onclick="toggleTable()" class="p-1.5 hover:bg-white/20 rounded-full">
                <i data-lucide="x" class="w-4 h-4"></i>
            </button>
        </div>
        <div class="table-content">
            <div id="building-table-container" class="table-tab-content">
                <table class="data-table" id="building-table">
                    <thead>
                        <tr>
                            <th style="width: 30px"><i data-lucide="map-pin" class="w-4 h-4"></i></th>
                            <th class="sortable-header" data-sort="building_c">รหัส</th>
                            <th class="sortable-header" data-sort="full_name">เจ้าของ</th>
                            <th class="text-center sortable-header" data-sort="hs_no">เลขที่</th>
                            <th class="text-center sortable-header" data-sort="hs_moo">หมู่</th>
                            <th class="sortable-header" data-sort="b_type">ประเภท</th>
                            <th class="text-center sortable-header" data-sort="b_mat">วัสดุ</th>
                            <th class="text-center sortable-header" data-sort="no_floor">ชั้น</th>
                            <th class="text-center sortable-header" data-sort="b_area">พื้นที่ทั้งหลัง (ตร.ม.)</th>
                            <th class="text-center sortable-header" data-sort="b_year">อายุ</th>
                            <th class="sortable-header" data-sort="b_note">รายละเอียด</th>
                            <th class="sortable-header" data-sort="b_use">ใช้ประโยชน์</th>
                            <th class="sortable-header" data-sort="b_use2">ใช้ประโยชน์ (2)</th>
                            <th class="sortable-header" data-sort="land_use">ใช้ประโยชน์ที่ดิน</th>
                            <th class="sortable-header" data-sort="check">ตรวจสอบ</th>
                            <th style="width: 60px">ซูม</th>
                        </tr>
                    </thead>
                    <tbody id="building-table-body">
                        <tr>
                            <td colspan="15" class="text-center py-8 text-gray-500">กำลังโหลดข้อมูล...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div id="sign-table-container" class="table-tab-content hidden">
                <table class="data-table" id="sign-table">
                    <thead>
                        <tr>
                            <th style="width: 30px"><i data-lucide="map-pin" class="w-4 h-4"></i></th>
                            <th class="sortable-header" data-sort="s_code">รหัส</th>
                            <th class="sortable-header" data-sort="s_characte">ลักษณะ</th>
                            <th class="text-center sortable-header" data-sort="s_wide">กว้าง (ซ.ม.)</th>
                            <th class="text-center sortable-header" data-sort="s_length">ยาว (ซ.ม.)</th>
                            <th class="text-center sortable-header" data-sort="no_side">จำนวนด้าน</th>
                            <th class="sortable-header" data-sort="s_text">ข้อความ</th>
                            <th class="sortable-header" data-sort="check">ตรวจสอบ</th>
                            <th style="width: 60px">ซูม</th>
                        </tr>
                    </thead>
                    <tbody id="sign-table-body">
                        <tr>
                            <td colspan="8" class="text-center py-8 text-gray-500">กำลังโหลดข้อมูล...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- องค์ประกอบแสดงรูปภาพ (มีขนาดและตำแหน่งเดียวกับตาราง) -->
    <div id="image-preview-container" class="data-table-panel" style="display: none; z-index: 1004; bottom: 5px; transform: translateY(0);">
        <div class="table-header" style="background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);">
            <div class="flex items-center justify-between w-full">
                <div class="flex items-center gap-2">
                    <h3 class="font-bold text-white text-sm">รูปภาพ</h3>
                </div>
                <!-- ✅ ปุ่มปิดหน้าต่างรูปภาพ -->
                <button onclick="hideImagePreview()" class="p-2 hover:bg-white/20 rounded-full transition">
                    <i data-lucide="x" class="w-5 h-5 text-white"></i>
                </button>
            </div>
        </div>
        <div class="table-content flex items-center justify-center p-4">
            <img id="image-preview" src="" alt="รูปภาพ" class="max-w-full max-h-full object-contain hidden">
            <div id="image-preview-placeholder" class="text-gray-300 text-sm">
                คลิกที่ชื่อรูปภาพในแผงข้อมูลเพื่อดูรูปใหญ่
            </div>
        </div>
    </div>

    <!-- หน้าต่างกรอกข้อมูล -->
    <div id="side-panel" class="side-panel fixed top-0 right-0 w-[44vw] sm:w-[280px] h-full z-[1002] shadow-2xl flex flex-col">
        <div class="p-4 border-b flex justify-between items-center bg-gray-50">
            <div>
                <h2 id="panel-title" class="font-bold text-blue-900">บันทึกข้อมูล</h2>
                <p id="latlng-display" class="text-[10px] text-gray-500 font-mono"></p>
            </div>
            <button onclick="closePanel()" class="p-2 hover:bg-gray-200 rounded-full"><i data-lucide="x" class="w-5 h-5"></i></button>
        </div>
        <form id="survey-form" class="flex-1 overflow-y-auto p-4 space-y-3"></form>
        <div class="p-4 bg-white border-t">
            <button type="button" onclick="saveSurveyData()" class="w-full bg-blue-600 text-white py-3 rounded-xl font-bold flex items-center justify-center gap-2">
                <i data-lucide="save" class="w-5 h-5"></i> บันทึก
            </button>
        </div>
    </div>

    <script>
        const CONFIG = {
            SCRIPT_URL: 'https://script.google.com/macros/s/AKfycbyFWpmT-X62o3H_leBlJ35qLJv3I57We_DzlvcmQLwm-NcIwLM3k-GFq_namGrG8zylMw/exec'
        };

    // ✅ ประกาศตัวแปร Global ทั้งหมดไว้ที่นี่ที่เดียว
        let map;
        let activeTool = null;
        let isEditMode = false;
        let surveyLayers = L.layerGroup();
        let editingMarker = null;
        let markersBeingMoved = new Set(); // ✅ เพิ่มบรรทัดนี้ - เก็บ rowKey ของจุดที่กำลังถูกย้าย
        // ตัวแปรสำหรับเก็บข้อมูลและ Cache
        let allBuildings = []; 
        let allSigns = [];   
        let movingMarkerId = null; // ✅ เก็บ ID ของจุดที่กำลังถูกลากอยู่  
        
        // ตัวแปรสำหรับระบบอัปเดตอัตโนมัติ

        let autoUpdateInterval = null;
        let isUpdating = false;
        let isUploadingImage = false; // [cite: 71]

        let canvasRenderer; // ✅ ประกาศตัวแปรระดับโกลบอล

        function initMap() {
            // ✅ สร้าง Canvas Renderer 1 ครั้ง
            canvasRenderer = L.canvas({ padding: 0.5 });
            
            const mapOptions = {
                zoomControl: false,
                attributionControl: false,
                preferCanvas: true,
                renderer: canvasRenderer, // ✅ ใช้ renderer เดียวกัน
                zoomSnap: isMobile() ? 0.5 : 1,
                wheelDebounceTime: 40,
                doubleClickZoom: false
            };

          map = L.map('map', {
            zoomControl: false,
            attributionControl: false,
            preferCanvas: true,
            // ✅ อนุญาตให้แผนที่แสดงล้นขอบจอได้
            padding: [50, 50], // เพิ่มพื้นที่ว่างรอบแผนที่ (บน, ล่าง, ซ้าย, ขวา)
            maxBoundsViscosity: 0.5, // ลดความหนืดของขอบเขต (ทำให้เลื่อนลื่นขึ้น)
            inertia: true, // เปิดใช้งานการเลื่อนแบบอินเนอร์เชีย
            inertiaDeceleration: 3000, // ความเร็วการชะลอตัว
            inertiaMaxSpeed: 1500, // ความเร็วสูงสุด
            // ไม่กำหนดขอบเขตแผนที่ (ให้แสดงล้นได้)
            // maxBounds: undefined
          }).setView([15.202, 102.068], 14);

          // Hardware Acceleration
          const container = map.getContainer();
          container.style.transform = 'translate3d(0, 0, 0)';
          
        // Google Hybrid Tile Options - ปรับเพิ่มประสิทธิภาพ
        const tileOptions = {
            subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],
            updateWhenIdle: false, // ✅ โหลดขณะเลื่อน (ไม่รอหยุด)
            updateWhenZooming: true, // ✅ อัปเดตขณะซูม
            keepBuffer: isMobile() ? 6 : 10, // ✅ เพิ่มบัฟเฟอร์ (มือถือ 4, คอม 8)
            maxNativeZoom: 19, // ป้องกันการโหลดไทล์ที่ไม่มี
            reuseTiles: true, // ✅ ใช้ไทล์เก่าซ้ำแทนโหลดใหม่
            className: 'map-tiles-optimized'
        };

        // Low Res / Background Layer
        const lowResLayer = L.tileLayer('https://{s}.google.com/vt/lyrs=y&x={x}&y={y}&z={z}', {
            ...tileOptions,
            maxZoom: 15,
            zIndex: 1
        });

        // High Res Layer
        const highResLayer = L.tileLayer('https://{s}.google.com/vt/lyrs=y&x={x}&y={y}&z={z}', {
            ...tileOptions,
            minZoom: 16,
            maxZoom: 22,
            zIndex: 2
        });

          lowResLayer.addTo(map);
          highResLayer.addTo(map);
          surveyLayers.addTo(map);
        }
        // ตรวจจับอุปกรณ์มือถือ
        function isMobile() {
          return /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        function activateTool(tool) {
          isEditMode = false;
          document.getElementById('btn-edit').classList.remove('active-edit');
          surveyLayers.eachLayer(l => l.dragging && l.dragging.disable());
          
          if (activeTool === tool) {
            // ยกเลิกการเพิ่มจุด - เลื่อนลง
            deactivateTools();
          } else {
            // เปิดใช้งานเครื่องมือใหม่
            activeTool = tool;
            document.getElementById('btn-building').classList.toggle('active-tool', tool === 'building');
            document.getElementById('btn-sign').classList.toggle('active-tool', tool === 'sign');
            
            // แสดงเป้าเล็งและปุ่มบวกด้วยแอนิเมชันเลื่อนขึ้น
            const crosshair = document.getElementById('crosshair');
            const addTrigger = document.getElementById('add-trigger-container');
            
            // ลบคลาส hidden และเพิ่มคลาส visible พร้อมแอนิเมชัน
            crosshair.classList.remove('hidden');
            addTrigger.classList.remove('hidden');
            
            // บังคับให้เบราว์เซอร์คำนวณใหม่ก่อนเริ่มแอนิเมชัน
            void crosshair.offsetWidth;
            void addTrigger.offsetWidth;
            
            // เริ่มแอนิเมชันเลื่อนขึ้น
            crosshair.classList.add('visible');
            addTrigger.classList.add('visible');
            
            // ซ่อนปุ่มคอนเฟิร์มหากมี
            document.getElementById('confirm-overlay').classList.add('hidden');
          }
        }

        // ระบบแคชแผนที่
        let mapCache = {};

        function cacheCurrentView() {
            const bounds = map.getBounds();
            const zoom = map.getZoom();
            
            // สร้างคีย์สำหรับแคช
            const cacheKey = `${bounds.getNorth()},${bounds.getEast()},${bounds.getSouth()},${bounds.getWest()}_${zoom}`;
            
            // บันทึกตำแหน่งปัจจุบันลงในแคช
            mapCache[cacheKey] = {
                timestamp: new Date().toISOString(),
                bounds: bounds,
                zoom: zoom
            };
            
            console.log(`แคชตำแหน่ง: ${cacheKey}`);
        }

        // โหลดแผนที่จากแคชเมื่อเปิดแอป
        function loadCachedMapViews() {
            // โหลดจาก localStorage
            const cached = localStorage.getItem('mapCache');
            if (cached) {
                mapCache = JSON.parse(cached);
                console.log('โหลดแคชแผนที่เรียบร้อย');
            }
        }

        // บันทึกแคชเมื่อปิดแอป
        window.addEventListener('beforeunload', () => {
            localStorage.setItem('mapCache', JSON.stringify(mapCache));
        });

        // เรียกใช้เมื่อเปิดแอป
        loadCachedMapViews();

        function deactivateTools() {
          activeTool = null;
          document.getElementById('btn-building').classList.remove('active-tool');
          document.getElementById('btn-sign').classList.remove('active-tool');
          
          const crosshair = document.getElementById('crosshair');
          const addTrigger = document.getElementById('add-trigger-container');
          
          // เริ่มแอนิเมชันเลื่อนลง
          crosshair.classList.remove('visible');
          addTrigger.classList.remove('visible');
          
          // หลังแอนิเมชันเสร็จ ซ่อนองค์ประกอบจริงๆ
          setTimeout(() => {
            crosshair.classList.add('hidden');
            addTrigger.classList.add('hidden');
            document.getElementById('confirm-overlay').classList.add('hidden');
          }, 400); // ตรงกับระยะเวลาแอนิเมชัน 0.4s
        }

        function toggleEditMode() {
            isEditMode = !isEditMode;
            
            const btnEdit = document.getElementById('btn-edit');
            
            if (isEditMode) {
                // ปิดเครื่องมือเพิ่มจุด
                activeTool = null;
                document.getElementById('btn-building').classList.remove('active-tool');
                document.getElementById('btn-sign').classList.remove('active-tool');
                
                // ✅ เพิ่มคลาส 'active-edit' ให้ปุ่ม "move" เป็นสีน้ำเงิน
                btnEdit.classList.add('active-edit');
                
                // ✅ เปิดใช้งานการลากมาร์กเกอร์ทั้งหมด
                surveyLayers.eachLayer(function(layer) {
                    if (layer._popupData && layer.dragging && layer.dragging.enable) {
                        layer.dragging.enable();
                        
                        // ผูกเหตุการณ์เมื่อลากเสร็จ
                        layer.off('dragend');
                        layer.on('dragend', async function(e) {
                            const newLatLng = e.target.getLatLng();
                            const marker = e.target;
                            const data = marker._popupData;
                            if (data) {
                                await updateMarkerPosition(marker, data, newLatLng);
                            }
                        });
                    }
                });
                
                showEditModeModal();
            } else {
                // ✅ ลบคลาส 'active-edit' ออกจากปุ่ม "move"
                btnEdit.classList.remove('active-edit');
                
                // ✅ ปิดการลากมาร์กเกอร์ทั้งหมด
                surveyLayers.eachLayer(function(layer) {
                    if (layer.dragging && layer.dragging.disable) {
                        layer.dragging.disable();
                    }
                });
            }
        }

        // ฟังก์ชันสำหรับปิด/เปิดการใช้งานปุ่มรีโหลด
        function disableRefreshButton() {
            const btn = document.getElementById('btn-refresh');
            btn.disabled = true;
            btn.style.opacity = '0.5';
            btn.style.cursor = 'not-allowed';
        }

        function enableRefreshButton() {
            const btn = document.getElementById('btn-refresh');
            btn.disabled = false;
            btn.style.opacity = '1';
            btn.style.cursor = 'pointer';
        }


        // ข้อ 2: แสดงปุ่มยืนยัน
        function showConfirmButton() {
            const overlay = document.getElementById('confirm-overlay');
            const btn = document.getElementById('btn-confirm-action');
            const text = document.getElementById('confirm-text');

            if (activeTool === 'building') {
                btn.style.backgroundColor = '#f97316'; 
                text.innerText = "เพิ่มสิ่งปลูกสร้าง";
            } else {
                btn.style.backgroundColor = '#22c55e';
                text.innerText = "ยืนยันเพิ่มป้าย";
            }
            overlay.classList.remove('hidden');
        }

        // ข้อ 2: ยืนยันและบันทึกเบื้องหลัง
        async function confirmCapture() {
            // คำนวณพิกัดตามตำแหน่งเป้า (สูงขึ้น 15%)
            const containerPoint = L.point(map.getSize().x / 2, map.getSize().y * 0.35);
            const latlng = map.containerPointToLatLng(containerPoint);

            document.getElementById('confirm-overlay').classList.add('hidden');
            
            const tempMarker = createCircleMarker(latlng, activeTool);
            tempMarker.addTo(surveyLayers);
            
            backgroundUpload(latlng, activeTool, tempMarker);
        }

        // แก้ไขฟังก์ชัน backgroundUpload
        async function backgroundUpload(latlng, type, marker) {
            const refreshBtn = document.getElementById('btn-refresh');
            const refreshIcon = document.getElementById('refresh-icon');
            
            disableRefreshButton();
            refreshIcon.classList.add('animate-spin');
            
            // สร้างข้อมูลพื้นฐาน
            const data = {
                lat_long: `${latlng.lat.toFixed(6)}, ${latlng.lng.toFixed(6)}`,
                date_added: new Date().toISOString(),
                tempMarker: true
            };
            
            // เพิ่มข้อมูลเริ่มต้น
            if (type === 'sign') {
                data.s_code = `99Z000-S${Date.now().toString().slice(-3)}`;
                data.s_name = '';
                data.s_type = '';
                data.s_wide = '0';
                data.s_length = '0';
            } else {
                data.building_c = `99Z000-B${Date.now().toString().slice(-5)}`;
                data.full_name = '';
                data.b_type = '';
                data.b_area = '0';
            }
            
            // ✅ ทำเครื่องหมายในมาร์กเกอร์ว่าเป็นชั่วคราว
            marker._popupData = { ...data, type: type, tempMarker: true };
            setupMarkerPopup(marker, marker._popupData, type);
            
            try {
                // ✅ สร้างคิวทุกกรณี ไม่ต้องตรวจสอบออนไลน์/ออฟไลน์
                const queueId = addToSyncQueue('quickAdd', type, data);
                marker._popupData = {
                    ...data,
                    type: type,
                    tempMarker: true,
                    queued: true,
                    queueId: queueId
                };
                setupMarkerPopup(marker, marker._popupData, type);
                
                // ✅ เรียกซิงค์ทันที
                await processSyncQueue();
                
                // ✅ รอให้รายการนี้สำเร็จ
                const maxWaitTime = 60000; // 30 วินาที
                const startTime = Date.now();
                let queueItem = syncQueue.find(q => q.id === queueId);
                
                while (queueItem && queueItem.status === 'ยังไม่สำรวจ' && (Date.now() - startTime) < maxWaitTime) {
                    await new Promise(resolve => setTimeout(resolve, 500)); // รอ 500 มิลลิวินาที
                    queueItem = syncQueue.find(q => q.id === queueId);
                }
                
                // ✅ โหลดข้อมูลใหม่ก่อน (เพื่อให้มีข้อมูลจริงแสดงบนแผนที่)
                await loadExistingData();
                
                // ✅ ลบจุดชั่วคราวหลังจากโหลดเสร็จ
                setTimeout(() => {
                    surveyLayers.eachLayer(layer => {
                        if (layer._popupData && layer._popupData.tempMarker) {
                            surveyLayers.removeLayer(layer);
                        }
                    });
                    refreshIcon.classList.remove('animate-spin');
                    refreshBtn.classList.add('refresh-success');
                    setTimeout(() => {
                        refreshBtn.classList.remove('refresh-success');
                        enableRefreshButton();
                    }, 2000);
                    
                    if (queueItem && queueItem.status === 'success') {
                        showNotificationLeft('เพิ่มจุดเรียบร้อยแล้ว!', 'success');
                    } else {
                        showNotificationLeft('เพิ่มจุดเรียบร้อยแล้ว (รอซิงค์)', 'warning');
                    }
                }, 300);
                
            } catch (err) {
                refreshIcon.classList.remove('animate-spin');
                enableRefreshButton();
                showNotificationLeft("การบันทึกล้มเหลว: " + err.message, 'error');
            }
        }

        // ============================================
        // ฟังก์ชันบันทึกข้อมูล (แก้ไขส่วนจัดการรูปภาพ - แยกเก็บลิ้งค์และชื่อไฟล์)
        // ============================================
        async function saveSurveyData() {
            const form = document.getElementById('survey-form');
            if (!form) {
                showNotificationLeft('ไม่พบฟอร์มข้อมูล', 'error');
                return;
            }
            
            // ✅ รวบรวมข้อมูลจากฟอร์ม (ไม่รวมฟิลด์ไฟล์)
            const formData = new FormData(form);
            const data = {};

            for (let [key, value] of formData.entries()) {
                if (key.endsWith('_temp')) continue; // ข้ามฟิลด์ชั่วคราว
                
                const input = form.querySelector(`[name="${key}"]`);
                if (input && input.type === 'checkbox') {
                    data[key] = input.checked ? 'TRUE' : 'FALSE';
                } else if (input && input.type !== 'file') {
                    data[key] = value.trim();
                }
            }

            // ✅ เพิ่มค่าฟิลด์ที่ถูกปิดการใช้งาน (เฉพาะสิ่งปลูกสร้าง) - แก้ไขปัญหาค่าว่างไม่ถูกส่ง
            if (form.querySelector('[name="b_use2"]')) { // ตรวจสอบว่าเป็นฟอร์มสิ่งปลูกสร้าง
                const disabledFields = [
                    'b_use2', 'per_use2', 'buse_floor2', 'buse_area2', 'ment_use2', 'full_area2',
                    'land_use' // เพิ่ม land_use ด้วย (แม้จะคำนวณอัตโนมัติ แต่ต้องส่งค่า)
                ];
                
                disabledFields.forEach(fieldId => {
                    const field = form.querySelector(`[name="${fieldId}"]`);
                    if (field) {
                        // ดึงค่าจากฟิลด์แม้ถูกปิดการใช้งาน + trim ค่าว่าง
                        const rawValue = field.value || '';
                        data[fieldId] = rawValue.trim();
                        console.log(`📤 เพิ่มค่า ${fieldId} (disabled) ใน payload: "${data[fieldId]}"`);
                    }
                });
            }

            // ✅ คำนวณค่า "ใช้ประโยชน์ที่ดิน" ใหม่ทุกครั้งก่อนบันทึก (ไม่พึ่งพาค่าใน UI)
            const bUseField = form.querySelector('select[name="b_use"]');
            const bUse2Field = form.querySelector('select[name="b_use2"]');
            let computedLandUse = '';

            if (bUseField && bUse2Field) {
                const bUseValue = (bUseField.value || '').trim();
                const bUse2Value = (bUse2Field.value || '').trim();
                
                // คำนวณตามเงื่อนไขเดิม
                if (bUseValue && bUse2Value) {
                    computedLandUse = '5-ใช้ประโยชน์หลายประเภท'; // ทั้งสองช่องมีค่า
                } else if (bUseValue) {
                    computedLandUse = bUseValue; // มีค่าจาก b_use เท่านั้น
                } else if (bUse2Value) {
                    computedLandUse = bUse2Value; // มีค่าจาก b_use2 เท่านั้น
                }
                // ถ้าทั้งสองว่าง → ค่าว่าง (ไม่ต้องทำอะไร)
            }

            // ✅ ตั้งค่าในข้อมูลที่จะส่ง (แทนที่ค่าเดิมหรือเพิ่มใหม่)
            data.land_use = computedLandUse;
            console.log('✅ คำนวณค่า land_use ใหม่ก่อนบันทึก:', data.land_use || '(ว่าง)');

            // ✅ ดึงพิกัดจากหลายแหล่ง (สำคัญที่สุด!)
            let latLongValue = '';

            // ลองดึงจากฟิลด์ซ่อนในฟอร์มก่อน (สำคัญที่สุด!)
            const latLongInput = form.querySelector('input[name="lat_long"]');
            if (latLongInput && latLongInput.value.trim() !== '') {
                latLongValue = latLongInput.value.trim();
                console.log('📍 พิกัดจากฟิลด์ซ่อน:', latLongValue);
            }

            // ถ้าไม่มีในฟิลด์ซ่อน ให้ลองดึงจาก #latlng-display
            if (!latLongValue) {
                const latlngDisplay = document.getElementById('latlng-display')?.innerText;
                if (latlngDisplay && latlngDisplay.trim() !== '' && latlngDisplay !== 'กำลังโหลด...') {
                    latLongValue = latlngDisplay.trim();
                    console.log('📍 พิกัดจาก #latlng-display:', latLongValue);
                }
            }

            // ถ้ายังไม่มี ให้ดึงจากมาร์กเกอร์ที่กำลังแก้ไข
            if (!latLongValue && editingMarker && editingMarker._popupData) {
                latLongValue = editingMarker._popupData.lat_long || '';
                console.log('📍 พิกัดจาก _popupData:', latLongValue);
            }

            // ตรวจสอบว่าได้พิกัดหรือไม่
            if (!latLongValue || latLongValue.trim() === '') {
                showNotificationLeft('❌ ไม่พบพิกัดตำแหน่ง กรุณาตรวจสอบอีกครั้ง', 'error');
                console.error('❌ ไม่พบพิกัดในทุกแหล่งที่พยายามดึง');
                console.log('- ฟิลด์ซ่อน:', latLongInput?.value);
                console.log('- #latlng-display:', document.getElementById('latlng-display')?.innerText);
                console.log('- editingMarker._popupData:', editingMarker?._popupData);
                return;
            }

            data.lat_long = latLongValue;
            console.log('✅ ใช้พิกัด:', data.lat_long);
            
            // ✅ ตรวจสอบประเภทและกำหนดรหัสอัตโนมัติ
            let markerType;
            let rowKey = null;
            let action = 'add';
            
            if (editingMarker && editingMarker._popupData) {
                markerType = editingMarker._popupData.type || (editingMarker._popupData.building_c ? 'building' : 'sign');
                rowKey = editingMarker._popupData.id || editingMarker._popupData._row_num;
                action = 'update';
            } else {
                markerType = document.getElementById('marker-type')?.value || 'building';
                action = 'add';
            }
            
            if (!markerType || !['building', 'sign'].includes(markerType)) {
                showNotificationLeft('ไม่พบประเภทข้อมูล', 'error');
                return;
            }

            // ============================================
            // ✅ กำหนดรหัสอัตโนมัติถ้าไม่มี (สำคัญมาก!)
            // ============================================
            if (markerType === 'building') {
                // ตรวจสอบว่ามีรหัสสิ่งปลูกสร้างหรือไม่
                if (!data.building_c || data.building_c.trim() === '') {
                    // สร้างรหัสสิ่งปลูกสร้างอัตโนมัติ (เช่น B001, B002, ...)
                    const existingCodes = allBuildings.map(b => b.building_c).filter(c => c);
                    let maxNum = 0;
                    existingCodes.forEach(code => {
                        const match = code.match(/^B(\d+)$/);
                        if (match) {
                            maxNum = Math.max(maxNum, parseInt(match[1]));
                        }
                    });
                    data.building_c = `B${String(maxNum + 1).padStart(3, '0')}`;
                    console.log(`🏷️ สร้างรหัสสิ่งปลูกสร้างอัตโนมัติ: ${data.building_c}`);
                }
            } else if (markerType === 'sign') {
                // ตรวจสอบว่ามีรหัสป้ายหรือไม่
                if (!data.s_code || data.s_code.trim() === '') {
                    // สร้างรหัสป้ายอัตโนมัติ (เช่น S001, S002, ...)
                    const existingCodes = allSigns.map(s => s.s_code).filter(c => c);
                    let maxNum = 0;
                    existingCodes.forEach(code => {
                        const match = code.match(/^S(\d+)$/);
                        if (match) {
                            maxNum = Math.max(maxNum, parseInt(match[1]));
                        }
                    });
                    data.s_code = `S${String(maxNum + 1).padStart(3, '0')}`;
                    console.log(`🏷️ สร้างรหัสป้ายอัตโนมัติ: ${data.s_code}`);
                }
            }

            // ============================================
            // ✅ จัดการรูปภาพ: เฉพาะเมื่อมีการเลือกไฟล์ใหม่เท่านั้น
            // ============================================
            let imageBase64 = null;
            let fileNameParam = null;
            const fileInput = form.querySelector('input[type="file"]');
            
            // ✅ ตรวจสอบว่ามีการเลือกไฟล์ใหม่หรือไม่
            if (fileInput && fileInput.files[0]) {
                const file = fileInput.files[0];
                const maxSize = markerType === 'building' ? 1500 : 2000;
                
                // ตั้งชื่อไฟล์ใหม่
                const prefix = markerType === 'building' ? 'B' : 'S';
                const code = data.building_c || data.s_code || Date.now().toString().slice(-5);
                const extension = file.name.split('.').pop().toLowerCase() || 'jpg';
                fileNameParam = `${prefix}${code}.${extension}`;
                
                // ปรับขนาดรูปภาพ
                try {
                    const resizedImage = await resizeImage(file, maxSize, maxSize);
                    const base64Data = resizedImage.split(',')[1];
                    imageBase64 = `${file.type};base64,${base64Data}`;
                    
                    // บันทึกลง IndexedDB
                    await saveImageToDB(imageBase64, fileNameParam, rowKey || Date.now(), markerType);
                    console.log(`✅ รูปภาพบันทึกใน IndexedDB: ${fileNameParam}`);
                    
                    // ✅ เก็บชื่อไฟล์ในข้อมูล (สำหรับคอลั่มน์ 'picture')
                    data.picture = fileNameParam;
                } catch (err) {
                    console.error('Error resizing image:', err);
                    try {
                        const arrayBuffer = await file.arrayBuffer();
                        const bytes = [...new Uint8Array(arrayBuffer)];
                        const binary = bytes.map(b => String.fromCharCode(b)).join('');
                        imageBase64 = `${file.type};base64,${btoa(binary)}`;
                        
                        await saveImageToDB(imageBase64, fileNameParam, rowKey || Date.now(), markerType);
                        console.log(`⚠️ รูปภาพบันทึกแบบไม่ปรับขนาด: ${fileNameParam}`);
                        data.picture = fileNameParam;
                    } catch (fallbackErr) {
                        console.error('Fallback failed:', fallbackErr);
                        showNotificationLeft('⚠️ ไม่สามารถบันทึกรูปภาพได้', 'warning');
                        // ✅ ไม่เก็บค่า picture หากบันทึกไม่สำเร็จ
                        delete data.picture;
                        imageBase64 = null;
                        fileNameParam = null;
                    }
                }
            } else {
                // ✅ สำคัญมาก: ไม่เก็บค่า picture ในข้อมูลเมื่อไม่มีการเลือกไฟล์ใหม่
                // เพื่อป้องกันไม่ให้เซิร์ฟเวอร์ทับค่าเดิมด้วย "image.jpg"
                console.log('ℹ️ ไม่มีการเลือกรูปภาพใหม่ - ไม่ส่งค่า picture ไปยังเซิร์ฟเวอร์');
            }
            
            // ✅ วางโค้ดตรวจสอบที่นี่ (หลังจากตั้งค่า data.picture และก่อนสร้างคิว)
            if (data.picture === 'image.jpg' || data.picture === '') {
                delete data.picture;
                console.warn('⚠️ ลบค่า picture ที่ไม่ถูกต้องออกก่อนส่ง: ', data.picture);
            }
            if (fileNameParam === 'image.jpg' || !fileNameParam || fileNameParam.trim() === '') {
                fileNameParam = null;
                imageBase64 = null;
                console.warn('⚠️ ยกเลิกการส่ง fileNameParam ที่ไม่ถูกต้อง');
            }

            // ============================================
            // ✅ สร้างคิวสำหรับอัปโหลด
            // ============================================
            const queueId = addToSyncQueue(action, markerType, data, rowKey, imageBase64, fileNameParam);
            console.log(`✅ สร้างคิวสำเร็จ: ${queueId} (${action})`);
            
            // ✅ อัปเดตมาร์กเกอร์ทันที
            if (editingMarker) {
                editingMarker._popupData = {
                    ...editingMarker._popupData,
                    ...data,
                    queued: true,
                    queueId: queueId
                };
                setupMarkerPopup(editingMarker, editingMarker._popupData, markerType);
            }
            
            // ✅ ปิดแผงและแจ้งเตือน
            closePanel();
            const msg = action === 'update' ? 'อัปเดตข้อมูลเรียบร้อยแล้ว!' : 'บันทึกข้อมูลเรียบร้อยแล้ว!';
            showNotificationLeft(`${msg} (รออัปโหลด)`, 'success');
            
            // ✅ เริ่มซิงค์ทันทีหากออนไลน์
            if (isOnline && navigator.onLine) {
                setTimeout(() => {
                    console.log('🔄 เริ่มซิงค์คิวข้อมูล...');
                    processSyncQueue();
                }, 300);
            }
            
            console.log('✅ บันทึกข้อมูลเสร็จสิ้น');
        }

        async function processDataSyncQueue() {
            console.log('🔄 เริ่มกระบวนการซิงค์ข้อมูล...');
            console.log('สถานะออนไลน์:', isOnline, 'navigator.onLine:', navigator.onLine);
            console.log('จำนวนรายการในคิวข้อมูล:', dataSyncQueue.length);
            
            if (!isOnline || !navigator.onLine) {
                console.log('❌ ออฟไลน์ - รอการเชื่อมต่อ...');
                return;
            }
            
            if (dataSyncQueue.length === 0) {
                console.log('ℹ️ คิวข้อมูลว่าง - ไม่มีข้อมูลให้อัปโหลด');
                return;
            }
            
            console.log(`📦 เริ่มกระบวนการซิงค์ข้อมูล (${dataSyncQueue.length} รายการ)`);
            console.log('CONFIG.SCRIPT_URL:', CONFIG.SCRIPT_URL);
            
            // ประมวลผลคิวทีละรายการ
            for (let i = 0; i < dataSyncQueue.length; i++) {
                const item = dataSyncQueue[i];
                
                if (item.status === 'success') {
                    console.log(`⏭️ รายการ ${i + 1}: สำเร็จแล้ว (ข้าม)`);
                    continue;
                }
                
                try {
                    console.log(`📤 กำลังประมวลผลรายการ ${i + 1}/${dataSyncQueue.length}: ${item.action}`);
                    console.log('ข้อมูล:', JSON.stringify(item, null, 2));
                    
                    let result;
                    
                    // ✅ แก้ไข: เปลี่ยน 'add' เป็น 'quickAdd'
                    switch (item.action) {
                        case 'add':
                        case 'quickAdd':
                            result = await sendDataWithRetry('quickAdd', item.type, item.data);
                            break;
                        case 'update':
                            result = await sendDataWithRetry('update', item.type, item.data, item.rowKey);
                            break;
                        case 'delete':
                            result = await sendDataWithRetry('delete', item.type, {}, item.rowKey);
                            break;
                        case 'updatePosition':
                            result = await sendDataWithRetry('updatePosition', item.type, item.data, item.rowKey);
                            break;
                        default:
                            console.warn(`⚠️ ไม่รู้จัก action: ${item.action}`);
                            continue;
                    }
                    
                    console.log(`📊 ผลลัพธ์รายการ ${i + 1}:`, result);
                    
                    // ✅ ตรวจสอบว่าเซิร์ฟเวอร์ตอบกลับสำเร็จจริงๆ
                    if (result && (result.success || (result.data && result.data.status === 200))) {
                        console.log(`✅ รายการ ${i + 1} สำเร็จ`);
                        
                        // อัปเดตสถานะในคิว
                        item.status = 'success';
                        item.syncedAt = new Date().toISOString();
                        
                        // บันทึกคิวลงใน localStorage
                        saveDataSyncQueueToStorage();
                        
                        // แสดงแจ้งเตือน
                        showNotificationLeft(`อัปโหลดข้อมูลสำเร็จ (${i + 1}/${dataSyncQueue.length})`, 'success');
                        
                    } else {
                        console.warn(`⚠️ รายการ ${i + 1} ล้มเหลว - รอลองใหม่`);
                        console.log('ผลลัพธ์:', result);
                        
                        item.retryCount = (item.retryCount || 0) + 1;
                        
                        if (item.retryCount >= 3) {
                            item.status = 'failed';
                            console.error(`❌ รายการ ${i + 1} ล้มเหลวเกิน 3 ครั้ง`);
                        }
                        
                        // บันทึกคิวลงใน localStorage
                        saveDataSyncQueueToStorage();
                        
                        // หยุดกระบวนการชั่วคราว
                        break;
                    }
                    
                    // รอ 500ms ระหว่างการอัปโหลดแต่ละรายการ
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                } catch (err) {
                    console.error(`❌ ข้อผิดพลาดในการประมวลผลรายการ ${i + 1}:`, err);
                    console.error('Stack trace:', err.stack);
                    
                    item.retryCount = (item.retryCount || 0) + 1;
                    
                    if (item.retryCount >= 3) {
                        item.status = 'failed';
                    }
                    
                    // บันทึกคิวลงใน localStorage
                    saveDataSyncQueueToStorage();
                    
                    // หยุดกระบวนการชั่วคราว
                    break;
                }
            }
            
            // ลบรายการที่สำเร็จแล้วออกจากคิว
            const successItems = dataSyncQueue.filter(item => item.status === 'success');
            for (const item of successItems) {
                removeFromDataSyncQueue(item.id);
            }
            
            // โหลดคิวใหม่จาก localStorage
            loadDataSyncQueueFromStorage();
            
            console.log(`✅ กระบวนการซิงค์ข้อมูลเสร็จสิ้น - คงเหลือ ${dataSyncQueue.length} รายการ`);
            
            // ถ้ายังมีรายการเหลืออยู่ ให้ลองซิงค์อีกครั้งหลังจาก 5 วินาที
            if (dataSyncQueue.length > 0) {
                console.log('⏳ มีรายการเหลืออยู่ - จะลองซิงค์อีกครั้งใน 5 วินาที');
                setTimeout(() => {
                    processDataSyncQueue();
                }, 5000);
            }
        }

        // แก้ไขฟังก์ชัน updateMarkerPosition
        async function updateMarkerPosition(marker, data, newLatLng) {
            const refreshBtn = document.getElementById('btn-refresh');
            const refreshIcon = document.getElementById('refresh-icon');
            disableRefreshButton();
            refreshIcon.classList.add('animate-spin');
            
            const oldLatLng = data.lat_long;
            const newLatLngStr = `${newLatLng.lat.toFixed(6)}, ${newLatLng.lng.toFixed(6)}`;
            const rowKey = data._row_num || data.id;
            const type = data.type || (data.building_c ? 'building' : 'sign');
            
            if (!rowKey) {
                alert("ไม่พบข้อมูลสำหรับอัปเดต");
                refreshIcon.classList.remove('animate-spin');
                enableRefreshButton();
                return;
            }
            
            // ✅ เพิ่มลงในรายการจุดที่กำลังถูกย้าย
            markersBeingMoved.add(rowKey);
            
            // ✅ หาจุดจริงที่กำลังถูกย้าย (ไม่ใช่จุดชั่วคราว)
            let realMarker = null;
            surveyLayers.eachLayer(layer => {
                if (layer._popupData) {
                    const layerId = layer._popupData._row_num || layer._popupData.id;
                    // ✅ ตรวจสอบว่าเป็นจุดจริง (ไม่ใช่จุดชั่วคราว)
                    if (String(layerId) === String(rowKey) && !layer._popupData.tempMarker) {
                        realMarker = layer;
                    }
                }
            });
            
            if (!realMarker) {
                console.warn(`⚠️ ไม่พบจุดจริงที่จะย้าย: ${rowKey}`);
                markersBeingMoved.delete(rowKey);
                refreshIcon.classList.remove('animate-spin');
                enableRefreshButton();
                return;
            }
            
            try {
                // ✅ อัปเดตตำแหน่งในข้อมูลทันที (ไม่ต้องโหลดข้อมูลใหม่ทั้งหมด)
                realMarker._popupData.lat_long = newLatLngStr;
                realMarker.setLatLng(newLatLng);
                
                // ✅ ส่งข้อมูลไปยังเซิร์ฟเวอร์
                const body = new URLSearchParams();
                body.append('action', 'updatePosition');
                body.append('type', type);
                body.append('rowKey', rowKey);
                body.append('lat_long', newLatLngStr);
                
                const res = await fetch(CONFIG.SCRIPT_URL.trim(), {
                    method: 'POST',
                    body,
                    timeout: 10000
                });
                
                const result = await res.json();
                
                if (res.ok && result.status === 200) {
                    // ✅ อัปเดตสำเร็จ - ลบออกจากรายการจุดที่กำลังถูกย้าย
                    markersBeingMoved.delete(rowKey);
                    refreshIcon.classList.remove('animate-spin');
                    refreshBtn.classList.add('refresh-success');
                    
                    setTimeout(() => {
                        refreshBtn.classList.remove('refresh-success');
                        enableRefreshButton();
                    }, 2000);
                    
                    showNotificationLeft('อัปเดตตำแหน่งสำเร็จ!', 'success');
                } else {
                    throw new Error(result.message || "อัปเดตตำแหน่งไม่สำเร็จ");
                }
            } catch (err) {
                // ✅ หากเกิดข้อผิดพลาด ให้คืนค่าจุดเดิม
                console.error('❌ ข้อผิดพลาดในการอัปเดต:', err);
                
                // คืนค่าตำแหน่งเดิม
                const coords = oldLatLng.split(',').map(Number);
                realMarker.setLatLng(L.latLng(coords[0], coords[1]));
                realMarker._popupData.lat_long = oldLatLng;
                
                markersBeingMoved.delete(rowKey);
                refreshIcon.classList.remove('animate-spin');
                enableRefreshButton();
                
                showNotificationLeft("การอัปเดตล้มเหลว: " + err.message, 'error');
            }
        }

        // ข้อ 3: ตั้งค่าป๊อปอัปเพื่อเปิดฟอร์ม (แก้ไขเพิ่มปุ่มลบ + แก้ไขป๊อบอัปไม่ปิดอัตโนมัติ)
        function setupMarkerPopup(marker, data, type) {
            const popupDiv = document.createElement('div');
            popupDiv.className = "p-1 min-w-[160px]";
            popupDiv.innerHTML = `
                <p class="font-bold text-sm text-blue-900">${type === 'building' ? 'สิ่งปลูกสร้าง' : 'ป้าย'}</p>
                <p class="text-[10px] text-gray-500">${data.lat_long}</p>
                <div class="mt-2 space-y-2">
                    <button class="w-full bg-blue-600 text-white text-[11px] py-3 rounded font-bold shadow-sm active:bg-blue-700 hover:bg-blue-700 transition">แก้ข้อมูล</button>
                    <button class="w-full bg-red-600 text-white text-[11px] py-3 rounded font-bold shadow-sm active:bg-red-700 hover:bg-red-700 transition">ลบจุด</button>
                </div>
            `;
            
            // ✅ ผูกป๊อปอัปให้มาร์กเกอร์ (สำคัญที่สุด!)
            marker.bindPopup(popupDiv, {
                minWidth: 190,
                maxWidth: 220,
                autoPan: false, // ปิดการแพนอัตโนมัติ
                closeOnClick: true
            });
            
            // เก็บข้อมูลไว้ในมาร์กเกอร์
            marker._popupData = { ...data, type: type };
            
            // ✅ ผูกปุ่มเมื่อเปิดป๊อปอัป
            marker.on('popupopen', () => {
                const buttons = marker.getPopup().getElement().querySelectorAll('button');
                if (buttons[0]) {
                    buttons[0].onclick = (e) => {
                        e.stopPropagation();
                        openEditPanel(marker._popupData, marker._popupData.type, marker);
                    };
                }
                if (buttons[1]) {
                    buttons[1].onclick = (e) => {
                        e.stopPropagation();
                        showDeleteConfirm(marker, marker._popupData, marker._popupData.type);
                    };
                }
            });
        }

        // ฟังก์ชันลบจุดและข้อมูลจาก Google Sheets (ข้อ 1)
        // แก้ไขฟังก์ชัน deleteMarker
        async function deleteMarker(marker, data, type) {
            const refreshBtn = document.getElementById('btn-refresh');
            const refreshIcon = document.getElementById('refresh-icon');
            
            // ปิดการใช้งานปุ่ม
            disableRefreshButton();
            refreshIcon.classList.add('animate-spin');
            
            // แสดงแจ้งเตือนว่ากำลังลบ (ฝั่งซ้าย)
            const deletingMsg = document.createElement('div');
            deletingMsg.className = 'fixed top-4 left-4 bg-blue-500 text-white px-6 py-3 rounded-lg shadow-lg z-[2000] animate-fade-in';
            deletingMsg.innerHTML = '<i data-lucide="loader" class="w-5 h-5 inline mr-2 animate-spin"></i>กำลังลบข้อมูล...';
            document.body.appendChild(deletingMsg);
            
            const rowKey = data._row_num || data.id;
            
            if (!rowKey) {
                alert("ไม่พบข้อมูลสำหรับลบ");
                refreshIcon.classList.remove('animate-spin');
                enableRefreshButton();
                deletingMsg.classList.add('animate-fade-out');
                setTimeout(() => deletingMsg.remove(), 300);
                return;
            }
            
            const body = new URLSearchParams();
            body.append('action', 'delete');
            body.append('type', type);
            body.append('rowKey', rowKey);
            
            try {
                const res = await fetch(CONFIG.SCRIPT_URL.trim(), { method: 'POST', body });
                
                if (res.ok) {
                    // ซ่อนข้อความ "กำลังลบ"
                    deletingMsg.classList.add('animate-fade-out');
                    setTimeout(() => deletingMsg.remove(), 300);
                    
                    // แสดงแจ้งเตือนสำเร็จ (ฝั่งซ้าย)
                    const successMsg = document.createElement('div');
                    successMsg.className = 'fixed top-4 left-4 bg-green-500 text-white px-6 py-3 rounded-lg shadow-lg z-[2000] animate-fade-in';
                    successMsg.innerHTML = '<i data-lucide="check-circle" class="w-5 h-5 inline mr-2"></i>ลบข้อมูลเรียบร้อยแล้ว!';
                    document.body.appendChild(successMsg);
                    
                    setTimeout(() => {
                        successMsg.classList.add('animate-fade-out');
                        setTimeout(() => successMsg.remove(), 300);
                    }, 500);
                    
                    surveyLayers.removeLayer(marker);
                    await loadExistingData();
                    
                    refreshIcon.classList.remove('animate-spin');
                    refreshBtn.classList.add('refresh-success');
                    setTimeout(() => {
                        refreshBtn.classList.remove('refresh-success');
                        enableRefreshButton();
                    }, 500);
                    
                    console.log("ลบข้อมูลเรียบร้อยแล้ว");
                } else {
                    throw new Error("ลบข้อมูลไม่สำเร็จ");
                }
            } catch (err) {
                // ซ่อนข้อความ "กำลังลบ"
                deletingMsg.classList.add('animate-fade-out');
                setTimeout(() => deletingMsg.remove(), 300);
                
                refreshIcon.classList.remove('animate-spin');
                enableRefreshButton();
                console.error("Error deleting marker:", err);
                
                // แสดงแจ้งเตือนข้อผิดพลาด (ฝั่งซ้าย)
                const errorMsg = document.createElement('div');
                errorMsg.className = 'fixed top-4 left-4 bg-red-500 text-white px-6 py-3 rounded-lg shadow-lg z-[2000] animate-fade-in';
                errorMsg.innerHTML = '<i data-lucide="alert-circle" class="w-5 h-5 inline mr-2"></i>เกิดข้อผิดพลาดในการลบ!';
                document.body.appendChild(errorMsg);
                
                setTimeout(() => {
                    errorMsg.classList.add('animate-fade-out');
                    setTimeout(() => errorMsg.remove(), 300);
                }, 500);
                
                throw err;
            }
        }


        function openEditPanel(data, type, marker) {
            editingMarker = marker;
            const form = document.getElementById('survey-form');
            document.getElementById('latlng-display').innerText = data.lat_long;
            document.getElementById('panel-title').innerText = type === 'building' ? 'รายละเอียดสิ่งปลูกสร้าง' : 'รายละเอียดป้าย';
            // ✅ เพิ่มฟิลด์ประเภทมาร์กเกอร์เป็นบรรทัดแรกของฟอร์ม
            // let html = `<input type="hidden" id="marker-type" name="marker-type" value="${type}">`;

            const buildingFields = [
                { id: 'image', label: 'รูปสิ่งปลูกสร้าง', type: 'file', icon: 'camera' },
                { id: 'full_name', label: 'เจ้าของ', type: 'text' },
                { id: 'address', label: 'ที่อยู่', type: 'text' },
                { id: 'building_c', label: 'รหัสสิ่งปลูกสร้าง', type: 'text' },
                { id: 'b_type', label: 'ประเภทสิ่งปลูกสร้าง', type: 'select', options: [ '000-ไม่ระบุ', '101-บ้านพักอาศัยไม้ชั้นเดียว', '102-บ้านพักอาศัยไม้ชั้นเดียวใต้ถุนสูง', '103-บ้านพักอาศัยตึกชั้นเดียว', '104-บ้านพักอาศัยไม้สองชั้น', '105-บ้านพักอาศัยตึกสองชั้น', '106-บ้านพักอาศัยครึ่งตึกครึ่งไม้สองชั้น', '107-บ้านพักอาศัยตึกสามชั้น', '108-บ้านพักอาศัยแฝดตึกสองชั้น', '109-บ้านพักอาศัยแฝดตึกสามชั้น', '110-บ้านทรงไทยไม้ชั้นเดียวใต้ถุนสูง', '111-บ้านทรงไทยครึ่งตึกครึ่งไม้สองชั้น', '112-บ้านพักอาศัยแฝดตึกชั้นเดียว', '201-บ้านแถว ทาวน์เฮาส์) ชั้นเดียว', '202-บ้านแถว ทาวน์เฮาส์) สองชั้น', '203-บ้านแถว ทาวน์เฮาส์) สามชั้น', '204-บ้านแถว ทาวน์เฮาส์) สี่ชั้น', '301-ห้องแถวไม้ชั้นเดียว', '302-ห้องแถวไม้สองชั้น', '303-ห้องแถวครึ่งตึกครึ่งไม้สองชั้น', '401-ตึกแถวชั้นเดียว', '402-ตึกแถวสองชั้น', '403-ตึกแถวสองชั้นครึ่ง', '404-ตึกแถวสามชั้น', '405-ตึกแถวสามชั้นครึ่ง', '406-ตึกแถวสี่ชั้น', '407-ตึกแถวสี่ชั้นครึ่ง', '408-ตึกแถวห้าชั้น', '409-ตึกแถวหกชั้น', '501-คลังสินค้า พื้นที่ไม่เกิน 300 ตารางเมตร', '502-คลังสินค้าพื้นที่เกินกว่า 300 ตารางเมตรขึ้นไป', '503-เรือนคนใช้ /ครัว', '504-โรงจอดรถ', '505-สถานศึกษา', '506/1-โรงแรม ความสูงไม่เกิน 5 ชั้น', '506/2-โรงแรม ความสูงเกินกว่า 5 ชั้นขึ้นไป', '507-โรงมหรสพ', '508-สถานพยาบาล', '509/1-สำนักงาน ความสูงไม่เกิน 5 ชั้น', '509/2-สำนักงาน ความสูงเกินกว่า 5 ชั้นขึ้นไป', '510-ภัตตาคาร', '511/1-ห้างสรรพสินค้า', '511/2-อาคารพาณิชยกรรม ประเภทค้าปลีกค้าส่ง', '512-สถานีบริการน้ำมันเชื้อเพลิง', '513-โรงงาน', '514-ตลาด พื้นที่ไม่เกิน 1,000 ตารางเมตร', '515-ตลาด พื้นที่เกินกว่า 1,000 ตารางเมตรขึ้นไป', '516-อาคารพาณิชย์ ประเภทโฮมออฟฟิศ', '517-โรงเลี้ยงสัตว์', '518-โรงงานซ่อมรถยนต์', '519-อาคารจอดรถ', '520/1-อาคารอยู่อาศัยรวม ความสูงไม่เกิน 5 ชั้น', '520/2-อาคารอยู่อาศัยรวม ความสูงเกินกว่า 5 ชั้นขึ้นไป', '521-ป้อมยาม', '522-อาคารพาณิชย์ ประเภทโชว์รูมรถยนต์', '523-ห้องน้ำรวม', '601-รั้วคอนกรีต', '602-รั้วลวดหนาม', '603-รั้วสังกะสี', '604-รั้วลวดถัก', '605-รั้วไม้', '606-รั้วเหล็กดัด', '607-รั้วอัลลอยด์', '608-สระว่ายน้ำ', '609-ลานกีฬาอเนกประสงค์', '610-ถนนคอนกรีต', '611-ลานคอนกรีต', '612-ถนนลาดยาง', '613-ป้ายโฆษณา', '614-ท่าเทียบเรือ'] },
                { id: 'b_mat', label: 'วัสดุ', type: 'select', options: ['ไม้', 'ตึก', 'ตึก/ไม้'] },
                { id: 'b_year', label: 'อายุ (ปี)', type: 'select', options: [1, 2, 3, 5, 7, 10, 15, 20, 25, 30, 35, 40, 45, 50, 70, 80, 100], allowCustom: true },
                { id: 'hs_no', label: 'บ้านเลขที่', type: 'text' },
                { id: 'hs_moo', label: 'หมู่', type: 'select', options: ['', 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]},
                { id: 'no_floor', label: 'จำนวนชั้น', type: 'select', options: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], defaultValue: 1 },
                { id: 'b_area', label: 'พื้นที่ทั้งหลัง (ตร.ม.)', type: 'number', defaultValue: '' },
                { id: 'b_note', label: 'รายละเอียด', type: 'select', options: ['', 'ยุ้งข้าว', 'คอกวัว', 'เล้าไก่', 'คอกหมู', 'โรงจอดรถ', 'ห้องน้ำ', 'ร้านค้าของชำ', 'มินิมาร์ท', 'กระท่อมนา', 'เพิงพัก', 'โรงเก็บของ', 'เก็บฟาง', 'โรงครัว', 'ศาลาพักผ่อน', 'ตู้เติมเงิน', 'ตู้น้ำมันหยอดเหรียญ', 'ตู้น้ำดื่มหยอดเหรียญ', 'รื้อ'], allowCustom: true },
                // ✅ กลุ่มที่ 1 - สีเขียว
                { id: 'b_use', label: 'ใช้ประโยชน์', type: 'select', options: ['', '1-เกษตรกรรม', '2-(1)ที่อยู่อาศัย หลังหลัก', '2-(2)ที่อยู่อาศัย หลังหลักไม่เป็นกรรมสิทธิ์ที่ดิน', '2-(3)ที่อยู่อาศัย หลังอื่นๆ เช่น ให้เช่ารายเดือน', '3-อื่นๆ', '4-ทิ้งไว้ว่างเปล่า/รกร้าง'], customClass: 'bg-custom-green' },
                { id: 'per_use', label: 'การเช่า', type: 'select', options: ['ใช้ประโยชน์เอง', 'ให้เช่า', 'ผู้อื่นใช้'], customClass: 'bg-custom-green' },
                { id: 'full_area', label: 'ใช้ทั้งหลัง', type: 'select', options: ['', 'เต็มพื้นที่', 'บางส่วน'], customClass: 'bg-custom-green' },
                { id: 'buse_floor', label: 'ชั้นที่ใช้', type: 'select', options: ['1-1', '1-2', '1-3', '1-4', '1-5'], allowCustom: true, customClass: 'bg-custom-green' },
                { id: 'buse_area', label: 'พื้นที่ใช้ (ตร.ม.)', type: 'number', customClass: 'bg-custom-green' },
                { id: 'ment_use', label: 'รายละเอียด', type: 'select', options: ['', 'ยุ้งข้าว', 'คอกวัว', 'เล้าไก่', 'คอกหมู', 'โรงจอดรถ', 'ห้องน้ำ', 'ร้านค้าของชำ', 'มินิมาร์ท', 'กระท่อมนา', 'เพิงพัก', 'โรงเก็บของ', 'เก็บฟาง', 'โรงครัว', 'ศาลาพักผ่อน', 'ตู้เติมเงิน', 'ตู้น้ำมันหยอดเหรียญ', 'ตู้น้ำดื่มหยอดเหรียญ', 'รื้อ'], allowCustom: true, customClass: 'bg-custom-green' },
                
                // ✅ กลุ่มที่ 2 - สีชมพู
                { id: 'b_use2', label: 'ใช้ประโยชน์ (2)', type: 'select', options: ['', '1-เกษตรกรรม', '2-(1)ที่อยู่อาศัย หลังหลัก', '2-(2)ที่อยู่อาศัย หลังหลักไม่เป็นกรรมสิทธิ์ที่ดิน', '2-(3)ที่อยู่อาศัย หลังอื่นๆ เช่น ให้เช่ารายเดือน', '3-อื่นๆ', '4-ทิ้งไว้ว่างเปล่า/รกร้าง'], customClass: 'bg-custom-pink' },
                { id: 'per_use2', label: 'การเช่า (2)', type: 'select', options: ['ใช้ประโยชน์เอง', 'ให้เช่า', 'ผู้อื่นใช้'], defaultValue: 'ใช้ประโยชน์เอง' , customClass: 'bg-custom-pink' },
                { id: 'buse_floor2', label: 'ชั้นที่ใช้ (2)', type: 'select', options: ['', '1-1', '1-2', '1-3', '1-4', '1-5'], allowCustom: true, customClass: 'bg-custom-pink' },
                {
                  id: 'buse_area2', 
                  label: 'พื้นที่ใช้ (2) (ตร.ม.)', 
                  type: 'number', 
                  customClass: 'bg-custom-pink',
                  withButtons: true // เพิ่มฟลากรูปปุ่ม
                },
                { id: 'ment_use2', label: 'รายละเอียด (2)', type: 'select', options: ['', 'ยุ้งข้าว', 'คอกวัว', 'เล้าไก่', 'คอกหมู', 'โรงจอดรถ', 'ห้องน้ำ', 'ร้านค้าของชำ', 'มินิมาร์ท', 'กระท่อมนา', 'เพิงพัก', 'โรงเก็บของ', 'เก็บฟาง', 'โรงครัว', 'ศาลาพักผ่อน', 'ตู้เติมเงิน', 'ตู้น้ำมันหยอดเหรียญ', 'ตู้น้ำดื่มหยอดเหรียญ', 'รื้อ'], allowCustom: true, customClass: 'bg-custom-pink' },
                { id: 'full_area2', label: 'ใช้ทั้งหลัง (2)', type: 'select', options: ['', 'บางส่วน'], customClass: 'bg-custom-pink' },
                { 
                  id: 'land_use', 
                  label: 'ใช้ประโยชน์ที่ดิน', 
                  type: 'select', 
                  options: ['', '1-เกษตรกรรม', '2-(1)ที่อยู่อาศัย หลังหลัก', '2-(2)ที่อยู่อาศัย หลังหลักไม่เป็นกรรมสิทธิ์ที่ดิน', '2-(3)ที่อยู่อาศัย หลังอื่นๆ เช่น ให้เช่ารายเดือน', '3-อื่นๆ', '4-ทิ้งไว้ว่างเปล่า/รกร้าง', '5-ใช้ประโยชน์หลายประเภท'], 
                  customClass: 'bg-custom-green',
                  computed: true, // ✅ เพิ่มบรรทัดนี้ (แทน readonly: true)
                  disabled: true  // ✅ เพิ่มบรรทัดนี้
                },
                { id: 'check', label: 'สถานะการตรวจสอบ', type: 'select', options: ['ยังไม่สำรวจ', 'ถ่ายรูปแล้ว', 'ตรวจสอบแล้ว'], customClass: 'bg-custom-check-status' }
            ];

            
            const signFields = [
                { id: 'image', label: 'รูปป้าย', type: 'file', icon: 'camera' },
                { id: 's_code', label: 'รหัสป้าย', type: 'text' },
                { id: 's_name', label: 'ชื่อกิจการ', type: 'text' },
                { id: 's_type', label: 'ประเภทป้าย', type: 'select', options: ['ป้าย/แสดงโฆษณาทั่วไป', 'ป้าย/ป้ายภายในอาคาร 3 ตร.ม. ขึ้นไป', 'ป้ายตามกฎหมายทะเบียนพาณิชย์'] },
                { id: 's_wide', label: 'กว้าง (ซ.ม.)', type: 'number', defaultValue: '' },
                { id: 's_length', label: 'ยาว (ซ.ม.)', type: 'number', defaultValue: '' },
                { id: 'no_side', label: 'จำนวนด้าน', type: 'select', options: [1, 2], defaultValue: 1 },
                // ✅ เพิ่ม 2 ฟิลด์ชั่วคราว (ไม่บันทึกลงชีท)
                { 
                    id: 'content_type_temp', 
                    label: 'ลักษณะเนื้อหา', 
                    type: 'select', 
                    options: ['1.ไทยล้วน', '2.ไทยอยู่บนสุด', '3.ไม่มีไทย', '3.ไทยไม่อยู่บนสุด'],
                    tempField: true // หมายเหตุ: ฟิลด์นี้ไม่บันทึกลงชีท
                },
                { 
                    id: 'sign_type_detail_temp', 
                    label: 'ลักษณะตัวป้าย', 
                    type: 'select', 
                    options: ['(ข) ทั่วไป', '(ก) จอ LED', '(ก) มอเตอร์/เคลื่อนไหว'],
                    tempField: true // หมายเหตุ: ฟิลด์นี้ไม่บันทึกลงชีท
                },
                // ✅ ฟิลด์ "ลักษณะ" แบบอ่านอย่างเดียว (สร้างอัตโนมัติ)
                { 
                    id: 's_characte', 
                    label: 'ลักษณะ', 
                    type: 'text',
                    readonly: true,
                    description: 'ค่านี้สร้างอัตโนมัติจาก 2 ฟิลด์ด้านบน'
                },
                { id: 's_text', label: 'ข้อความในป้าย', type: 'text' },
                { id: 'comment', label: 'หมายเหตุ', type: 'text' },
                { id: 'fullname', label: 'เจ้าของ', type: 'text' },
                { id: 'address', label: 'ที่อยู่', type: 'text' },
                { id: 'check', label: 'สถานะการตรวจสอบ', type: 'select', options: ['ยังไม่สำรวจ', 'ถ่ายรูปแล้ว', 'ตรวจสอบแล้ว'], customClass: 'bg-custom-check-status' }
            ];
            
            const fields = type === 'building' ? buildingFields : signFields;

    // ✅ เพิ่มฟิลด์ประเภทมาร์กเกอร์เป็นบรรทัดแรกของฟอร์ม
            let html = `
                <input type="hidden" id="marker-type" name="marker-type" value="${type}">
                <input type="hidden" name="lat_long" value="${data.lat_long || ''}">
            `;
            fields.forEach(f => {
                html += `<div class="mb-2">`;
                
                // ✅ สร้าง <label> เฉพาะฟิลด์ที่ไม่ใช่ 'file'
                if (f.type !== 'file') {
                    html += `<label class="form-label">${f.label}</label>`;
                }
                
                // ✅ ตรวจสอบฟิลด์ "สถานะการตรวจสอบ" และตั้งค่าอัตโนมัติถ้ามีชื่อรูปภาพในคอลั่มน์ 'picture' (แต่ไม่ทับถ้าเป็น 'ตรวจสอบแล้ว')
                let fieldValue = data[f.id] || '';
                if (f.id === 'check') {
                    // ⚠️ ถ้าสถานะปัจจุบันคือ 'ตรวจสอบแล้ว' → คงค่าไว้ทันที (สถานะสูงสุด ไม่ย้อนกลับ)
                    if (fieldValue === 'ตรวจสอบแล้ว') {
                        // ไม่ทำอะไร → คงค่า 'ตรวจสอบแล้ว' ไว้
                    } 
                    // ✅ ถ้าไม่ใช่ 'ตรวจสอบแล้ว' และมีชื่อรูปภาพในคอลั่มน์ 'picture' → ตั้งค่าเป็น 'ถ่ายรูปแล้ว'
                    else if (data.picture && data.picture.trim() !== '') {
                        fieldValue = 'ถ่ายรูปแล้ว';
                    }
                    // ถ้าไม่มีชื่อรูปภาพและไม่ใช่ 'ตรวจสอบแล้ว' → คงค่าเดิม (เช่น 'ยังไม่สำรวจ' หรือค่าว่าง)
                }
                
                if (f.type === 'textarea') {
                    const customClass = f.customClass || '';
                    html += `<textarea name="${f.id}" class="form-input ${customClass}" rows="2"${f.readonly ? ' readonly' : ''}>${fieldValue}</textarea>`;
                } else if (f.type === 'file') {
                    // ✅ ดึงชื่อไฟล์จากคอลั่มน์ 'picture' แทน 'image'
                    let fileName = '';
                    if (type === 'building') {
                        fileName = data.picture || data.image?.split('/').pop()?.split('?')[0] || 'ยังไม่มีรูปภาพ';
                    } else if (type === 'sign') {
                        fileName = data.picture || data.image?.split('/').pop()?.split('?')[0] || 'ยังไม่มีรูปภาพ';
                    }
                    
                    // ✅ แทนที่โค้ดเดิม (ประมาณบรรทัด 1800-1820) ด้วยโค้ดนี้
                    html += `
                    <div class="mb-2">
                        <div class="mb-3">
                            <label class="form-label flex items-center gap-1">
                                <i data-lucide="camera" class="w-3 h-3"></i>
                                ${f.label}
                            </label>
                            <input type="file" name="${f.id}" accept="image/*" capture="environment" class="hidden" id="file-input-${f.id}">
                            <button type="button" onclick="document.getElementById('file-input-${f.id}').click()" 
                                class="w-full bg-gradient-to-r from-blue-500 to-blue-600 text-white py-2 px-2 rounded-md font-semibold text-sm shadow-sm hover:from-blue-600 hover:to-blue-700 transition-all flex items-center justify-center gap-1">
                                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M14.5 4h-4L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-3.5-3z"></path>
                                    <circle cx="12" cy="13" r="3"></circle>
                                    <path d="M12 10v3l1.5 1.5"></path>
                                </svg>
                                <span>เปิดกล้อง</span>
                            </button>
                            
                            <!-- ✅ ป้ายแสดงชื่อรูปภาพที่คลิกได้ -->
                            <div id="filename-container-${f.id}" class="mt-1.5">
                                <span id="filename-badge-${f.id}" 
                                    class="text-[10px] text-blue-600 font-medium px-2 py-0.5 bg-blue-50 rounded-full inline-flex items-center gap-1 cursor-pointer hover:bg-blue-100 transition"
                                    onclick="handleImageBadgeClick('${data.image || ''}', '${data.picture || 'ไม่มีชื่อรูปภาพ'}')">
                                    <i data-lucide="image" class="w-3 h-3"></i>
                                    <span id="filename-text-${f.id}">${fileName}</span>
                                </span>
                            </div>
                        </div>
                    </div>`;
                } else if (f.type === 'select') {
                    const customClass = f.customClass || '';
                    // ✅ เพิ่มเงื่อนไข disabled
                    const isDisabled = f.disabled ? 'disabled' : '';
                    
                    if (f.allowCustom) {
                        const value = fieldValue !== undefined && fieldValue !== null && fieldValue !== '' ? fieldValue : (f.defaultValue !== undefined ? f.defaultValue : '');
                        html += `<input type="text" name="${f.id}" class="form-input ${customClass}" list="${f.id}-options" value="${value}" ${isDisabled}>`;
                        html += `<datalist id="${f.id}-options">`;
                        f.options.forEach(opt => {
                            html += `<option value="${opt}">${opt}</option>`;
                        });
                        html += `</datalist>`;
                    } else {
                        const value = fieldValue !== undefined && fieldValue !== null && fieldValue !== '' ? fieldValue : (f.defaultValue !== undefined ? f.defaultValue : '');
                        html += `<select name="${f.id}" class="form-input ${customClass}" ${isDisabled}>`; // ✅ เพิ่ม ${isDisabled}
                        f.options.forEach(opt => {
                            const selected = String(value) === String(opt) ? 'selected' : '';
                            html += `<option value="${opt}" ${selected}>${opt}</option>`;
                        });
                        html += `</select>`;
                    }

            } else if (f.type === 'number') {
                const customClass = f.customClass || '';
                // ✅ ตรวจสอบว่าเป็นฟิลด์ buse_area2 ที่ต้องการปุ่ม
                if (f.id === 'buse_area2' && f.withButtons) {
                    html += `
                    <div class="flex gap-2 items-center">
                        <input type="number" name="${f.id}" class="form-input ${customClass} flex-1" value="${fieldValue}"${f.readonly ? ' readonly' : ''}>
                        <div class="flex gap-1">
                            <!-- ปุ่มแรก: สีส้ม ข้อความ "B" -->
                            <button type="button" onclick="openAreaCalculator()" 
                                class="px-3 py-2 bg-orange-500 text-white rounded font-bold text-sm hover:bg-orange-600 transition"
                                title="คำนวณพื้นที่">
                                B
                            </button>
                            <!-- ปุ่มที่สอง: สีเขียว ไอคอนสามเหลี่ยม (Δ) -->
                            <button type="button" onclick="calculateDeltaArea()" 
                                class="px-3 py-2 bg-green-500 text-white rounded font-bold text-sm hover:bg-green-600 transition"
                                title="คำนวณผลต่าง">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M12 2L22 22H2L12 2z"></path>
                                </svg>
                            </button>
                        </div>
                    </div>
                    `;
                } else {
                    html += `<input type="${f.type}" name="${f.id}" class="form-input ${customClass}" value="${fieldValue}"${f.readonly ? ' readonly' : ''}>`;
                }
            } else {
                const customClass = f.customClass || '';
                html += `<input type="${f.type}" name="${f.id}" class="form-input ${customClass}" value="${fieldValue}"${f.readonly ? ' readonly' : ''}>`;
            }
                html += `</div>`;
            });
            
            form.innerHTML = html;
            // ✅ เพิ่มหลังจาก form.innerHTML = html; ในฟังก์ชัน openEditPanel()
            // ✅ วางโค้ดผูกเหตุการณ์ที่นี่ (หลัง form.innerHTML)
            // ✅ ผูกเหตุการณ์อัปเดตชื่อรูปภาพเมื่อเลือกไฟล์ใหม่ (วางหลัง form.innerHTML = html;)
            // ✅ ผูกเหตุการณ์อัปเดตชื่อรูปภาพ + สถานะการตรวจสอบเมื่อเลือกไฟล์ใหม่
            const fileInputs = form.querySelectorAll('input[type="file"]');
            fileInputs.forEach(input => {
                input.addEventListener('change', (e) => {
                    const fileId = input.id.replace('file-input-', '');
                    const fileNameBadge = document.getElementById(`filename-text-${fileId}`);
                    const checkSelect = form.querySelector('select[name="check"]'); // ดึงฟิลด์สถานะ
                    
                    if (e.target.files.length > 0) {
                        // สร้างชื่อไฟล์ใหม่
                        const file = e.target.files[0];
                        const prefix = type === 'building' ? 'B' : 'S';
                        const code = data.building_c || data.s_code || Date.now().toString().slice(-5);
                        const extension = file.name.split('.').pop().toLowerCase();
                        const fileName = `${prefix}${code}.${extension}`;
                        
                        // ✅ อัปเดตป้ายชื่อรูปภาพ
                        fileNameBadge.textContent = fileName;
                        
                        // ✅ อัปเดตสถานะการตรวจสอบทันที (ถ้าเป็น "ยังไม่สำรวจ")
                        if (checkSelect && checkSelect.value === 'ยังไม่สำรวจ') {
                            checkSelect.value = 'ถ่ายรูปแล้ว';
                            console.log('✅ สถานะเปลี่ยนเป็น: ถ่ายรูปแล้ว');
                        }
                        // ⚠️ ถ้าเป็น "ตรวจสอบแล้ว" → ไม่ทำอะไร (คงค่าเดิม)
                    } else {
                        fileNameBadge.textContent = 'ยังไม่มีรูปภาพ';
                    }
                });
            });

            // ✅ ผูกเหตุการณ์เมื่อเลือกค่าใน 'ประเภทสิ่งปลูกสร้าง' เพื่อตั้งค่าวัสดุตามเงื่อนไขใหม่
            if (type === 'building') {
                const bTypeSelect = document.querySelector('select[name="b_type"]');
                const bMatSelect = document.querySelector('select[name="b_mat"]');
                
                if (bTypeSelect && bMatSelect) {
                    const updateBMat = () => {
                        const selectedValue = bTypeSelect.value;
                        
                        // ✅ ตรวจสอบกรณีพิเศษก่อน (106-บ้านพักอาศัยครึ่งตึกครึ่งไม้สองชั้น)
                        if (selectedValue === '106-บ้านพักอาศัยครึ่งตึกครึ่งไม้สองชั้น') {
                            bMatSelect.value = 'ตึก/ไม้';
                        } 
                        // ✅ ตรวจสอบคำว่า "ไม้" (ไม่รวมกรณีพิเศษเพราะตรวจสอบก่อนแล้ว)
                        else if (selectedValue.includes('ไม้')) {
                            bMatSelect.value = 'ไม้';
                        } 
                        // ✅ ตรวจสอบคำว่า "ตึก" (ไม่รวมกรณีพิเศษ)
                        else if (selectedValue.includes('ตึก')) {
                            bMatSelect.value = 'ตึก';
                        }
                        // ถ้าไม่ตรงเงื่อนไขใด ๆ → คงค่าเดิม (ไม่ล้างค่า)
                    };
                    
                    // ผูกเหตุการณ์เมื่อเปลี่ยนค่าใน "ประเภทสิ่งปลูกสร้าง"
                    bTypeSelect.addEventListener('change', updateBMat);
                    
                    // ตั้งค่าเริ่มต้นเมื่อเปิดแผง (ใช้ข้อมูลที่มีอยู่)
                    updateBMat();
                    
                    console.log('✅ ผูกเหตุการณ์ตั้งค่าวัสดุอัตโนมัติจากประเภทสิ่งปลูกสร้าง (เงื่อนไขใหม่)');
                }
            }

            // ✅ ผูกเหตุการณ์เมื่อเลือกค่าใน 'ประเภทสิ่งปลูกสร้าง' เพื่อตั้งค่าจำนวนชั้นตามเงื่อนไข
            if (type === 'building') {
                const bTypeSelect = document.querySelector('select[name="b_type"]');
                const noFloorSelect = document.querySelector('select[name="no_floor"]');
                if (bTypeSelect && noFloorSelect) {
                    const updateNoFloor = () => {
                        const selectedValue = bTypeSelect.value;
                        // ✅ ตรวจสอบคำว่า "ชั้นเดียว"
                        if (selectedValue.includes('ชั้นเดียว')) {
                            noFloorSelect.value = '1';
                        }
                        // ✅ ตรวจสอบคำว่า "สองชั้น"
                        else if (selectedValue.includes('สองชั้น')) {
                            noFloorSelect.value = '2';
                        }
                        // ✅ ตรวจสอบคำว่า "สามชั้น"
                        else if (selectedValue.includes('สามชั้น')) {
                            noFloorSelect.value = '3';
                        }
                        // ✅ ตรวจสอบคำว่า "สี่ชั้น"
                        else if (selectedValue.includes('สี่ชั้น')) {
                            noFloorSelect.value = '4';
                        }
                        // ✅ ตรวจสอบคำว่า "ห้าชั้น"
                        else if (selectedValue.includes('ห้าชั้น')) {
                            noFloorSelect.value = '5';
                        }
                        // ✅ ตรวจสอบคำว่า "หกชั้น"
                        else if (selectedValue.includes('หกชั้น')) {
                            noFloorSelect.value = '6';
                        }
                        // ถ้าไม่ตรงเงื่อนไขใด ๆ → คงค่าเดิม (ไม่ล้างค่า)
                    };
                    // ผูกเหตุการณ์เมื่อเปลี่ยนค่าใน "ประเภทสิ่งปลูกสร้าง"
                    bTypeSelect.addEventListener('change', updateNoFloor);
                    // ตั้งค่าเริ่มต้นเมื่อเปิดแผง (ใช้ข้อมูลที่มีอยู่)
                    updateNoFloor();
                    console.log('✅ ผูกเหตุการณ์ตั้งค่าจำนวนชั้นอัตโนมัติจากประเภทสิ่งปลูกสร้าง');
                }
            }

            // ✅ ผูกเหตุการณ์เมื่อเลือกค่าใน 'ใช้ทั้งหลัง' + อัปเดต "ชั้นที่ใช้", "พื้นที่ใช้" และ "ใช้ทั้งหลัง (2)" อัตโนมัติ
            if (type === 'building') {
                const fullAreaSelect = document.querySelector('select[name="full_area"]');
                const noFloorSelect = document.querySelector('select[name="no_floor"]');
                const buseFloorInput = document.querySelector('input[name="buse_floor"]');
                const bAreaInput = document.querySelector('input[name="b_area"]');
                const buseAreaInput = document.querySelector('input[name="buse_area"]');
                const fullArea2Select = document.querySelector('select[name="full_area2"]'); // ✅ เพิ่มการอ้างอิง
                
                if (fullAreaSelect && noFloorSelect && buseFloorInput && bAreaInput && buseAreaInput && fullArea2Select) {
                    // ฟังก์ชันอัปเดต "ชั้นที่ใช้" จาก "จำนวนชั้น" (เฉพาะเมื่อเลือก "เต็มพื้นที่")
                    const updateBuseFloor = () => {
                        if (fullAreaSelect.value === 'เต็มพื้นที่') {
                            const noFloorValue = noFloorSelect.value;
                            buseFloorInput.value = noFloorValue ? `1-${noFloorValue}` : '1-1';
                        }
                    };
                    
                    // ฟังก์ชันอัปเดต "พื้นที่ใช้" จาก "พื้นที่ทั้งหลัง" (เฉพาะเมื่อเลือก "เต็มพื้นที่")
                    const updateBuseArea = () => {
                        if (fullAreaSelect.value === 'เต็มพื้นที่') {
                            buseAreaInput.value = bAreaInput.value || '';
                        }
                    };
                    
                    // ✅ ฟังก์ชันตั้งค่า "ใช้ทั้งหลัง (2)" เมื่อเลือก "บางส่วน"
                    const syncFullArea2 = () => {
                        if (fullAreaSelect.value === 'บางส่วน' && !fullArea2Select.disabled) {
                            fullArea2Select.value = 'บางส่วน';
                        }
                    };
                    
                    // ฟังก์ชันจัดการกลุ่มที่ 2 (ล้างค่า + ปิดการแก้ไขเมื่อเลือก "เต็มพื้นที่")
                    const toggleGroup2 = () => {
                        const isFullArea = fullAreaSelect.value === 'เต็มพื้นที่';
                        
                        // รายการช่องในกลุ่มที่ 2 ที่ต้องล้างค่าและปิดการแก้ไข
                        const group2Fields = [
                            'b_use2', 'per_use2', 'buse_floor2', 'buse_area2', 'ment_use2'
                            // ❌ ไม่รวม 'full_area2' เพราะจัดการแยกต่างหาก
                        ];
                        
                        // จัดการช่องกลุ่มที่ 2 (ยกเว้น full_area2)
                        group2Fields.forEach(fieldId => {
                            const field = document.querySelector(`[name="${fieldId}"]`);
                            if (field) {
                                if (isFullArea) {
                                    field.value = '';
                                    field.disabled = true;
                                    field.style.backgroundColor = '#f3f4f6';
                                    field.style.cursor = 'not-allowed';
                                } else {
                                    field.disabled = false;
                                    field.style.backgroundColor = '';
                                    field.style.cursor = '';
                                }
                            }
                        });
                        
                        // ✅ จัดการ "ใช้ทั้งหลัง (2)" แยกต่างหาก
                        if (isFullArea) {
                            // ล้างค่าและปิดการแก้ไขเมื่อเลือก "เต็มพื้นที่"
                            fullArea2Select.value = '';
                            fullArea2Select.disabled = true;
                            fullArea2Select.style.backgroundColor = '#f3f4f6';
                            fullArea2Select.style.cursor = 'not-allowed';
                            
                            // ✅ ทริกเกอร์เหตุการณ์ change บน b_use2 เพื่ออัปเดต land_use ทันที
                            const bUse2Field = document.querySelector('select[name="b_use2"]');
                            if (bUse2Field) {
                                // ตั้งค่าเป็นว่างก่อน (เพื่อความชัดเจน)
                                bUse2Field.value = '';
                                // สร้างและส่งเหตุการณ์ change
                                const changeEvent = new Event('change', { bubbles: true });
                                bUse2Field.dispatchEvent(changeEvent);
                                console.log('✅ ทริกเกอร์ change event บน b_use2 เพื่ออัปเดต land_use');
                            }
                        } else {
                            // เปิดการแก้ไขเมื่อไม่ได้เลือก "เต็มพื้นที่"
                            fullArea2Select.disabled = false;
                            fullArea2Select.style.backgroundColor = '';
                            fullArea2Select.style.cursor = '';
                            
                            // ✅ ตั้งค่าเป็น "บางส่วน" ทันทีเมื่อเลือก "บางส่วน" ใน full_area
                            syncFullArea2();
                        }
                        
                        // อัปเดต "ชั้นที่ใช้" และ "พื้นที่ใช้"
                        updateBuseFloor();
                        updateBuseArea();
                    };
                    
                    // ผูกเหตุการณ์เมื่อเลือกค่าใน "ใช้ทั้งหลัง"
                    fullAreaSelect.addEventListener('change', toggleGroup2);
                    
                    // ผูกเหตุการณ์เมื่อเปลี่ยน "จำนวนชั้น"
                    noFloorSelect.addEventListener('change', updateBuseFloor);
                    
                    // ผูกเหตุการณ์เมื่อเปลี่ยน "พื้นที่ทั้งหลัง"
                    bAreaInput.addEventListener('input', updateBuseArea);
                    
                    // ✅ ผูกเหตุการณ์เพิ่มเติม: อัปเดต full_area2 เมื่อ full_area เปลี่ยนเป็น "บางส่วน"
                    fullAreaSelect.addEventListener('change', syncFullArea2);
                    
                    // ตั้งค่าเริ่มต้นเมื่อเปิดแผง
                    toggleGroup2();
                }
            }
            // ✅ คำนวณค่า "ใช้ประโยชน์ที่ดิน" อัตโนมัติ (เฉพาะสิ่งปลูกสร้าง)
            if (type === 'building') {
                const updateLandUse = () => {
                    const bUse = document.querySelector('select[name="b_use"]')?.value || '';
                    const bUse2 = document.querySelector('select[name="b_use2"]')?.value || '';
                    const landUseSelect = document.querySelector('select[name="land_use"]');
                    
                    if (!landUseSelect) return;
                    
                    let newValue = '';
                    
                    // เงื่อนไขการคำนวณ
                    if (bUse && bUse2) {
                        newValue = '5-ใช้ประโยชน์หลายประเภท'; // ทั้งสองช่องมีค่า
                    } else if (bUse) {
                        newValue = bUse; // มีค่าจาก b_use เท่านั้น
                    } else if (bUse2) {
                        newValue = bUse2; // มีค่าจาก b_use2 เท่านั้น
                    }
                    
                    // ตั้งค่าและปิดการแก้ไข
                    landUseSelect.value = newValue;
                    landUseSelect.disabled = true; // ป้องกันการแก้ไข
                    landUseSelect.style.backgroundColor = '#f3f4f6'; // สีพื้นหลังเทาอ่อน
                    landUseSelect.style.cursor = 'not-allowed';
                };
                
                // ผูกเหตุการณ์เมื่อเลือกค่า
                const bUseSelect = document.querySelector('select[name="b_use"]');
                const bUse2Select = document.querySelector('select[name="b_use2"]');
                
                if (bUseSelect && bUse2Select) {
                    bUseSelect.addEventListener('change', updateLandUse);
                    bUse2Select.addEventListener('change', updateLandUse);
                    
                    // ตั้งค่าเริ่มต้น
                    updateLandUse();
                }
            }
            // ✅ เชื่อมโยงค่าจาก 'b_note' ไปยัง 'ment_use' และ 'ment_use2' (อัปเดตทุกครั้งที่ b_note เปลี่ยน)
            if (type === 'building') {
                const bNoteInput = document.querySelector('input[name="b_note"]');
                const mentUseInput = document.querySelector('input[name="ment_use"]');
                const mentUse2Input = document.querySelector('input[name="ment_use2"]');
                
                if (bNoteInput && mentUseInput && mentUse2Input) {
                    // ✅ ฟังก์ชันอัปเดตจาก b_note (ทุกครั้งที่เปลี่ยน)
                    const syncFromBNote = () => {
                        const value = bNoteInput.value;
                        
                        // ✅ อัปเดต ment_use เสมอ ไม่มีเงื่อนไข ไม่มีข้อยกเว้น
                        mentUseInput.value = value;
                        console.log(`🔄 b_note เปลี่ยน → ment_use = "${value}"`);
                        
                        // ✅ อัปเดต ment_use2 เฉพาะเมื่อเปิดการแก้ไขอยู่ (ตรวจสอบสถานะปัจจุบันทุกครั้ง)
                        if (!mentUse2Input.disabled) {
                            mentUse2Input.value = value;
                            console.log(`🔄 b_note เปลี่ยน → ment_use2 = "${value}" (เปิดการแก้ไขอยู่)`);
                        } else {
                            console.log(`⏭️ b_note เปลี่ยน แต่ ment_use2 ถูกปิดการแก้ไข → ไม่อัปเดต`);
                        }
                    };
                    
                    // ✅ ใช้เหตุการณ์ 'change' (เมื่อผู้ใช้เสร็จสิ้นการแก้ไข)
                    bNoteInput.addEventListener('change', syncFromBNote);
                    
                    // ✅ ตั้งค่าเริ่มต้นเมื่อเปิดแผง
                    // syncFromBNote();
                    
                    console.log('✅ เชื่อมโยง b_note → ment_use (ทุกครั้งที่เปลี่ยน) + ment_use2 (ถ้าเปิดการแก้ไข)');
                } else {
                    console.warn('⚠️ ไม่พบฟิลด์ b_note, ment_use หรือ ment_use2');
                }
            }
            if (type === 'sign') {
                // ฟังก์ชันอัปเดตค่า s_characte อัตโนมัติ
                const updateSCharacte = () => {
                    const contentTypeEl = document.querySelector('select[name="content_type_temp"]');
                    const signTypeDetailEl = document.querySelector('select[name="sign_type_detail_temp"]');
                    const sCharacteEl = document.querySelector('input[name="s_characte"]');
                    
                    if (!contentTypeEl || !signTypeDetailEl || !sCharacteEl) return;
                    
                    const num = contentTypeEl.value.charAt(0); // ดึงเลขหน้าสุด (1, 2, 3, 4)
                    const letterMatch = signTypeDetailEl.value.match(/\(([^)]+)\)/); // ดึงตัวอักษรในวงเล็บ
                    const letter = letterMatch ? letterMatch[1].charAt(0) : ''; // เอาแค่ตัวแรก (ก หรือ ข)
                    
                    sCharacteEl.value = num && letter ? `${num}(${letter})` : '-';
                };
                
                // ผูกเหตุการณ์เมื่อเลือกค่า
                const contentTypeEl = document.querySelector('select[name="content_type_temp"]');
                const signTypeDetailEl = document.querySelector('select[name="sign_type_detail_temp"]');
                
                if (contentTypeEl && signTypeDetailEl) {
                    contentTypeEl.addEventListener('change', updateSCharacte);
                    signTypeDetailEl.addEventListener('change', updateSCharacte);
                    
                    // ตั้งค่าเริ่มต้นจากข้อมูลเดิม (ถ้ามี)
                    if (data.s_characte) {
                        const match = data.s_characte.match(/^(\d)\(([^)]+)\)$/);
                        if (match) {
                            const num = match[1];
                            const letter = match[2];
                            
                            // ตั้งค่าลักษณะเนื้อหา
                            for (let opt of contentTypeEl.options) {
                                if (opt.value.startsWith(`${num}.`)) {
                                    contentTypeEl.value = opt.value;
                                    break;
                                }
                            }
                            
                            // ตั้งค่าลักษณะตัวป้าย
                            for (let opt of signTypeDetailEl.options) {
                                if (opt.value.includes(`(${letter})`)) {
                                    signTypeDetailEl.value = opt.value;
                                    break;
                                }
                            }
                        }
                    }
                    
                    // อัปเดตค่าเริ่มต้น
                    updateSCharacte();
                }
            }

            // ✅ ตรวจสอบว่าหน้าต่างรูปภาพเปิดอยู่หรือไม่ → อัปเดตรูปภาพอัตโนมัติ
            const imagePreviewContainer = document.getElementById('image-preview-container');
            if (imagePreviewContainer && imagePreviewContainer.style.display === 'flex') {
                console.log('🖼️ หน้าต่างรูปภาพเปิดอยู่ → อัปเดตรูปภาพใหม่');
                if (data.image && data.image.trim() !== '') {
                    showImagePreview(data.image, data.picture || 'รูปภาพ');
                } else {
                    // ถ้าไม่มีรูปภาพ → แสดงข้อความในหน้าต่างรูปภาพแทนการซ่อน
                    const placeholder = document.getElementById('image-preview-placeholder');
                    const img = document.getElementById('image-preview');
                    if (placeholder && img) {
                        img.classList.add('hidden');
                        placeholder.textContent = '⚠️ รายการนี้ยังไม่มีรูปภาพ';
                        placeholder.classList.remove('text-gray-300');
                        placeholder.classList.add('text-yellow-500', 'font-medium');
                    }
                }
            }

            document.getElementById('side-panel').classList.add('open');
            marker.closePopup();
        }

        function closePanel() {
            const panel = document.getElementById('side-panel');
            if (panel) {
                panel.classList.remove('open');
            }
            // ✅ ซ่อนรูปภาพเมื่อปิดแผง (ยังคงต้องการ)
            // hideImagePreview();
        }


        function locateUser() { 
            map.locate({setView: true, maxZoom: 18}); 
            map.once('locationfound', (e) => {
                L.circleMarker(e.latlng, { radius: 8, fillColor: '#2563eb', color: '#fff', weight: 3, fillOpacity: 0.9 }).addTo(map);
            });
        }
        // ตัวแปรเก็บข้อมูลสำหรับการลบ
        let deleteMarkerData = null;
        let deleteMarkerType = null;
        let deleteMarkerRef = null;

        // เปิดหน้าต่างยืนยันการลบ
        function showDeleteConfirm(marker, data, type) {
            deleteMarkerRef = marker;
            deleteMarkerData = data;
            deleteMarkerType = type;
            
            const title = document.getElementById('delete-modal-title');
            const message = document.getElementById('delete-modal-message');
            
            if (type === 'building') {
                title.textContent = 'ลบสิ่งปลูกสร้าง';
                message.textContent = 'คุณแน่ใจว่าต้องการลบสิ่งปลูกสร้างนี้? การกระทำนี้ไม่สามารถยกเลิกได้';
            } else {
                title.textContent = 'ลบป้าย';
                message.textContent = 'คุณแน่ใจว่าต้องการลบป้ายนี้? การกระทำนี้ไม่สามารถยกเลิกได้';
            }
            
            document.getElementById('confirm-delete-modal').classList.remove('hidden');
            document.getElementById('confirm-delete-modal').classList.add('flex');
        }

        // ปิดหน้าต่างยืนยันการลบ
        function cancelDelete() {
            document.getElementById('confirm-delete-modal').classList.add('hidden');
            deleteMarkerData = null;
            deleteMarkerType = null;
            deleteMarkerRef = null;
        }

        // ยืนยันการลบ
        async function confirmDeleteAction() {
            if (!deleteMarkerRef || !deleteMarkerData || !deleteMarkerType) {
                cancelDelete();
                return;
            }
            
            // ปิดหน้าต่างยืนยัน
            document.getElementById('confirm-delete-modal').classList.add('hidden');
            
            try {
                await deleteMarker(deleteMarkerRef, deleteMarkerData, deleteMarkerType);
            } catch (err) {
                console.error("Error in delete action:", err);
            } finally {
                cancelDelete();
            }
        }

        // เปิดหน้าต่างโหมดแก้ไข
        function showEditModeModal() {
            document.getElementById('edit-mode-modal').classList.remove('hidden');
            document.getElementById('edit-mode-modal').classList.add('flex');
            
            // ปิดอัตโนมัติหลัง 3 วินาที
            setTimeout(() => {
                closeEditModeModal();
            }, 4000);
        }

        // ปิดหน้าต่างโหมดแก้ไข
        function closeEditModeModal() {
            document.getElementById('edit-mode-modal').classList.add('hidden');
        }

        // ฟังก์ชันสำหรับแสดง/ซ่อนตาราง
        function toggleTable() {
            const panel = document.getElementById('data-table-panel');
            const imagePreview = document.getElementById('image-preview-container');
            const btn = document.getElementById('btn-show-table');
            
            panel.classList.toggle('open');
            
            // ✅ จัดการตำแหน่งองค์ประกอบแสดงรูปภาพตามสถานะของตาราง
            if (panel.classList.contains('open')) {
                // เปิดตาราง → ย้ายรูปภาพขึ้นเหนือตาราง
                if (imagePreview && imagePreview.style.display !== 'none') {
                    imagePreview.style.bottom = `calc(5px + 45vh + 10px)`;
                }
                btn.innerHTML = '<i data-lucide="x" class="w-6 h-6 text-red-600"></i>';
            } else {
                // ปิดตาราง → ย้ายรูปภาพกลับมาที่ตำแหน่งเดิม (แทนที่ตาราง)
                if (imagePreview && imagePreview.style.display !== 'none') {
                    imagePreview.style.bottom = '5px';
                }
                btn.innerHTML = '<i data-lucide="table" class="w-6 h-6 text-blue-600"></i>';
            }
            
            lucide.createIcons();
        }

        // ฟังก์ชันสลับแท็บตาราง
        function switchTableTab(type) {
            // เปลี่ยนแท็บ
            document.querySelectorAll('.table-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // แสดงตารางที่เลือก
            document.getElementById('building-table-container').classList.toggle('hidden', type !== 'building');
            document.getElementById('sign-table-container').classList.toggle('hidden', type !== 'sign');
        }

        // ฟังก์ชันซูมไปที่ตำแหน่ง
        function zoomToLocation(latlng, zoomLevel = 18) {
            map.setView(latlng, zoomLevel);
            
            // สร้างเอฟเฟกต์กระพริบ
            const blinkMarker = L.circleMarker(latlng, {
                radius: 15,
                fillColor: '#22d3ee',
                color: '#fff',
                weight: 3,
                fillOpacity: 0.8,
                opacity: 1
            }).addTo(map);
            
            // กระพริบ 3 ครั้ง
            let count = 0;
            const blinkInterval = setInterval(() => {
                blinkMarker.setStyle({
                    opacity: blinkMarker.options.opacity === 1 ? 0 : 1,
                    fillOpacity: blinkMarker.options.fillOpacity === 0.8 ? 0 : 0.8
                });
                count++;
                if (count >= 6) {
                    clearInterval(blinkInterval);
                    map.removeLayer(blinkMarker);
                }
            }, 300);
        }

        // ฟังก์ชันสร้างแถวข้อมูลสิ่งปลูกสร้าง
        function renderBuildingTable() {
            const tbody = document.getElementById('building-table-body');
            
            if (!allBuildings || allBuildings.length === 0) {
                tbody.innerHTML = '<tr><td colspan="15" class="text-center py-8 text-gray-500">ไม่มีข้อมูลสิ่งปลูกสร้าง</td></tr>';
                return;
            }
            
            // ✅ เรียงข้อมูลตาม ID (เรียงจากน้อยไปมากตามลำดับอักขระ)
            const sortedBuildings = sortBuildings(allBuildings, buildingSortColumn, buildingSortDirection);

            tbody.innerHTML = sortedBuildings.map(building => {
                if (!building.lat_long) return '';
                
                const [lat, lng] = building.lat_long.split(',').map(Number);
                if (isNaN(lat) || isNaN(lng)) return '';
                
                // ✅ กำหนดสีสถานะการตรวจสอบ
                let statusClass = 'status-ยังไม่สำรวจ';
                let statusText = building.check || 'ยังไม่สำรวจ';
                
                if (building.check === 'ถ่ายรูปแล้ว') {
                    statusClass = 'status-ถ่ายรูปแล้ว';
                } else if (building.check === 'ตรวจสอบแล้ว') {
                    statusClass = 'status-ตรวจสอบแล้ว';
                }
                
                // ✅ ฟังก์ชันช่วยแสดงค่า (ถ้าไม่มีให้แสดง "-")
                const displayValue = (val) => val && val.toString().trim() !== '' ? val : '-';
                
                return `
                    <tr>
                        <td><span class="marker-icon marker-building"></span></td>
                        <td class="font-medium">${displayValue(building.building_c)}</td>
                        <td>${displayValue(building.full_name)}</td>
                        <td class="text-center">${displayValue(building.hs_no)}</td>
                        <td class="text-center">${displayValue(building.hs_moo)}</td>
                        <td>${displayValue(building.b_type)}</td>
                        <td class="text-center">${displayValue(building.b_mat)}</td>
                        <td class="text-center">${displayValue(building.no_floor)}</td>
                        <td class="text-center">${displayValue(building.b_area)}</td>
                        <td class="text-center">${displayValue(building.b_year)}</td>
                        <td>${displayValue(building.b_note)}</td>
                        <td>${displayValue(building.b_use)}</td>
                        <td>${displayValue(building.b_use2)}</td>
                        <td>${displayValue(building.land_use)}</td>
                        <td><span class="status-badge ${statusClass}">${statusText}</span></td>
                        <td>
                            <button class="zoom-btn" onclick="zoomToLocation(L.latLng(${lat}, ${lng}))">
                                <i data-lucide="locate" class="w-3 h-3 inline"></i>
                            </button>
                        </td>
                    </tr>
                `;
            }).join('');
            // ✅ อัปเดตจำนวนที่หัวตาราง
            updateTableCounters();

            // ✅ สร้างไอคอนหลังเรนเดอร์ตารางเสร็จ
            lucide.createIcons();
        }

        // อัปเดตจำนวนสิ่งปลูกสร้างและป้ายที่หัวตาราง
        function updateTableCounters() {
            const buildingCount = allBuildings ? allBuildings.length : 0;
            const signCount = allSigns ? allSigns.length : 0;
            
            const buildingBadge = document.getElementById('building-count-badge');
            const signBadge = document.getElementById('sign-count-badge');
            
            if (buildingBadge) {
                buildingBadge.textContent = buildingCount;
            }
            
            if (signBadge) {
                signBadge.textContent = signCount;
            }
            
            console.log(`📊 จำนวนสิ่งปลูกสร้าง: ${buildingCount}, จำนวนป้าย: ${signCount}`);
        }

        // ============================================
        // ฟังก์ชันเมนูฟันเฟือง
        // ============================================

        /**
         * เปิด/ปิดเมนูฟันเฟือง
         */
        function toggleSettingsMenu() {
          const menu = document.getElementById('settings-menu');
          const icon = document.getElementById('settings-icon');
          const badge = document.getElementById('settings-badge');
          
          if (menu.classList.contains('hidden')) {
            // เปิดเมนู - ปุ่มย่อยเลื่อนลงมาทีละปุ่ม
            menu.classList.remove('hidden');
            icon.classList.add('animate-spin');
            
            // ซ่อนจุดแจ้งเตือน (ถ้ามี)
            badge.classList.add('hidden');
            
            // แอนิเมชันเลื่อนลงมาทีละปุ่ม
            setTimeout(() => {
              const buttons = menu.querySelectorAll('button');
              buttons.forEach((btn, index) => {
                setTimeout(() => {
                  btn.style.transform = 'translateY(0)';
                  btn.style.opacity = '1';
                }, index * 100);
              });
            }, 100);
            
            // ปิดเมนูอัตโนมัติเมื่อคลิกที่อื่น
            setTimeout(() => {
              document.addEventListener('click', closeSettingsMenuOnClickOutside);
            }, 100);
            
          } else {
            // ปิดเมนู
            closeSettingsMenu();
          }
        }

        /**
         * ปิดเมนูเมื่อคลิกที่อื่น
         */
        function closeSettingsMenuOnClickOutside(e) {
          const settingsBtn = document.getElementById('btn-settings');
          const settingsMenu = document.getElementById('settings-menu');
          
          if (!settingsBtn.contains(e.target) && !settingsMenu.contains(e.target)) {
            closeSettingsMenu();
            document.removeEventListener('click', closeSettingsMenuOnClickOutside);
          }
        }

        /**
         * ปิดเมนู
         */
        function closeSettingsMenu() {
          const menu = document.getElementById('settings-menu');
          const icon = document.getElementById('settings-icon');
          
          // แอนิเมชันเลื่อนขึ้นไป
          const buttons = menu.querySelectorAll('button');
          buttons.forEach((btn, index) => {
            setTimeout(() => {
              btn.style.transform = 'translateY(-20px)';
              btn.style.opacity = '0';
            }, (buttons.length - index - 1) * 50);
          });
          
          setTimeout(() => {
            menu.classList.add('hidden');
            icon.classList.remove('animate-spin');
          }, buttons.length * 50 + 100);
        }

        /**
         * ปุ่ม 1: ส่งออกแผนที่สิ่งปลูกสร้าง (GeoJSON)
         */
        async function exportBuildingGeoJSON() {
          closeSettingsMenu();
          
          // แสดงข้อความแจ้งเตือน
          showNotificationLeft('กำลังเตรียมข้อมูลสิ่งปลูกสร้าง...', 'info');
          
          try {
            // ดึงข้อมูลจากเซิร์ฟเวอร์
            const res = await fetch(`${CONFIG.SCRIPT_URL}?action=exportGeoJSON&type=building`);
            const geojsonData = await res.json();
            
            if (geojsonData.type === 'FeatureCollection') {
              // สร้าง Blob และดาวน์โหลดไฟล์
              const blob = new Blob([JSON.stringify(geojsonData, null, 2)], { 
                type: 'application/geo+json' 
              });
              
              const url = window.URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              a.download = `buildings_${new Date().toISOString().slice(0,10)}.geojson`;
              document.body.appendChild(a);
              a.click();
              window.URL.revokeObjectURL(url);
              document.body.removeChild(a);
              
              showNotificationLeft('ดาวน์โหลดไฟล์สิ่งปลูกสร้างสำเร็จ!', 'success');
            } else {
              throw new Error('ข้อมูลไม่ถูกต้อง');
            }
          } catch (err) {
            console.error('Error exporting buildings:', err);
            showNotificationLeft('เกิดข้อผิดพลาดในการส่งออกข้อมูล', 'error');
          }
        }

        /**
         * ปุ่ม 2: ส่งออกแผนที่ป้าย (GeoJSON)
         */
        async function exportSignGeoJSON() {
          closeSettingsMenu();
          
          showNotificationLeft('กำลังเตรียมข้อมูลป้าย...', 'info');
          
          try {
            const res = await fetch(`${CONFIG.SCRIPT_URL}?action=exportGeoJSON&type=sign`);
            const geojsonData = await res.json();
            
            if (geojsonData.type === 'FeatureCollection') {
              const blob = new Blob([JSON.stringify(geojsonData, null, 2)], { 
                type: 'application/geo+json' 
              });
              
              const url = window.URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              a.download = `signs_${new Date().toISOString().slice(0,10)}.geojson`;
              document.body.appendChild(a);
              a.click();
              window.URL.revokeObjectURL(url);
              document.body.removeChild(a);
              
              showNotificationLeft('ดาวน์โหลดไฟล์ป้ายสำเร็จ!', 'success');
            } else {
              throw new Error('ข้อมูลไม่ถูกต้อง');
            }
          } catch (err) {
            console.error('Error exporting signs:', err);
            showNotificationLeft('เกิดข้อผิดพลาดในการส่งออกข้อมูล', 'error');
          }
        }

        /**
         * ปุ่ม 3: โหลดรูปสิ่งปลูกสร้างจากโฟลเดอร์ Google Drive
         */
        async function loadBuildingImages() {
          closeSettingsMenu();
          
          showNotificationLeft('กำลังโหลดรูปภาพสิ่งปลูกสร้าง...', 'info');
          
          try {
            // ดึงข้อมูลสิ่งปลูกสร้างทั้งหมด
            const res = await fetch(`${CONFIG.SCRIPT_URL}?action=getData`);
            const data = await res.json();
            const buildings = data.buildings || [];
            
            // กรองเฉพาะที่มีรูปภาพ
            const buildingsWithImages = buildings.filter(b => b.image && b.image.trim() !== '');
            
            if (buildingsWithImages.length === 0) {
              showNotificationLeft('ไม่พบรูปภาพสิ่งปลูกสร้าง', 'warning');
              return;
            }
            
            // แสดงแกลเลอรี่รูปภาพ
            showImageGallery(buildingsWithImages, 'building');
            
          } catch (err) {
            console.error('Error loading building images:', err);
            showNotificationLeft('เกิดข้อผิดพลาดในการโหลดรูปภาพ', 'error');
          }
        }

        /**
         * ปุ่ม 4: โหลดรูปป้ายจากโฟลเดอร์ Google Drive
         */
        async function loadSignImages() {
          closeSettingsMenu();
          
          showNotificationLeft('กำลังโหลดรูปภาพป้าย...', 'info');
          
          try {
            const res = await fetch(`${CONFIG.SCRIPT_URL}?action=getData`);
            const data = await res.json();
            const signs = data.signs || [];
            
            const signsWithImages = signs.filter(s => s.picture && s.picture.trim() !== '');
            
            if (signsWithImages.length === 0) {
              showNotificationLeft('ไม่พบรูปภาพป้าย', 'warning');
              return;
            }
            
            showImageGallery(signsWithImages, 'sign');
            
          } catch (err) {
            console.error('Error loading sign images:', err);
            showNotificationLeft('เกิดข้อผิดพลาดในการโหลดรูปภาพ', 'error');
          }
        }

        /**
         * แสดงแกลเลอรี่รูปภาพ - เวอร์ชันแก้ไข
         */
        function showImageGallery(items, type) {
            // ✅ ข้อ 1: กรองเฉพาะรูปที่มีลิ้งค์
            const filteredItems = items.filter(item => {
                if (type === 'building') {
                    return item.image && item.image.trim() !== '';
                } else {
                    return item.picture && item.picture.trim() !== '';
                }
            });
            
            if (filteredItems.length === 0) {
                showNotificationLeft('ไม่พบรูปภาพที่มีลิ้งค์', 'warning');
                return;
            }
            
            // สร้างหน้าต่างแกลเลอรี่
            const galleryDiv = document.createElement('div');
            galleryDiv.id = 'image-gallery-modal';
            galleryDiv.className = 'fixed inset-0 bg-black/90 z-[3000] flex flex-col p-4 overflow-hidden';
            
            // ✅ ค่าเริ่มต้น: แสดงเป็นรายชื่อ
            let isGridView = false;
            
            galleryDiv.innerHTML = `
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-white text-xl font-bold">
                    ${type === 'building' ? 'รูปภาพสิ่งปลูกสร้าง' : 'รูปภาพป้าย'} (${filteredItems.length} รูป)
                </h3>
                <div class="flex gap-2">
                    <!-- ✅ ปุ่มสลับมุมมอง (ค่าเริ่มต้น: แสดงเป็นภาพ) -->
                    <button onclick="toggleGalleryView()" id="btn-toggle-view" class="bg-gray-700 text-white px-4 py-2 rounded-lg hover:bg-gray-600 transition flex items-center gap-2">
                        <i data-lucide="grid" id="view-icon" class="w-4 h-4"></i>
                        <span id="view-text">แสดงเป็นภาพ</span>
                    </button>
                    <!-- ✅ ปุ่มดาวน์โหลดทั้งหมด -->
                    <button onclick="downloadAllImagesAsZip()" class="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition flex items-center gap-2">
                        <i data-lucide="download" class="w-4 h-4"></i>
                        <span>ดาวน์โหลดทั้งหมด</span>
                    </button>
                    <button onclick="closeImageGallery()" class="text-white hover:text-gray-300 transition">
                        <i data-lucide="x" class="w-8 h-8"></i>
                    </button>
                </div>
            </div>
            <!-- ✅ คอนเทนเนอร์สำหรับสลับมุมมอง -->
            <div id="gallery-container" class="flex-1 overflow-y-auto">
                <!-- จะถูกแทนที่ด้วยฟังก์ชัน toggleGalleryView() -->
            </div>
            `;
            
            document.body.appendChild(galleryDiv);
            lucide.createIcons();
            
            // ✅ เริ่มต้นด้วยมุมมองรายชื่อ
            renderGalleryListView(filteredItems, type);
        }

        // ✅ ประกาศตัวแปรสำหรับเก็บสถานะมุมมองและข้อมูลปัจจุบัน
        let currentGalleryItems = [];
        let currentGalleryType = '';
        let isGridView = false; // ✅ ค่าเริ่มต้น: false = แสดงเป็นรายชื่อ

        /**
         * ✅ ฟังก์ชันสลับระหว่างมุมมองภาพตัวอย่างกับรายชื่อ
         */
        function toggleGalleryView() {
            isGridView = !isGridView;
            
            const btn = document.getElementById('btn-toggle-view');
            const icon = document.getElementById('view-icon');
            const text = document.getElementById('view-text');
            
            if (isGridView) {
                // สลับไปมุมมองภาพตัวอย่าง
                btn.className = 'bg-gray-700 text-white px-4 py-2 rounded-lg hover:bg-gray-600 transition flex items-center gap-2';
                icon.innerHTML = '<i data-lucide="list" class="w-4 h-4"></i>';
                text.textContent = 'แสดงเป็นรายชื่อ';
                renderGalleryGridView(currentGalleryItems, currentGalleryType);
            } else {
                // สลับไปมุมมองรายชื่อ
                btn.className = 'bg-gray-700 text-white px-4 py-2 rounded-lg hover:bg-gray-600 transition flex items-center gap-2';
                icon.innerHTML = '<i data-lucide="grid" class="w-4 h-4"></i>';
                text.textContent = 'แสดงเป็นภาพ';
                renderGalleryListView(currentGalleryItems, currentGalleryType);
            }
            
            lucide.createIcons();
        }

        /**
         * ✅ แสดงมุมมองภาพตัวอย่าง (Grid View)
         */
        function renderGalleryGridView(items, type) {
            currentGalleryItems = items;
            currentGalleryType = type;
            
            const container = document.getElementById('gallery-container');
            
            container.innerHTML = `
            <div id="gallery-grid" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3">
                ${items.map((item, index) => `
                <div class="relative group cursor-pointer" onclick="openImageViewer(${index}, '${type}')">
                    <img src="${type === 'building' ? item.image : item.picture}"
                        alt="รูปภาพ ${index + 1}"
                        class="w-full h-32 object-cover rounded-lg hover:opacity-75 transition"
                        onerror="this.src='https://via.placeholder.com/150?text=No+Image'">
                    <div class="absolute inset-0 bg-black/50 opacity-0 group-hover:opacity-100 transition-opacity rounded-lg flex items-center justify-center">
                        <span class="text-white text-sm font-bold">ดูรูปใหญ่</span>
                    </div>
                    <div class="mt-1 text-xs text-white truncate">
                        ${type === 'building' ? (item.building_c || item.full_name || '-') : (item.s_code || item.s_name || '-')}
                    </div>
                </div>
                `).join('')}
            </div>
            `;
            
            lucide.createIcons();
        }

        /**
         * ✅ แสดงมุมมองรายชื่อ (List View)
         */
        function renderGalleryListView(items, type) {
            currentGalleryItems = items;
            currentGalleryType = type;
            
            const container = document.getElementById('gallery-container');
            
            container.innerHTML = `
            <div class="bg-gray-800 rounded-lg overflow-hidden">
                <div class="grid grid-cols-[40px_1fr_120px_80px] gap-2 p-3 bg-gray-700 text-white font-bold text-sm">
                    <span>#</span>
                    <span>ชื่อ</span>
                    <span>ขนาด</span>
                    <span>ดาวน์โหลด</span>
                </div>
                <div class="max-h-[calc(100vh-150px)] overflow-y-auto">
                    ${items.map((item, index) => `
                    <div class="grid grid-cols-[40px_1fr_120px_80px] gap-2 p-3 border-b border-gray-700 hover:bg-gray-700/50 transition cursor-pointer" onclick="openImageViewer(${index}, '${type}')">
                        <span class="text-gray-400 text-sm">${index + 1}</span>
                        <div class="flex items-center gap-2">
                            <i data-lucide="image" class="w-4 h-4 text-blue-400"></i>
                            <span class="text-white truncate">
                                ${type === 'building' ? (item.building_c || item.full_name || '-') : (item.s_code || item.s_name || '-')}
                            </span>
                        </div>
                        <span class="text-gray-400 text-xs">-</span>
                        <button onclick="event.stopPropagation(); downloadSingleImage('${type === 'building' ? item.image : item.picture}', '${type === 'building' ? (item.building_c || 'building') : (item.s_code || 'sign')}')" 
                            class="bg-blue-600 text-white px-2 py-1 rounded hover:bg-blue-700 transition text-xs flex items-center justify-center gap-1">
                            <i data-lucide="download" class="w-3 h-3"></i>
                        </button>
                    </div>
                    `).join('')}
                </div>
            </div>
            `;
            
            lucide.createIcons();
        }

        /**
         * ✅ ดาวน์โหลดรูปภาพเดียว
         */
        function downloadSingleImage(url, filename) {
            const link = document.createElement('a');
            link.href = url;
            link.download = `${filename}_${Date.now()}.jpg`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            showNotificationLeft(`ดาวน์โหลด ${filename} สำเร็จ!`, 'success');
        }

        // ============================================
        // ดาวน์โหลดรูปทั้งหมดเป็นไฟล์เดียว (ใช้ JSZip) - เวอร์ชันแก้ไขแล้ว
        // ============================================
        async function downloadAllImagesAsZip() {
            showNotificationLeft('กำลังเตรียมดาวน์โหลด...', 'info');
            
            try {
                const galleryGrid = document.getElementById('gallery-grid');
                if (!galleryGrid) {
                    showNotificationLeft('❌ ไม่พบข้อมูลรูปภาพ', 'error');
                    return;
                }
                
                const items = [];
                const type = document.querySelector('#image-gallery-modal h3')?.innerText.includes('สิ่งปลูกสร้าง') ? 'building' : 'sign';
                
                galleryGrid.querySelectorAll('.relative.group').forEach((el, index) => {
                    const img = el.querySelector('img');
                    const url = img?.src;
                    const codeEl = el.querySelector('p.font-bold');
                    const codeText = codeEl?.innerText || '';
                    const code = codeText.replace(/[^0-9]/g, '');
                    
                    // ✅ แก้ไข: ลบช่องว่างพิเศษในสตริงตรวจสอบ
                    if (url && url !== 'https://via.placeholder.com/150?text=No+Image') {
                        items.push({
                            url: url,
                            filename: `${type === 'building' ? 'B' : 'S'}${code || index + 1}.jpg`
                        });
                    }
                });
                
                if (items.length === 0) {
                    showNotificationLeft('⚠️ ไม่พบรูปภาพให้ดาวน์โหลด', 'warning');
                    return;
                }
                
                showNotificationLeft(`กำลังดาวน์โหลด ${items.length} รูป...`, 'info');
                
                // ✅ แก้ไข: ลบช่องว่างพิเศษใน URL JSZip
                if (typeof JSZip === 'undefined') {
                    await new Promise((resolve, reject) => {
                        const script = document.createElement('script');
                        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js'; // ✅ ลบช่องว่าง
                        script.onload = resolve;
                        script.onerror = () => reject(new Error('Failed to load JSZip'));
                        document.head.appendChild(script);
                    });
                }
                
                const zip = new JSZip();
                const folder = zip.folder(type === 'building' ? 'buildings' : 'signs');
                let successCount = 0;
                
                for (let i = 0; i < items.length; i++) {
                    const item = items[i];
                    try {
                        const response = await fetch(item.url);
                        if (!response.ok) throw new Error(`HTTP ${response.status}`);
                        
                        const blob = await response.blob();
                        folder.file(item.filename, blob);
                        successCount++;
                        
                        if ((i + 1) % 5 === 0 || i === items.length - 1) {
                            showNotificationLeft(`กำลังดาวน์โหลด (${successCount}/${items.length})...`, 'info');
                        }
                    } catch (err) {
                        console.error(`ดาวน์โหลด ${item.filename} ล้มเหลว:`, err);
                    }
                }
                
                if (successCount === 0) {
                    showNotificationLeft('❌ ดาวน์โหลดรูปภาพล้มเหลวทั้งหมด', 'error');
                    return;
                }
                
                const content = await zip.generateAsync({ type: 'blob' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(content);
                link.download = `${type === 'building' ? 'buildings' : 'signs'}_${new Date().toISOString().slice(0, 10)}.zip`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href);
                
                showNotificationLeft(`✅ ดาวน์โหลดรูปภาพทั้งหมด (${successCount} รูป) เสร็จสิ้น!`, 'success');
            } catch (err) {
                console.error('ข้อผิดพลาด:', err);
                showNotificationLeft('❌ ดาวน์โหลดล้มเหลว: ' + err.message, 'error');
            }
        }

        /**
         * เปิดดูรูปภาพขนาดใหญ่ - เวอร์ชันแก้ไข
         */
        function openImageViewer(index, type) {
            const items = currentGalleryItems;
            const item = items[index];
            
            if (!item) return;
            
            // สร้างหน้าต่างดูรูปใหญ่
            const viewerDiv = document.createElement('div');
            viewerDiv.id = 'image-viewer-modal';
            viewerDiv.className = 'fixed inset-0 bg-black/95 z-[3001] flex items-center justify-center p-4';
            viewerDiv.onclick = (e) => {
                if (e.target === viewerDiv) closeImageViewer();
            };
            
            // ✅ ใช้ลิ้งค์ที่ถูกต้องตามประเภท
            const imageUrl = type === 'building' ? item.image : item.picture;
            const code = type === 'building' ? item.building_c : item.s_code;
            const name = type === 'building' ? item.full_name : item.s_name;
            const address = type === 'building' ? item.address : item.comment;
            
            viewerDiv.innerHTML = `
            <div class="relative max-w-4xl w-full">
                <img src="${imageUrl}"
                    alt="รูปภาพ"
                    class="w-full max-h-[80vh] object-contain rounded-lg"
                    onerror="this.src='https://via.placeholder.com/800x600?text=No+Image'">
                <div class="absolute bottom-4 left-4 right-4 bg-black/70 text-white p-3 rounded-lg">
                    <p class="font-bold">${type === 'building' ? 'สิ่งปลูกสร้าง:' : 'ป้าย:'} ${code || '-'}</p>
                    <p class="text-sm">${name || ''}</p>
                    <p class="text-xs mt-1">${address || ''}</p>
                </div>
                <button onclick="closeImageViewer()" class="absolute top-4 right-4 text-white hover:text-gray-300 transition">
                    <i data-lucide="x" class="w-8 h-8"></i>
                </button>
                <button onclick="downloadSingleImage('${imageUrl}', '${code || 'image'}')"
                    class="absolute top-4 left-4 bg-blue-600 text-white p-2 rounded-lg hover:bg-blue-700 transition">
                    <i data-lucide="download" class="w-5 h-5"></i>
                </button>
            </div>
            `;
            
            document.body.appendChild(viewerDiv);
            lucide.createIcons();
        }

        /**
         * ปิดหน้าต่างดูรูปใหญ่
         */
        function closeImageViewer() {
          const viewer = document.getElementById('image-viewer-modal');
          if (viewer) viewer.remove();
        }

        /**
         * ปิดแกลเลอรี่รูปภาพ
         */
        function closeImageGallery() {
          const gallery = document.getElementById('image-gallery-modal');
          if (gallery) gallery.remove();
          closeImageViewer(); // ปิดหน้าต่างดูรูปใหญ่ด้วย (ถ้ามี)
        }

        /**
         * ดาวน์โหลดรูปภาพ
         */
        function downloadImage(url, filename) {
          const link = document.createElement('a');
          link.href = url;
          link.download = `${filename}_${Date.now()}.jpg`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        }

        /**
         * แสดงแจ้งเตือน
         */
        function showNotificationLeft(message, type = 'info') {
          const colors = {
            info: 'bg-blue-500',
            success: 'bg-green-500',
            error: 'bg-red-500',
            warning: 'bg-yellow-500'
          };
          
          const icons = {
            info: 'info',
            success: 'check-circle',
            error: 'alert-circle',
            warning: 'alert-triangle'
          };
          
          const notification = document.createElement('div');
          notification.className = `fixed top-4 left-4 ${colors[type]} text-white px-6 py-3 rounded-lg shadow-lg z-[2000] animate-fade-in`;
          notification.innerHTML = `
            <i data-lucide="${icons[type]}" class="w-5 h-5 inline mr-2"></i>
            ${message}
          `;
          
          document.body.appendChild(notification);
          lucide.createIcons();
          
          setTimeout(() => {
            notification.classList.add('animate-fade-out');
            setTimeout(() => notification.remove(), 300);
          }, 500);
        }
        /**
         * แสดงมาร์กเกอร์ทั้งหมด (สำหรับข้อมูลน้อย)
         */
        function renderAllMarkers() {
          allBuildings.forEach(r => {
            if (!r.lat_long) return;
            const coords = r.lat_long.split(',').map(Number);
            if (coords.length < 2 || isNaN(coords[0]) || isNaN(coords[1])) return;
            const m = createCircleMarker(L.latLng(coords[0], coords[1]), 'building', isEditMode);
            setupMarkerPopup(m, r, 'building');
            m.addTo(surveyLayers);
          });
          
          allSigns.forEach(r => {
            if (!r.lat_long) return;
            const coords = r.lat_long.split(',').map(Number);
            if (coords.length < 2 || isNaN(coords[0]) || isNaN(coords[1])) return;
            const m = createCircleMarker(L.latLng(coords[0], coords[1]), 'sign', isEditMode);
            setupMarkerPopup(m, r, 'sign');
            m.addTo(surveyLayers);
          });
        }

        async function saveLargeFileInChunks(file, fileName) {
            const CHUNK_SIZE = 10 * 1024 * 1024; // 10MB ต่อชิ้น
            const db = await openDatabase();
            const transaction = db.transaction('mapFiles', 'readwrite');
            const store = transaction.objectStore('mapFiles');
            
            for (let start = 0; start < file.size; start += CHUNK_SIZE) {
                const chunk = file.slice(start, start + CHUNK_SIZE);
                const chunkData = await chunk.arrayBuffer();
                
                await store.add({
                    id: `${fileName}_chunk_${start}`,
                    fileName: fileName,
                    chunkIndex: start / CHUNK_SIZE,
                    totalChunks: Math.ceil(file.size / CHUNK_SIZE),
                     chunkData,
                    timestamp: new Date().toISOString()
                });
            }
            
            console.log(`✅ บันทึกไฟล์ ${fileName} สำเร็จ (${file.size} bytes)`);
        }

        async function compressAndSaveMap(file) {
            // ใช้ไลบรารีบีบอัด เช่น pako หรือ zlib
            const compressed = await compressFile(file);
            await saveToIndexedDB(compressed);
        }

        // บันทึกเฉพาะชั้นข้อมูลที่จำเป็น
        const layersToCache = ['parcel', 'boundary']; // ไม่รวม 'building' ถ้าใหญ่เกินไป

        async function downloadMapStreaming(fileId) {
            const response = await fetch(`https://drive.google.com/uc?export=download&id=${fileId}`);
            const reader = response.body.getReader();
            const chunks = [];
            
            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                chunks.push(value);
                
                // บันทึกเป็นระยะเพื่อไม่ให้หน่วยความจำเต็ม
                if (chunks.length > 10) {
                    await saveChunksToDB(chunks);
                    chunks.length = 0;
                }
            }
            
            await saveChunksToDB(chunks);
        }

        async function checkMapFileSize(fileId) {
            const response = await fetch(`https://drive.google.com/uc?export=download&id=${fileId}`, {
                method: 'HEAD'
            });
            
            const size = response.headers.get('content-length');
            const mb = (size / 1024 / 1024).toFixed(2);
            
            console.log(`ขนาดไฟล์แผนที่: ${mb} MB`);
            
            if (size > 50 * 1024 * 1024) {
                alert(`⚠️ ไฟล์แผนที่ใหญ่เกินไป (${mb} MB)\nแนะนำให้แบ่งชั้นข้อมูลหรือบีบอัดไฟล์`);
            }
            
            return size;
        }

        // ============================================
        // อัปเดตมาร์กเกอร์เฉพาะในมุมมอง (GPU Optimized)
        // ============================================
        function updateVisibleMarkers() {
            // ✅ ใช้ requestAnimationFrame สำหรับการเรนเดอร์แบบประสิทธิภาพสูง
            requestAnimationFrame(() => {
                const bounds = map.getBounds();
                const zoom = map.getZoom();
                const bufferRatio = isMobile() ? 1.3 : 1.5; // ลดบัฟเฟอร์สำหรับมือถือ
                const bufferedBounds = bounds.pad(bufferRatio);
                
                // ✅ ล้างมาร์กเกอร์ทั้งหมดในครั้งเดียว (แทนทีละตัว)
                surveyLayers.clearLayers();
                
                // ✅ สร้างมาร์กเกอร์แบบแบตช์
                const markersToRender = [];
                
                // จุดสิ่งปลูกสร้าง
                allBuildings.forEach(r => {
                    if (!r.lat_long) return;
                    const coords = r.lat_long.split(',').map(Number);
                    if (coords.length < 2 || isNaN(coords[0]) || isNaN(coords[1])) return;
                    
                    const latLng = L.latLng(coords[0], coords[1]);
                    if (!bufferedBounds.contains(latLng)) return;
                    
                    // ✅ ข้ามจุดที่กำลังถูกย้าย
                    const recordKey = r._row_num || r.id;
                    if (markersBeingMoved.has(recordKey)) return;
                    
                    markersToRender.push({ latLng, data: r, type: 'building' });
                });
                
                // จุดป้าย
                allSigns.forEach(r => {
                    if (!r.lat_long) return;
                    const coords = r.lat_long.split(',').map(Number);
                    if (coords.length < 2 || isNaN(coords[0]) || isNaN(coords[1])) return;
                    
                    const latLng = L.latLng(coords[0], coords[1]);
                    if (!bufferedBounds.contains(latLng)) return;
                    
                    const recordKey = r._row_num || r.id;
                    if (markersBeingMoved.has(recordKey)) return;
                    
                    markersToRender.push({ latLng, data: r, type: 'sign' });
                });
                
                // ✅ เรนเดอร์ทั้งหมดในครั้งเดียว
                markersToRender.forEach(item => {
                    const m = createCircleMarker(item.latLng, item.type, isEditMode);
                    m._popupData = item.data;
                    m.addTo(surveyLayers);
                });
                
                console.log(`✅ เรนเดอร์มาร์กเกอร์ ${markersToRender.length} จุดด้วย GPU (Canvas)`);
            });
        }

        // ฟังก์ชันสร้างแถวข้อมูลป้าย
        function renderSignTable() {
            const tbody = document.getElementById('sign-table-body');
            if (!allSigns || allSigns.length === 0) {
                tbody.innerHTML = '<tr><td colspan="9" class="text-center py-8 text-gray-500">ไม่มีข้อมูลป้าย</td></tr>';
                return;
            }
            // ในฟังก์ชัน renderSignTable() แก้ไขส่วนสร้างแถว:
            const sortedSigns = sortSigns(allSigns, signSortColumn, signSortDirection);

            tbody.innerHTML = sortedSigns.map(sign => {
                if (!sign.lat_long) return '';
                const [lat, lng] = sign.lat_long.split(',').map(Number);
                if (isNaN(lat) || isNaN(lng)) return '';
                
                // ✅ แสดงสถานะตรวจสอบให้ตรงกับข้อมูลจริง
                const statusClass = sign.check === 'ถ่ายรูปแล้ว' ? 'status-ถ่ายรูปแล้ว' :
                                   sign.check === 'ตรวจสอบแล้ว' ? 'status-ตรวจสอบแล้ว' : 'status-ยังไม่สำรวจ';
                const statusText = sign.check || 'ยังไม่สำรวจ';
                
                return `
                <tr>
                    <td><span class="marker-icon marker-sign"></span></td>
                    <td class="font-medium">${sign.s_code || '-'}</td>      <!-- 1. รหัส -->
                    <td class="text-center">${sign.s_characte || '-'}</td>       <!-- ✅ แก้ไข: บังคับกึ่งกลางด้วย inline style -->
                    <td class="text-center">${sign.s_wide || '-'}</td>        <!-- ✅ เพิ่ม -->
                    <td class="text-center">${sign.s_length || '-'}</td>      <!-- ✅ เพิ่ม -->
                    <td class="text-center">${sign.no_side || '-'}</td>       <!-- ✅ เพิ่ม -->
                    <td>${sign.s_text || '-'}</td>                          <!-- 6. ข้อความ -->
                    <td class="text-center"><span class="status-badge ${statusClass}">${statusText}</span></td> <!-- ✅ เพิ่ม -->
                    <td>
                        <button class="zoom-btn" onclick="zoomToLocation(L.latLng(${lat}, ${lng}))">
                            <i data-lucide="locate" class="w-3 h-3 inline"></i>
                        </button>
                    </td>
                </tr>
                `;
            }).join('');
            lucide.createIcons();
        }

        // ============================================
        // สถานะการเรียงลำดับ (เริ่มต้นเรียงตามรหัส)
        // ============================================
        let buildingSortColumn = 'building_c';
        let buildingSortDirection = 'asc'; // 'asc' หรือ 'desc'
        let signSortColumn = 's_code';
        let signSortDirection = 'asc';

        // คอลั่มน์ที่เป็นตัวเลข (สำหรับการเรียงแบบตัวเลข)
        const buildingNumericColumns = ['b_area', 'b_year', 'hs_no', 'hs_moo', 'no_floor', 'buse_area', 'buse_area2'];
        const signNumericColumns = ['s_wide', 's_length', 'no_side'];

        // ============================================
        // ฟังก์ชันอัปเดตสัญลักษณ์เรียงลำดับในหัวตาราง
        // ============================================
        function updateSortIndicators(tableId, sortColumn, sortDirection) {
            // ลบสัญลักษณ์เก่าทั้งหมด
            document.querySelectorAll(`#${tableId} .sort-indicator`).forEach(el => el.remove());
            
            // เพิ่มสัญลักษณ์ใหม่ในคอลั่มน์ที่เรียง
            const header = document.querySelector(`#${tableId} th.sortable-header[data-sort="${sortColumn}"]`);
            if (header) {
                const indicator = document.createElement('span');
                indicator.className = 'sort-indicator ml-1 text-blue-600 font-bold';
                indicator.innerHTML = sortDirection === 'asc' ? '↑' : '↓';
                header.appendChild(indicator);
            }
        }

        // ============================================
        // ฟังก์ชันเรียงข้อมูลสิ่งปลูกสร้าง
        // ============================================
        function sortBuildings(data, column, direction) {
            return [...data].sort((a, b) => {
                let valA = a[column] || '';
                let valB = b[column] || '';
                
                // จัดการค่าตัวเลข
                if (buildingNumericColumns.includes(column)) {
                    valA = parseFloat(valA) || 0;
                    valB = parseFloat(valB) || 0;
                    return direction === 'asc' ? valA - valB : valB - valA;
                }
                
                // จัดการข้อความ (รองรับภาษาไทย)
                if (typeof valA === 'string' && typeof valB === 'string') {
                    const result = valA.localeCompare(valB, 'th', { numeric: true, sensitivity: 'base' });
                    return direction === 'asc' ? result : -result;
                }
                
                // Fallback
                return direction === 'asc' ? (valA > valB ? 1 : -1) : (valA < valB ? 1 : -1);
            });
        }

        // ============================================
        // ฟังก์ชันเรียงข้อมูลป้าย
        // ============================================
        function sortSigns(data, column, direction) {
            return [...data].sort((a, b) => {
                let valA = a[column] || '';
                let valB = b[column] || '';
                
                // จัดการค่าตัวเลข
                if (signNumericColumns.includes(column)) {
                    valA = parseFloat(valA) || 0;
                    valB = parseFloat(valB) || 0;
                    return direction === 'asc' ? valA - valB : valB - valA;
                }
                
                // จัดการข้อความ (รองรับภาษาไทย)
                if (typeof valA === 'string' && typeof valB === 'string') {
                    const result = valA.localeCompare(valB, 'th', { numeric: true, sensitivity: 'base' });
                    return direction === 'asc' ? result : -result;
                }
                
                // Fallback
                return direction === 'asc' ? (valA > valB ? 1 : -1) : (valA < valB ? 1 : -1);
            });
        }

        // ============================================
        // ผูกเหตุการณ์คลิกหัวตารางเมื่อโหลดหน้าเว็บ
        // ============================================
        document.addEventListener('DOMContentLoaded', () => {
            // ผูกเหตุการณ์กับหัวตารางสิ่งปลูกสร้าง
            document.querySelectorAll('#building-table .sortable-header').forEach(header => {
                header.style.cursor = 'pointer';
                header.style.userSelect = 'none';
                header.addEventListener('click', () => {
                    const column = header.dataset.sort;
                    if (buildingSortColumn === column) {
                        buildingSortDirection = buildingSortDirection === 'asc' ? 'desc' : 'asc';
                    } else {
                        buildingSortColumn = column;
                        buildingSortDirection = 'asc';
                    }
                    updateSortIndicators('building-table', buildingSortColumn, buildingSortDirection);
                    renderBuildingTable(); // เรนเดอร์ใหม่ด้วยการเรียงลำดับใหม่
                });
            });
            
            // ผูกเหตุการณ์กับหัวตารางป้าย
            document.querySelectorAll('#sign-table .sortable-header').forEach(header => {
                header.style.cursor = 'pointer';
                header.style.userSelect = 'none';
                header.addEventListener('click', () => {
                    const column = header.dataset.sort;
                    if (signSortColumn === column) {
                        signSortDirection = signSortDirection === 'asc' ? 'desc' : 'asc';
                    } else {
                        signSortColumn = column;
                        signSortDirection = 'asc';
                    }
                    updateSortIndicators('sign-table', signSortColumn, signSortDirection);
                    renderSignTable(); // เรนเดอร์ใหม่ด้วยการเรียงลำดับใหม่
                });
            });
            
            // ตั้งค่าเริ่มต้น
            updateSortIndicators('building-table', buildingSortColumn, buildingSortDirection);
            updateSortIndicators('sign-table', signSortColumn, signSortDirection);
        });

        async function loadExistingData() {
            try {
                const res = await fetch(`${CONFIG.SCRIPT_URL}?action=getData`);
                const data = await res.json();
                
                // ✅ วางโค้ดตรงนี้ - แปลงค่าชั้นที่ใช้จากวันที่เป็นรูปแบบ "1-1", "1-2"
                if (data.buildings && Array.isArray(data.buildings)) {
                    data.buildings.forEach(b => {
                        b.buse_floor = normalizeFloorValue(b.buse_floor);
                        b.buse_floor2 = normalizeFloorValue(b.buse_floor2); // ใช้ชื่อถูกต้อง
                    });
                }

                // ✅ เก็บเฉพาะจุดชั่วคราวที่ไม่ใช่จุดที่กำลังถูกย้าย
                const tempMarkers = [];
                surveyLayers.eachLayer(layer => {
                    if (layer._popupData && layer._popupData.tempMarker && !layer._popupData.beingMoved) {
                        tempMarkers.push({
                            latlng: layer.getLatLng(),
                            data: layer._popupData,
                            type: layer._popupData.type
                        });
                    }
                });
                
                surveyLayers.clearLayers();
                
                // โหลดข้อมูลจริงจากเซิร์ฟเวอร์
                allBuildings = data.buildings || [];
                allSigns = data.signs || [];
                
                // แสดงข้อมูลในตาราง
                renderBuildingTable();
                renderSignTable();
                
                const totalMarkers = allBuildings.length + allSigns.length;
                const useOptimizedRendering = totalMarkers > 200;
                
                if (useOptimizedRendering) {
                    map.off('moveend', updateVisibleMarkers);
                    map.off('zoomend', updateVisibleMarkers);
                    map.on('moveend', updateVisibleMarkers);
                    map.on('zoomend', updateVisibleMarkers);
                    updateVisibleMarkers();
                } else {
                    // ✅ สร้างจุดจริงทั้งหมด (ไม่เรียก enableMarkerDragging)
                    allBuildings.forEach(r => {
                        if (!r.lat_long) return;
                        const coords = r.lat_long.split(',').map(Number);
                        if (coords.length < 2 || isNaN(coords[0]) || isNaN(coords[1])) return;
                        
                        // ✅ ข้ามจุดที่กำลังถูกย้าย
                        const recordKey = r._row_num || r.id;
                        if (markersBeingMoved.has(String(recordKey))) {
                            return;
                        }
                        
                        const m = createCircleMarker(L.latLng(coords[0], coords[1]), 'building', isEditMode);
                        m._popupData = r;
                        setupMarkerPopup(m, r, 'building');
                        m.addTo(surveyLayers);
                        // ❌ ลบบรรทัดนี้ออก: if (isEditMode) enableMarkerDragging(m, r);
                    });
                    
                    allSigns.forEach(r => {
                        if (!r.lat_long) return;
                        const coords = r.lat_long.split(',').map(Number);
                        if (coords.length < 2 || isNaN(coords[0]) || isNaN(coords[1])) return;
                        
                        // ✅ ข้ามจุดที่กำลังถูกย้าย
                        const recordKey = r._row_num || r.id;
                        if (markersBeingMoved.has(String(recordKey))) {
                            return;
                        }
                        
                        const m = createCircleMarker(L.latLng(coords[0], coords[1]), 'sign', isEditMode);
                        m._popupData = r;
                        setupMarkerPopup(m, r, 'sign');
                        m.addTo(surveyLayers);
                        // ❌ ลบบรรทัดนี้ออก: if (isEditMode) enableMarkerDragging(m, r);
                    });
                }
                
                // ✅ เพิ่มจุดชั่วคราวกลับเข้ามา (ไม่เรียก enableMarkerDragging)
                tempMarkers.forEach(marker => {
                    const m = createCircleMarker(marker.latlng, marker.type, isEditMode);
                    m._popupData = marker.data;
                    setupMarkerPopup(m, marker.data, marker.type);
                    m.addTo(surveyLayers);
                    // ❌ ลบบรรทัดนี้ออก: if (isEditMode) enableMarkerDragging(m, marker.data);
                });
            } catch (e) {
                console.error("Error loading data:", e);
            }
            // ✅ อัปเดตจำนวนที่หัวตารางหลังโหลดข้อมูล
            updateTableCounters();
        }

        // ============================================
        // Offline Data Storage System
        // ============================================

        // ตรวจจับสถานะออนไลน์
        let isOnline = navigator.onLine;
        let syncQueue = [];

        // แสดงสถานะการเชื่อมต่อ
        function updateConnectionStatus() {
            const statusDiv = document.getElementById('connection-status');
            if (!statusDiv) {
                const div = document.createElement('div');
                div.id = 'connection-status';
                div.className = 'fixed top-4 left-4 px-4 py-2 rounded-lg text-white font-bold shadow-lg z-[2000]';
                document.body.appendChild(div);
            }
            
            const status = document.getElementById('connection-status');
            if (isOnline) {
                status.textContent = '✓ เชื่อมต่ออินเทอร์เน็ต';
                status.className = 'fixed top-4 left-4 px-4 py-2 rounded-lg text-white font-bold shadow-lg z-[2000] bg-green-500';
            } else {
                status.textContent = '⚠️ โหมดออฟไลน์ - ข้อมูลจะถูกเก็บไว้ในมือถือ';
                status.className = 'fixed top-4 left-4 px-4 py-2 rounded-lg text-white font-bold shadow-lg z-[2000] bg-yellow-500';
            }
            
            // ซ่อนอัตโนมัติหลัง 3 วินาที
            setTimeout(() => {
                status.style.opacity = '0';
                setTimeout(() => status.remove(), 300);
            }, 1000);
        }

        // ฟังก์ชันตรวจสอบการเชื่อมต่อ
        window.addEventListener('online', () => {
            isOnline = true;
            updateConnectionStatus();
            // เมื่อกลับมาออนไลน์ ให้พยายามส่งข้อมูลที่ค้างอยู่
            setTimeout(processSyncQueue, 1000);
        });

        window.addEventListener('offline', () => {
            isOnline = false;
            updateConnectionStatus();
        });

        // ฟังก์ชันเก็บข้อมูลในคิว
        function addToSyncQueue(action, type, data, rowKey = null) {
            const queueItem = {
                id: Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                timestamp: new Date().toISOString(),
                action: action, // 'add', 'update', 'delete', 'updatePosition'
                type: type,     // 'building', 'sign'
                data: data,
                rowKey: rowKey,
                status: 'ยังไม่สำรวจ', // ยังไม่สำรวจ, success, failed
                retryCount: 0
            };
            
            syncQueue.push(queueItem);
            saveSyncQueueToStorage();
            
            // แสดงแจ้งเตือน
            showNotificationLeft(`บันทึกข้อมูลไว้ในมือถือ (${syncQueue.length} รายการรอซิงค์)`, 'warning');
            
            return queueItem.id;
        }

        // บันทึกคิวลงใน LocalStorage
        function saveSyncQueueToStorage() {
            localStorage.setItem('syncQueue', JSON.stringify(syncQueue));
        }

        // โหลดคิวจาก LocalStorage
        function loadSyncQueueFromStorage() {
            const saved = localStorage.getItem('syncQueue');
            if (saved) {
                syncQueue = JSON.parse(saved);
            }
        }

        // ลบรายการที่สำเร็จแล้ว
        function removeFromSyncQueue(id) {
            syncQueue = syncQueue.filter(item => item.id !== id);
            saveSyncQueueToStorage();
        }

        // ============================================
        // ฟังก์ชันส่งข้อมูลแบบมีการลองใหม่ (Retry Mechanism)
        // ============================================

        async function sendDataWithRetry(action, type, data, rowKey = null, maxRetries = 5) {
            // ถ้าออฟไลน์ → เก็บไว้ในคิวทันที
            if (!isOnline || !navigator.onLine) {
                return addToSyncQueue(action, type, data, rowKey);
            }
            
            let retryCount = 0;
            
            while (retryCount < maxRetries) {
                try {
                    const body = new URLSearchParams();
                    body.append('action', action);
                    body.append('type', type);
                    
                    if (rowKey) {
                        body.append('rowKey', rowKey);
                    }
                    
                    if (data) {
                        // ✅ แยกข้อมูลรูปภาพออก
                        const { image, fileName, ...textData } = data;
                        
                        // ส่งข้อมูลข้อความ
                        if (Object.keys(textData).length > 0) {
                            body.append('payload', JSON.stringify(textData));
                        }
                        
                        // ✅ ส่งรูปภาพไปยังเซิร์ฟเวอร์ทันที
                        if (image && fileName) {
                            body.append('image', image);
                            body.append('fileName', fileName);
                            console.log(`ส่งรูปภาพไปยังเซิร์ฟเวอร์: ${fileName}`);
                        }
                    }
                    
                    const res = await fetch(CONFIG.SCRIPT_URL.trim(), {
                        method: 'POST',
                        body,
                        timeout: action === 'updateImage' || (data && data.image) ? 60000 : 30000
                    });
                    
                    if (res.ok) {
                        // ✅ แก้ไขตรงนี้: เพิ่มชื่อคีย์ 'data'
                        return { success: true, data: await res.json() };
                    } else {
                        throw new Error(`HTTP ${res.status}`);
                    }
                } catch (err) {
                    retryCount++;
                    
                    if (retryCount >= maxRetries) {
                        // ✅ หากล้มเหลวทุกครั้ง ให้บันทึกลงคิว
                        const queueId = addToSyncQueue(action, type, data, rowKey);
                        console.error(`Failed after ${maxRetries} retries. Saved to queue: ${queueId}`);
                        return { success: false, queued: true, queueId: queueId };
                    }
                    
                    const waitTime = 1000 * Math.pow(2, retryCount);
                    console.log(`Retry ${retryCount}/${maxRetries} after ${waitTime}ms...`);
                    
                    // รอเวลาที่กำหนด
                    await new Promise(resolve => setTimeout(resolve, waitTime));
                }
            }
        }

        // ============================================
        // ตั้งค่าไฟล์แผนที่จากกูเกิ้ลไดร์ฟ
        // ============================================
        const MAP_CONFIG = {
            googleDriveFileId: 'YOUR_FILE_ID_HERE', // ✅ แทนที่ด้วยไฟล์ไอดีของคุณ
            fileName: 'ltaxmap_nt.gpkg',
            layers: ['parcel', 'boundary', 'building'],
            localCacheKey: 'ltaxmap_cache',
            lastModifiedKey: 'ltaxmap_last_modified',
            lastCheckKey: 'ltaxmap_last_check', // ✅ เพิ่มสำหรับตรวจสอบเวลา
            checkTime: 8 // ✅ เวลาตรวจสอบ: 08:00 น.
        };

        // ============================================
        // ตรวจสอบและโหลดแผนที่แบบออฟไลน์
        // ============================================
        async function checkAndLoadMap() {
            console.log('🔍 ตรวจสอบแผนที่...');
            
            // ✅ ตรวจสอบว่ามีไฟล์แผนที่ในแคชหรือไม่
            const cachedData = await getCachedMapData();
            
            if (cachedData) {
                console.log('✅ พบแผนที่ในแคช - โหลดจากแคช');
                loadMapFromCache(cachedData);
                
                // ✅ ตรวจสอบการอัปเดตแบบเบื้องหลัง (ทุกวัน 08:00 น.)
                setTimeout(() => checkForMapUpdate(), 1000);
            } else {
                console.log('⚠️ ไม่พบแผนที่ในแคช - ดาวน์โหลดใหม่');
                await downloadAndCacheMap();
            }
        }

        async function downloadAndCacheMap() {
            try {
                showNotificationLeft('กำลังดาวน์โหลดแผนที่...', 'info');
                
                const progressIndicator = document.createElement('div');
                progressIndicator.id = 'map-download-progress';
                progressIndicator.className = 'fixed top-4 right-4 bg-blue-500 text-white px-4 py-2 rounded-lg shadow-lg z-[2001]';
                progressIndicator.innerHTML = 'ดาวน์โหลดแผนที่: 0%';
                document.body.appendChild(progressIndicator);
                
                const fileUrl = `https://drive.google.com/uc?export=download&id=${MAP_CONFIG.googleDriveFileId}`;
                const response = await fetch(fileUrl);
                
                if (!response.ok) {
                    throw new Error('ดาวน์โหลดแผนที่ล้มเหลว');
                }
                
                // ✅ ดึงเวลาแก้ไขจริงจากหัวข้อ Last-Modified (สำคัญ!)
                const lastModifiedHeader = response.headers.get('last-modified');
                const lastModified = lastModifiedHeader 
                    ? new Date(lastModifiedHeader).toISOString() 
                    : new Date().toISOString(); // ใช้เวลาปัจจุบันหากไม่มี
                
                // ... (โค้ดดาวน์โหลดเหมือนเดิม) ...
                
                // ✅ บันทึกในแคช (ใช้เวลาแก้ไขจริงจากไดร์ฟ!)
                await cacheMapData(arrayBuffer, lastModified);
                
                progressIndicator.remove();
                
                console.log(`✅ ดาวน์โหลดและบันทึกแผนที่เรียบร้อย (แก้ไขล่าสุด: ${new Date(lastModified).toLocaleString('th-TH')})`);
                showNotificationLeft('ดาวน์โหลดแผนที่สำเร็จ!', 'success');
                
                loadMapFromCache(arrayBuffer);
                
            } catch (err) {
                console.error('❌ ข้อผิดพลาดในการดาวน์โหลดแผนที่:', err);
                showNotificationLeft('ดาวน์โหลดแผนที่ล้มเหลว: ' + err.message, 'error');
                
                const progressIndicator = document.getElementById('map-download-progress');
                if (progressIndicator) progressIndicator.remove();
            }
        }

        // ============================================
        // ตรวจสอบการอัปเดตแผนที่ (ใช้ HEAD request - ไม่มีค่าใช้จ่าย)
        // ============================================
        async function checkForMapUpdate() {
            try {
                console.log('🔍 ตรวจสอบการอัปเดตแผนที่...');
                
                // ✅ ตรวจสอบว่าเคยเช็ควันนี้แล้วหรือยัง
                const today = new Date().toDateString();
                const lastCheck = localStorage.getItem(MAP_CONFIG.lastCheckKey);
                if (lastCheck === today) {
                    console.log('✅ ตรวจสอบการอัปเดตแล้ววันนี้ - ข้าม');
                    return;
                }
                
                // ✅ ตรวจสอบว่าถึงเวลา 08:00 น. แล้วหรือยัง
                const now = new Date();
                if (now.getHours() < MAP_CONFIG.checkTime) {
                    console.log(`⏳ ยังไม่ถึงเวลา ${MAP_CONFIG.checkTime}:00 น. - ข้าม`);
                    return;
                }
                
                // ✅ ดึงเวลาแก้ไขล่าสุดจากไฟล์ในเครื่อง
                const localLastModifiedStr = localStorage.getItem(MAP_CONFIG.lastModifiedKey);
                if (!localLastModifiedStr) {
                    console.log('⚠️ ไม่พบข้อมูลเวลาแก้ไขในเครื่อง - ดาวน์โหลดใหม่');
                    await downloadAndCacheMap();
                    localStorage.setItem(MAP_CONFIG.lastCheckKey, today);
                    return;
                }
                
                // ✅ ส่งคำขอ HEAD ไปยังลิงก์ดาวน์โหลด (ไม่ดาวน์โหลดไฟล์จริง!)
                const fileUrl = `https://drive.google.com/uc?export=download&id=${MAP_CONFIG.googleDriveFileId}`;
                const headResponse = await fetch(fileUrl, { method: 'HEAD' });
                
                if (!headResponse.ok) {
                    throw new Error(`HEAD request ล้มเหลว: ${headResponse.status}`);
                }
                
                // ✅ ดึงเวลาแก้ไขล่าสุดจากหัวข้อ Last-Modified
                const remoteLastModifiedStr = headResponse.headers.get('last-modified');
                if (!remoteLastModifiedStr) {
                    console.warn('⚠️ ไม่พบหัวข้อ Last-Modified จากกูเกิ้ลไดร์ฟ');
                    localStorage.setItem(MAP_CONFIG.lastCheckKey, today);
                    return;
                }
                
                const remoteLastModified = new Date(remoteLastModifiedStr);
                const localLastModified = new Date(localLastModifiedStr);
                
                console.log(`🕒 เวลาแก้ไขในเครื่อง: ${localLastModified.toLocaleString('th-TH')}`);
                console.log(`🌐 เวลาแก้ไขบนไดร์ฟ: ${remoteLastModified.toLocaleString('th-TH')}`);
                
                // ✅ เปรียบเทียบเวลา - ดาวน์โหลดเฉพาะเมื่อไฟล์บนไดร์ฟใหม่กว่า
                if (remoteLastModified > localLastModified) {
                    console.log('🔄 พบเวอร์ชันใหม่บนกูเกิ้ลไดร์ฟ - กำลังดาวน์โหลด...');
                    showNotificationLeft('มีแผนที่เวอร์ชันใหม่! กำลังดาวน์โหลด...', 'info');
                    await downloadAndCacheMap();
                } else {
                    console.log('✅ แผนที่ในเครื่องเป็นเวอร์ชันล่าสุดแล้ว');
                    showNotificationLeft('แผนที่เป็นเวอร์ชันล่าสุดแล้ว', 'success');
                }
                
                // ✅ บันทึกว่าตรวจสอบแล้ววันนี้
                localStorage.setItem(MAP_CONFIG.lastCheckKey, today);
                
            } catch (err) {
                console.error('❌ ข้อผิดพลาดในการตรวจสอบการอัปเดต:', err);
                // ไม่แสดงข้อผิดพลาดให้ผู้ใช้ (ไม่รบกวนการทำงานหลัก)
            }
        }

        // ============================================
        // บันทึกข้อมูลแผนที่ในแคช (IndexedDB)
        // ============================================
        async function cacheMapData(arrayBuffer, lastModified) {
            try {
                // ✅ ใช้ IndexedDB สำหรับบันทึกไฟล์ขนาดใหญ่
                const db = await openMapDatabase();
                const transaction = db.transaction(['maps'], 'readwrite');
                const store = transaction.objectStore('maps');
                
                await store.put({
                    id: MAP_CONFIG.fileName,
                    data: arrayBuffer,
                    lastModified: lastModified
                });
                
                // ✅ บันทึกวันที่ใน localStorage สำหรับตรวจสอบง่าย
                localStorage.setItem(MAP_CONFIG.lastModifiedKey, lastModified);
                
                db.close();
                console.log('✅ บันทึกแผนที่ในแคชเรียบร้อย');
                
            } catch (err) {
                console.error('❌ ข้อผิดพลาดในการบันทึกแคช:', err);
                throw err;
            }
        }

        // ============================================
        // ดึงข้อมูลแผนที่จากแคช
        // ============================================
        async function getCachedMapData() {
            try {
                const db = await openMapDatabase();
                const transaction = db.transaction(['maps'], 'readonly');
                const store = transaction.objectStore('maps');
                const request = store.get(MAP_CONFIG.fileName);
                
                return new Promise((resolve, reject) => {
                    request.onsuccess = (event) => {
                        db.close();
                        resolve(event.target.result ? event.target.result.data : null);
                    };
                    request.onerror = (event) => {
                        db.close();
                        reject(event.target.error);
                    };
                });
                
            } catch (err) {
                console.error('❌ ข้อผิดพลาดในการดึงข้อมูลจากแคช:', err);
                return null;
            }
        }

        // ============================================
        // เปิดฐานข้อมูล IndexedDB สำหรับแผนที่
        // ============================================
        function openMapDatabase() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('MapCacheDB', 1);
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains('maps')) {
                        db.createObjectStore('maps', { keyPath: 'id' });
                    }
                };
                
                request.onsuccess = (event) => {
                    resolve(event.target.result);
                };
                
                request.onerror = (event) => {
                    reject(event.target.error);
                };
            });
        }

        // ============================================
        // โหลดแผนที่จากข้อมูลแคช
        // ============================================
        async function loadMapFromCache(arrayBuffer) {
            try {
                console.log('🗺️ กำลังโหลดแผนที่จากแคช...');
                
                // ✅ ใช้ไลบรารี GeoPackage เพื่ออ่านไฟล์
                const geoPackage = await GeoPackageAPI.open(arrayBuffer);
                
                // ✅ โหลดแต่ละชั้นข้อมูล
                for (const layerName of MAP_CONFIG.layers) {
                    await loadGeoPackageLayer(geoPackage, layerName);
                }
                
                console.log('✅ โหลดแผนที่เรียบร้อย');
                showNotificationLeft('โหลดแผนที่สำเร็จ!', 'success');
                
            } catch (err) {
                console.error('❌ ข้อผิดพลาดในการโหลดแผนที่:', err);
                showNotificationLeft('โหลดแผนที่ล้มเหลว: ' + err.message, 'error');
            }
        }

        // ============================================
        // โหลดชั้นข้อมูลจาก GeoPackage
        // ============================================
        async function loadGeoPackageLayer(geoPackage, layerName) {
            try {
                console.log(`🗺️ โหลดชั้นข้อมูล: ${layerName}`);
                
                // ✅ ดึงข้อมูลจากชั้นข้อมูล
                const featureDao = geoPackage.getFeatureDao(layerName);
                const features = [];
                
                // ✅ วนลูปดึงข้อมูลทั้งหมด
                await featureDao.queryForEach((feature) => {
                    features.push(feature);
                });
                
                // ✅ แปลงเป็น GeoJSON
                const geoJson = convertToGeoJSON(features, layerName);
                
                // ✅ แสดงบนแผนที่
                displayGeoJSONLayer(geoJson, layerName);
                
                console.log(`✅ โหลดชั้นข้อมูล ${layerName} เรียบร้อย (${features.length} รายการ)`);
                
            } catch (err) {
                console.error(`❌ ข้อผิดพลาดในการโหลดชั้นข้อมูล ${layerName}:`, err);
            }
        }

        // ============================================
        // แปลงข้อมูลเป็น GeoJSON
        // ============================================
        function convertToGeoJSON(features, layerName) {
            const geoJson = {
                type: 'FeatureCollection',
                features: features.map((feature) => {
                    return {
                        type: 'Feature',
                        geometry: feature.geometry,
                        properties: feature.attributes
                    };
                })
            };
            
            return geoJson;
        }

        // ============================================
        // แสดงข้อมูลบนแผนที่
        // ============================================
        function displayGeoJSONLayer(geoJson, layerName) {
            // ✅ สร้างเลเยอร์จากข้อมูล
            const layer = L.geoJSON(geoJson, {
                style: getLayerStyle(layerName),
                onEachFeature: onEachFeature
            });
            
            // ✅ เพิ่มเลเยอร์บนแผนที่
            layer.addTo(map);
            
            // ✅ เก็บอ้างอิงเลเยอร์ (ถ้าต้องการควบคุมการแสดง/ซ่อน)
            if (!window.mapLayers) window.mapLayers = {};
            window.mapLayers[layerName] = layer;
        }

        // ============================================
        // กำหนดสไตล์สำหรับแต่ละชั้นข้อมูล
        // ============================================
        function getLayerStyle(layerName) {
            switch (layerName) {
                case 'parcel':
                    return {
                        color: '#2563eb',
                        weight: 2,
                        fillOpacity: 0.1,
                        fillColor: '#2563eb'
                    };
                case 'boundary':
                    return {
                        color: '#dc2626',
                        weight: 3,
                        fillOpacity: 0,
                        dashArray: '5, 5'
                    };
                case 'building':
                    return {
                        color: '#16a34a',
                        weight: 1,
                        fillOpacity: 0.3,
                        fillColor: '#22c55e'
                    };
                default:
                    return {
                        color: '#6b7280',
                        weight: 1,
                        fillOpacity: 0.1
                    };
            }
        }

        // ============================================
        // จัดการเมื่อคลิกบนฟีเจอร์
        // ============================================
        function onEachFeature(feature, layer) {
            if (feature.properties) {
                // ✅ แสดงป๊อปอัปเมื่อคลิก
                layer.bindPopup(`
                    <div class="map-popup">
                        <h3>${feature.properties.name || 'ข้อมูล'}</h3>
                        <table class="popup-table">
                            ${Object.entries(feature.properties)
                                .map(([key, value]) => 
                                    `<tr><td><strong>${key}:</strong></td><td>${value}</td></tr>`
                                )
                                .join('')}
                        </table>
                    </div>
                `);
            }
        }

        // ============================================
        // เรียกใช้เมื่อโหลดหน้าเว็บ
        // ============================================
        window.addEventListener('load', () => {
            // ✅ ตรวจสอบและโหลดแผนที่
            checkAndLoadMap();
            
            // ✅ ตั้งเวลาตรวจสอบการอัปเดตทุกวัน 08:00 น.
            scheduleDailyUpdateCheck();
        });

        // ============================================
        // ตั้งเวลาตรวจสอบอัปเดตทุกวัน 08:00 น.
        // ============================================
        function scheduleDailyUpdateCheck() {
            // ✅ คำนวณเวลาถัดไปที่จะตรวจสอบ (08:00 น. ของวันนี้หรือพรุ่งนี้)
            const now = new Date();
            const nextCheck = new Date(now);
            nextCheck.setHours(MAP_CONFIG.checkTime, 0, 0, 0); // 08:00:00
            
            // ถ้าเลยเวลา 08:00 น. แล้ว ให้ตั้งเวลาเป็นพรุ่งนี้
            if (now > nextCheck) {
                nextCheck.setDate(nextCheck.getDate() + 1);
            }
            
            // ✅ คำนวณเวลาที่เหลือจนถึงเวลาตรวจสอบ
            const timeUntilCheck = nextCheck - now;
            
            console.log(`⏰ ตั้งเวลาตรวจสอบอัปเดตแผนที่: ${nextCheck.toLocaleString()}`);
            console.log(`⏳ เวลาที่เหลือ: ${Math.floor(timeUntilCheck / 60000)} นาที`);
            
            // ✅ ตั้งเวลาตรวจสอบ
            setTimeout(() => {
                checkForMapUpdate();
                
                // ✅ ตั้งเวลาตรวจสอบใหม่ทุกวัน (24 ชั่วโมง)
                setInterval(checkForMapUpdate, 24 * 60 * 60 * 1000);
            }, timeUntilCheck);
        }

        // ============================================
        // Enhanced Sync Process with Image Support
        // ============================================

        async function processSyncQueue() {
            if (!navigator.onLine || syncQueue.length === 0) {
                console.log('ไม่สามารถซิงค์ได้: ไม่มีอินเทอร์เน็ตหรือไม่มีคิว');
                return;
            }
            
            console.log(`กำลังซิงค์ข้อมูล (${syncQueue.length} รายการ)...`);
            
            const failedItems = [];
            for (let item of syncQueue) {
                if (item.status === 'success') continue;
                
                try {
                    const result = await sendDataWithRetry(
                        item.action,
                        item.type,
                        item.data,
                        item.rowKey,
                        3
                    );
                    
                    if (result.success) {
                        item.status = 'success';
                        removeFromSyncQueue(item.id);
                        console.log(`Synced: ${item.id}`);
                    } else {
                        item.retryCount++;
                        if (item.retryCount >= 5) {
                            item.status = 'failed';
                            failedItems.push(item);
                        }
                    }
                } catch (err) {
                    item.retryCount++;
                    console.error(`Error syncing ${item.id}:`, err);
                    if (item.retryCount >= 5) {
                        item.status = 'failed';
                        failedItems.push(item);
                    }
                }
                
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            
            // ซิงค์รูปภาพที่ยังไม่ได้ส่ง
            await syncPendingImages();
            saveSyncQueueToStorage();
            
            // แจ้งผลลัพธ์
            const successCount = syncQueue.filter(i => i.status === 'success').length;
            const ยังไม่สำรวจCount = syncQueue.filter(i => i.status === 'ยังไม่สำรวจ').length;
            
            if (ยังไม่สำรวจCount === 0 && failedItems.length === 0) {
                console.log('ซิงค์ข้อมูลสำเร็จทั้งหมด!');
            } else if (ยังไม่สำรวจCount > 0) {
                console.log(`ซิงค์ข้อมูล ${successCount} รายการ (${ยังไม่สำรวจCount} รายการรอซิงค์)`);
            }
            
            if (failedItems.length > 0) {
                console.log(`มี ${failedItems.length} รายการที่ซิงค์ไม่สำเร็จ`);
            }
        }


        // โหลดคิวเมื่อแอปเริ่มทำงาน
        loadSyncQueueFromStorage();

        // เพิ่มปุ่มตรวจสอบสถานะซิงค์ในเมนูฟันเฟือง
        // ในฟังก์ชัน toggleSettingsMenu ให้เพิ่มปุ่มใหม่:

        /*
        <button onclick="checkSyncStatus()" class="map-btn p-3 w-48 bg-gradient-to-r from-gray-400 to-gray-600 text-white hover:scale-105 transition-all shadow-lg flex items-center justify-start gap-2 text-left">
            <i data-lucide="sync" class="w-5 h-5"></i>
            <span class="text-xs font-bold">ตรวจสอบสถานะซิงค์</span>
        </button>
        */

        // ฟังก์ชันตรวจสอบสถานะ
        function checkSyncStatus() {
            closeSettingsMenu();
            
            const ยังไม่สำรวจ = syncQueue.filter(i => i.status === 'ยังไม่สำรวจ').length;
            const failed = syncQueue.filter(i => i.status === 'failed').length;
            const success = syncQueue.filter(i => i.status === 'success').length;
            
            let message = `📊 สถานะการซิงค์ข้อมูล:\n`;
            message += `✅ สำเร็จ: ${success} รายการ\n`;
            message += `⏳ รอซิงค์: ${ยังไม่สำรวจ} รายการ\n`;
            message += `❌ ล้มเหลว: ${failed} รายการ`;
            
            if (ยังไม่สำรวจ > 0) {
                message += `\n\n⚠️ มีข้อมูลที่ยังไม่ได้ซิงค์!`;
            }
            
            alert(message);
            
            // ถ้ามีข้อมูลรอซิงค์ ถามว่าต้องการซิงค์เลยไหม
            if (ยังไม่สำรวจ > 0 && isOnline) {
                if (confirm(`ต้องการซิงค์ข้อมูล ${ยังไม่สำรวจ} รายการที่รออยู่เลยหรือไม่?`)) {
                    processSyncQueue();
                }
            }
        }

        // ============================================
        // Auto-check and sync on app startup
        // ============================================

        async function checkAndSyncOnStartup() {
            console.log('ตรวจสอบข้อมูลที่รอซิงค์...');
            
            // โหลดคิวจาก localStorage
            loadSyncQueueFromStorage();
            
            // ตรวจสอบรูปภาพที่ยังไม่ได้ซิงค์
            try {
                const unsyncedImages = await getUnsyncedImages();
                const ยังไม่สำรวจCount = syncQueue.filter(i => i.status === 'ยังไม่สำรวจ').length;
                
                if (ยังไม่สำรวจCount > 0 || unsyncedImages.length > 0) {
                    const totalPending = ยังไม่สำรวจCount + unsyncedImages.length;
                    
                    showNotificationLeft(
                        `พบข้อมูลที่รอซิงค์ ${totalPending} รายการ`, 
                        'warning'
                    );
                    
                    // ถ้าออนไลน์ → เริ่มซิงค์ทันที
                    if (isOnline) {
                        setTimeout(() => {
                            showNotificationLeft('กำลังซิงค์ข้อมูล...', 'info');
                            processSyncQueue();
                        }, 1000);
                    } else {
                        showNotificationLeft('⚠️ อยู่ในโหมดออฟไลน์ - รอการเชื่อมต่อ', 'warning');
                    }
                }
            } catch (err) {
                console.error('Error checking ยังไม่สำรวจ data:', err);
            }
        }

        // ✅ มีเพียงระบบใหม่
        // ใช้ window.addEventListener แทน  เพื่อป้องกันการทับซ้อน
        window.addEventListener('load', async () => {
            // 1. เริ่มต้นแผนที่และไอคอน
            initMap();
            lucide.createIcons();
            loadExistingData();
            
            // 2. ตรวจสอบและซิงค์ข้อมูลที่ค้างอยู่ (สำคัญสำหรับระบบออฟไลน์)
            await checkAndSyncOnStartup();
            
            // 3. อัปเดตจุดแจ้งเตือนจำนวนข้อมูลที่รอซิงค์
            setInterval(() => {
                updateSyncBadge();
            }, 1000);

        window.addEventListener('beforeunload', () => {
            stopRealtimeAutoUpdate(); // ✅ หยุดระบบใหม่
        });
            
            // 4. ลงทะเบียน Service Worker สำหรับแคชไทล์
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('/sw.js')
                    .then((registration) => {
                        console.log('Service Worker registered:', registration.scope);
                    })
                    .catch((error) => {
                        console.log('Service Worker registration failed:', error);
                    });
            }
        });

        // แสดงจำนวนข้อมูลที่รอซิงค์ในปุ่มฟันเฟือง
        function updateSyncBadge() {
            const ยังไม่สำรวจ = syncQueue.filter(i => i.status === 'ยังไม่สำรวจ').length;
            const badge = document.getElementById('settings-badge');
            
            if (ยังไม่สำรวจ > 0) {
                badge.textContent = ยังไม่สำรวจ > 9 ? '9+' : ยังไม่สำรวจ;
                badge.classList.remove('hidden');
            } else {
                badge.classList.add('hidden');
            }
        }

        // เรียกใช้ทุกครั้งที่มีการเปลี่ยนแปลงคิว
        setInterval(updateSyncBadge, 1000);

        // ============================================
        // IndexedDB Storage for Images
        // ============================================

        let dbPromise = null;

        // เปิด/สร้าง IndexedDB
        function openDatabase() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('SurveyAppDB', 2);
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    
                    // สร้าง Store สำหรับรูปภาพ
                    if (!db.objectStoreNames.contains('images')) {
                        const imageStore = db.createObjectStore('images', { 
                            keyPath: 'id' 
                        });
                        imageStore.createIndex('timestamp', 'timestamp');
                        imageStore.createIndex('synced', 'synced');
                    }
                    
                    // สร้าง Store สำหรับข้อมูลซิงค์
                    if (!db.objectStoreNames.contains('syncQueue')) {
                        const queueStore = db.createObjectStore('syncQueue', { 
                            keyPath: 'id' 
                        });
                        queueStore.createIndex('status', 'status');
                        queueStore.createIndex('timestamp', 'timestamp');
                    }
                };
                
                request.onsuccess = (event) => {
                    resolve(event.target.result);
                };
                
                request.onerror = (event) => {
                    reject(event.target.error);
                };
            });
        }

        // บันทึกรูปภาพลงใน IndexedDB (พร้อมตรวจสอบพื้นที่และจัดการข้อผิดพลาด)
        async function saveImageToDB(imageData, filename, relatedId, type) {
            try {
                // ✅ ตรวจสอบขนาดรูปภาพก่อนบันทึก
                const estimateSize = Math.ceil(imageData.length * 0.75); // ประมาณขนาดจริง (ลบ 25% จาก base64)
                
                if (estimateSize > 50 * 1024 * 1024) { // เตือนถ้าเกิน 50MB
                    showNotificationLeft('⚠️ รูปภาพใหญ่เกินไป อาจใช้พื้นที่มาก', 'warning');
                }
                
                const db = await openDatabase();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction('images', 'readwrite');
                    const store = transaction.objectStore('images');
                    
                    const imageRecord = {
                        id: Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                        filename: filename,
                         imageData, // base64 string
                        relatedId: relatedId,
                        type: type, // 'building' หรือ 'sign'
                        timestamp: new Date().toISOString(),
                        synced: false,
                        retryCount: 0
                    };
                    
                    const request = store.add(imageRecord);
                    
                    request.onsuccess = () => {
                        console.log(`บันทึกรูปภาพสำเร็จ: ${filename} (${Math.round(estimateSize / 1024)} KB)`);
                        resolve(imageRecord.id);
                    };
                    
                    request.onerror = (event) => {
                        // ✅ ตรวจสอบข้อผิดพลาดพื้นที่เต็ม
                        if (event.target.error && event.target.error.name === 'QuotaExceededError') {
                            showNotificationLeft(
                                '❌ พื้นที่เก็บข้อมูลเต็ม! โปรดซิงค์ข้อมูลก่อนถ่ายรูปเพิ่ม',
                                'error'
                            );
                            reject(new Error('Storage quota exceeded'));
                        } else {
                            console.error('Error saving image to DB:', event.target.error);
                            reject(event.target.error);
                        }
                    };
                });
            } catch (err) {
                console.error('Error in saveImageToDB:', err);
                throw err;
            }
        }

        async function checkStorageSpace() {
            try {
                if ('storage' in navigator && 'estimate' in navigator.storage) {
                    const estimate = await navigator.storage.estimate();
                    const usage = estimate.usage || 0;
                    const quota = estimate.quota || 50 * 1024 * 1024; // 50MB default
                    
                    const usagePercent = (usage / quota) * 100;
                    
                    if (usagePercent > 80) {
                        showNotificationLeft(
                            `⚠️ พื้นที่เก็บข้อมูลเหลือน้อย (${Math.round(100 - usagePercent)}%)`,
                            'warning'
                        );
                    }
                    
                    if (usagePercent > 95) {
                        showNotificationLeft(
                            `❌ พื้นที่เก็บข้อมูลเกือบเต็ม! โปรดซิงค์ข้อมูล`,
                            'error'
                        );
                    }
                }
            } catch (err) {
                console.error('Error checking storage:', err);
            }
        }

        // ============================================
        // ฟังก์ชันดึงรูปภาพที่ยังไม่ได้ซิงค์ (แก้ไขแล้ว - ไม่ใช้ดัชนี boolean)
        // ============================================
        async function getUnsyncedImages() {
            const db = await openDatabase();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction('images', 'readonly');
                const store = transaction.objectStore('images');
                const request = store.openCursor(); // ✅ ไม่ใช้ดัชนี
                const unsyncedImages = [];
                
                request.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        const image = cursor.value;
                        // ✅ ตรวจสอบค่าโดยตรง
                        if (!image.synced || image.synced === false) {
                            unsyncedImages.push(image);
                        }
                        cursor.continue();
                    } else {
                        resolve(unsyncedImages);
                    }
                };
                
                request.onerror = (event) => {
                    console.error('Error getting unsynced images:', event.target.error);
                    reject(event.target.error);
                };
            });
        }

        // ============================================
        // ฟังก์ชันซิงค์รูปภาพ (แก้ไขแล้ว - ส่งให้ตรงกับเซิร์ฟเวอร์)
        // ============================================
        async function syncPendingImages() {
            try {
                const unsyncedImages = await getUnsyncedImages();
                if (unsyncedImages.length === 0) {
                    console.log('ℹ️ ไม่มีรูปภาพที่รอซิงค์');
                    return;
                }
                
                showNotificationLeft(`กำลังอัปโหลดรูปภาพ (${unsyncedImages.length} รูป)...`, 'info');
                console.log(`📤 เริ่มอัปโหลดรูปภาพ (${unsyncedImages.length} รูป)`);
                
                let successCount = 0;
                
                for (const image of unsyncedImages) {
                    try {
                        console.log(`📤 ส่งรูปภาพ: ${image.filename} (${image.relatedId})`);
                        
                        // ✅ ใช้ชื่อไฟล์ที่บันทึกไว้ใน IndexedDB (ไม่ต้องแยกอีก)
                        const payload = {};
                        
                        const body = new URLSearchParams();
                        body.append('action', 'update');
                        body.append('type', image.type);
                        body.append('rowKey', image.relatedId);
                        body.append('payload', JSON.stringify(payload));
                        body.append('image', image.imageData);
                        body.append('fileName', image.filename); // ✅ ใช้ชื่อที่ตั้งไว้แล้ว
                        
                        const res = await fetch(CONFIG.SCRIPT_URL.trim(), {
                            method: 'POST',
                            body,
                            timeout: 60000
                        });
                        
                        let result = null;
                        try {
                            result = await res.json();
                        } catch (parseErr) {
                            console.error(`❌ ไม่สามารถอ่านคำตอบจากเซิร์ฟเวอร์:`, parseErr);
                        }
                        
                        if (res.ok && result && (result.success === true || result.status === 200)) {
                            await markImageAsSynced(image.id);
                            successCount++;
                            console.log(`✅ อัปโหลดรูปภาพสำเร็จ: ${image.filename}`);
                            showNotificationLeft(`อัปโหลดรูปภาพ ${image.filename} สำเร็จ!`, 'success');
                        } else {
                            const errorMsg = result?.error || result?.message || `HTTP ${res.status}`;
                            console.error(`❌ อัปโหลดรูปภาพล้มเหลว: ${image.filename} - ${errorMsg}`);
                            
                            image.retryCount = (image.retryCount || 0) + 1;
                            if (image.retryCount >= 5) {
                                console.error(`❌ ยกเลิกหลังลอง ${image.retryCount} ครั้ง: ${image.filename}`);
                            }
                            
                            showNotificationLeft(`❌ ล้มเหลว: ${image.filename}`, 'error');
                        }
                    } catch (err) {
                        console.error(`❌ ข้อผิดพลาดในการอัปโหลด ${image.filename}:`, err);
                        image.retryCount = (image.retryCount || 0) + 1;
                        showNotificationLeft(`⚠️ ข้อผิดพลาด: ${image.filename}`, 'error');
                    }
                    
                    // รอ 2 วินาทีระหว่างส่งแต่ละรูป
                    await new Promise(resolve => setTimeout(resolve, 2000));
                }
                
                // ลบรูปภาพที่ซิงค์สำเร็จแล้ว
                await cleanupSyncedImages();
                
                if (successCount > 0) {
                    console.log(`✅ อัปโหลดรูปภาพสำเร็จทั้งหมด ${successCount}/${unsyncedImages.length} รูป`);
                }
            } catch (err) {
                console.error('❌ ข้อผิดพลาดในการซิงค์รูปภาพ:', err);
                showNotificationLeft('เกิดข้อผิดพลาดในการอัปโหลดรูปภาพ', 'error');
            }
        }

        // ============================================
        // ฟังก์ชันลบรูปภาพที่ซิงค์สำเร็จแล้ว (แก้ไขแล้ว - ไม่ใช้ดัชนี)
        // ============================================
        async function cleanupSyncedImages() {
            const db = await openDatabase();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction('images', 'readwrite');
                const store = transaction.objectStore('images');
                const request = store.openCursor(); // ✅ ไม่ใช้ดัชนี
                
                request.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        const image = cursor.value;
                        // ✅ ตรวจสอบค่าโดยตรง
                        if (image.synced === true) {
                            store.delete(cursor.primaryKey);
                        }
                        cursor.continue();
                    } else {
                        resolve();
                    }
                };
                
                request.onerror = (event) => {
                    console.error('Error cleaning up synced images:', event.target.error);
                    reject(event.target.error);
                };
            });
        }


        // ทำเครื่องหมายว่ารูปภาพซิงค์สำเร็จแล้ว
        async function markImageAsSynced(imageId) {
            const db = await openDatabase();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction('images', 'readwrite');
                const store = transaction.objectStore('images');
                
                const request = store.get(imageId);
                
                request.onsuccess = (event) => {
                    const image = event.target.result;
                    if (image) {
                        image.synced = true;
                        const updateRequest = store.put(image);
                        updateRequest.onsuccess = () => resolve();
                        updateRequest.onerror = () => reject(updateRequest.error);
                    } else {
                        reject(new Error('Image not found'));
                    }
                };
                
                request.onerror = () => {
                    reject(request.error);
                };
            });
        }

        // ลบรูปภาพที่ซิงค์สำเร็จแล้ว
        async function cleanupSyncedImages() {
            const db = await openDatabase();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction('images', 'readwrite');
                const store = transaction.objectStore('images');
                
                // ✅ ใช้ openCursor แทนการใช้ดัชนี (แก้ไขปัญหา IDBKeyRange)
                const request = store.openCursor();
                
                request.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        const image = cursor.value;
                        // ✅ ตรวจสอบค่าด้วยตนเอง
                        if (image.synced === true) {
                            store.delete(cursor.primaryKey);
                        }
                        cursor.continue();
                    } else {
                        resolve();
                    }
                };
                
                request.onerror = (event) => {
                    console.error('Error cleaning up synced images:', event.target.error);
                    reject(event.target.error);
                };
            });
        }

        // สร้างฟังก์ชันแสดงแจ้งเตือนฝั่งซ้าย
        function showNotificationLeft(message, type = 'info') {
            // ลบแจ้งเตือนเก่า
            const oldNotif = document.querySelector('.notification-left');
            if (oldNotif) oldNotif.remove();
            
            // กำหนดสีตามประเภท
            let bgColor = 'bg-blue-500';
            let icon = 'loader';
            
            if (type === 'success') {
                bgColor = 'bg-green-500';
                icon = 'check-circle';
            } else if (type === 'error') {
                bgColor = 'bg-red-500';
                icon = 'alert-circle';
            } else if (type === 'warning') {
                bgColor = 'bg-yellow-500';
                icon = 'alert-triangle';
            }
            
            // สร้างแจ้งเตือน
            const notif = document.createElement('div');
            notif.className = `fixed top-4 left-4 px-6 py-3 rounded-lg shadow-lg z-[2000] animate-fade-in notification-left ${bgColor} text-white font-bold flex items-center gap-2`;
            notif.innerHTML = `
                <i data-lucide="${icon}" class="w-5 h-5"></i>
                <span>${message}</span>
            `;
            
            document.body.appendChild(notif);
            lucide.createIcons({ elements: notif.querySelectorAll('[data-lucide]') });
            
            // ซ่อนอัตโนมัติหลัง 3 วินาที
            setTimeout(() => {
                notif.classList.add('animate-fade-out');
                setTimeout(() => notif.remove(), 300);
            }, 500);
        }

        // ============================================
        // อัปเดตแผนที่ด้วยตนเอง (จากเมนูตั้งค่า)
        // ============================================
        async function manualUpdateMap() {
            closeSettingsMenu();
            
            try {
                showNotificationLeft('กำลังตรวจสอบการอัปเดตแผนที่...', 'info');
                
                // ✅ ตรวจสอบว่ามีการเชื่อมต่ออินเทอร์เน็ต
                if (!navigator.onLine) {
                    showNotificationLeft('❌ ไม่มีการเชื่อมต่ออินเทอร์เน็ต', 'error');
                    return;
                }
                
                // ✅ ดาวน์โหลดแผนที่ใหม่ทันที
                await downloadAndCacheMap();
                
                // ✅ บันทึกเวลาตรวจสอบ
                const today = new Date().toDateString();
                localStorage.setItem(MAP_CONFIG.lastCheckKey, today);
                
                showNotificationLeft('✅ อัปเดตแผนที่สำเร็จ!', 'success');
                
            } catch (err) {
                console.error('❌ ข้อผิดพลาดในการอัปเดตแผนที่:', err);
                showNotificationLeft('อัปเดตแผนที่ล้มเหลว: ' + err.message, 'error');
            }
        }
 
        // ============================================
        // อัปเดตข้อมูลแบบเรียลไทม์
        // ============================================
        async function realtimeUpdate() {
            if (!navigator.onLine || isUpdating) return;
            
            isUpdating = true;
            try {
                const res = await fetch(`${CONFIG.SCRIPT_URL}?action=getData&t=${Date.now()}`);
                const newData = await res.json();
                
                // ✅ แก้ไข: ลบการตรวจสอบ timestamp ออก (เซิร์ฟเวอร์ไม่ได้ส่งมา)
                if (!newData.buildings || !newData.signs) { // ← ลบ newData.timestamp ||
                    console.warn('ข้อมูลจากเซิร์ฟเวอร์ไม่สมบูรณ์');
                    return;
                }
                
                // ตรวจสอบการเปลี่ยนแปลง
                const buildingChanges = detectChanges(allBuildings, newData.buildings);
                const signChanges = detectChanges(allSigns, newData.signs);
                
                // อัปเดตแผนที่และตาราง
                if (buildingChanges.total > 0) {
                    applyChanges(buildingChanges, 'building');
                    showUpdateNotification(buildingChanges, 'สิ่งปลูกสร้าง');
                }
                
                if (signChanges.total > 0) {
                    applyChanges(signChanges, 'sign');
                    showUpdateNotification(signChanges, 'ป้าย');
                }
                
                // อัปเดตข้อมูลแคช
                allBuildings = newData.buildings;
                allSigns = newData.signs;
                
                console.log('✅ อัปเดตข้อมูลเรียลไทม์สำเร็จ');
            } catch (err) {
                console.error('❌ ข้อผิดพลาดในการอัปเดต:', err);
            } finally {
                isUpdating = false;
            }
        }

        // ตรวจจับการเปลี่ยนแปลง
        function detectChanges(oldData, newData) {
            const oldMap = new Map(oldData.map(item => [item.id || item._row_num, item]));
            const newMap = new Map(newData.map(item => [item.id || item._row_num, item]));
            
            const added = [];
            const updated = [];
            const deleted = [];
            
            // หาข้อมูลที่เพิ่มใหม่
            newData.forEach(item => {
                const id = item.id || item._row_num;
                if (!oldMap.has(id)) added.push(item);
            });
            
            // หาข้อมูลที่อัปเดต
            newData.forEach(item => {
                const id = item.id || item._row_num;
                const oldItem = oldMap.get(id);
                if (oldItem && JSON.stringify(oldItem) !== JSON.stringify(item)) {
                    updated.push(item);
                }
            });
            
            // หาข้อมูลที่ถูกลบ
            oldData.forEach(item => {
                const id = item.id || item._row_num;
                if (!newMap.has(id)) deleted.push(item);
            });
            
            return { 
                added, 
                updated, 
                deleted,
                total: added.length + updated.length + deleted.length
            };
        }

        // ประยุกต์การเปลี่ยนแปลง
        function applyChanges(changes, type) {
            // ลบมาร์กเกอร์ที่ถูกลบ
            changes.deleted.forEach(item => {
                surveyLayers.eachLayer(layer => {
                    if (layer._popupData && 
                        (layer._popupData.id === item.id || layer._popupData._row_num === item._row_num)) {
                        surveyLayers.removeLayer(layer);
                    }
                });
            });
            
            // อัปเดตหรือเพิ่มมาร์กเกอร์ใหม่
            [...changes.added, ...changes.updated].forEach(item => {
                if (!item.lat_long) return;
                
                const coords = item.lat_long.split(',').map(Number);
                if (coords.length < 2 || isNaN(coords[0]) || isNaN(coords[1])) return;
                
                // ค้นหามาร์กเกอร์ที่มีอยู่
                let existingMarker = null;
                surveyLayers.eachLayer(layer => {
                    if (layer._popupData && 
                        (layer._popupData.id === item.id || layer._popupData._row_num === item._row_num)) {
                        existingMarker = layer;
                    }
                });
                
                if (existingMarker) {
                    // อัปเดตมาร์กเกอร์ที่มีอยู่
                    existingMarker.setLatLng(L.latLng(coords[0], coords[1]));
                    existingMarker._popupData = item;
                    setupMarkerPopup(existingMarker, item, type);
                } else {
                    // เพิ่มมาร์กเกอร์ใหม่
                    const marker = createCircleMarker(L.latLng(coords[0], coords[1]), type, isEditMode);
                    marker._popupData = item;
                    setupMarkerPopup(marker, item, type);
                    marker.addTo(surveyLayers);
                    if (isEditMode) enableMarkerDragging(marker, item);
                }
            });
            
            // อัปเดตตาราง
            if (type === 'building') renderBuildingTable();
            else renderSignTable();
        }

        // แสดงการแจ้งเตือน
        function showUpdateNotification(changes, typeName) {
            if (changes.total === 0) return;
            
            let message = `🔄 มีการอัปเดต${typeName} `;
            const parts = [];
            if (changes.added.length > 0) parts.push(`เพิ่ม ${changes.added.length}`);
            if (changes.updated.length > 0) parts.push(`แก้ไข ${changes.updated.length}`);
            if (changes.deleted.length > 0) parts.push(`ลบ ${changes.deleted.length}`);
            
            message += parts.join(', ');
            showNotificationLeft(message, 'info');
        }

        // ============================================
        // เริ่มระบบอัปเดตอัตโนมัติ
        // ============================================
        function startRealtimeAutoUpdate() {
            if (autoUpdateInterval) clearInterval(autoUpdateInterval);
            
            autoUpdateInterval = setInterval(() => {
                if (!isUpdating && navigator.onLine) {
                    realtimeUpdate();
                }
            }, 5000); // 5 วินาที
            
            console.log('✅ เริ่มระบบอัปเดตเรียลไทม์ทุก 5 วินาที');
        }

        // ============================================

        // ============================================
        // ข้อ 1.1: คำนวณพื้นที่ (กว้าง × ยาว)
        // ============================================
        let areaCalculatorModal = null;

        function openAreaCalculator() {
            // ปิดโมดัลเก่าถ้ามี
            if (areaCalculatorModal) {
                areaCalculatorModal.remove();
            }
            
            // สร้างหน้าต่างคำนวณพื้นที่
            areaCalculatorModal = document.createElement('div');
            areaCalculatorModal.className = 'fixed inset-0 bg-black/20 z-[3000] flex items-center justify-center p-4 pointer-events-none'; // ✅ เพิ่ม pointer-events-none
            areaCalculatorModal.innerHTML = `
            <div class="bg-white/90 backdrop-blur-sm rounded-xl shadow-2xl w-full max-w-md animate-scale-in pointer-events-auto"> <!-- ✅ เพิ่ม pointer-events-auto -->
                <div class="p-4 border-b flex justify-between items-center">
                    <h3 class="font-bold text-lg text-blue-900">คำนวณพื้นที่ประกอบการ</h3>
                    <button onclick="closeAreaCalculator()" class="p-2 hover:bg-gray-200 rounded-full">
                        <i data-lucide="x" class="w-5 h-5"></i>
                    </button>
                </div>
                <div class="p-4 space-y-4">
                    <div class="grid grid-cols-2 gap-3">
                        <div>
                            <label class="form-label">กว้าง (ม.)</label>
                            <input type="number" id="calc-width" class="form-input text-center" placeholder="" step="0.01" oninput="calculateAreaResult()" style="-webkit-appearance: textfield; -moz-appearance: textfield; appearance: textfield;">
                        </div>
                        <div>
                            <label class="form-label">ยาว (ม.)</label>
                            <input type="number" id="calc-length" class="form-input text-center" placeholder="" step="0.01" oninput="calculateAreaResult()" style="-webkit-appearance: textfield; -moz-appearance: textfield; appearance: textfield;">
                        </div>
                    </div>
                    <div>
                        <label class="form-label">ผลลัพธ์ (ตร.ม.)</label>
                        <input type="number" id="calc-result" class="form-input bg-custom-green/80 font-bold text-center" readonly placeholder="ผลลัพธ์พื้นที่ประกอบการ" style="-webkit-appearance: textfield; -moz-appearance: textfield; appearance: textfield;"> <!-- ✅ ลดความทึบของสีเขียว -->
                    </div>
                    <div class="flex gap-2">
                        <button type="button" onclick="clearAreaCalculator()" 
                            class="flex-1 py-2 bg-gray-500 text-white rounded font-bold hover:bg-gray-600 transition">
                            <i data-lucide="trash-2" class="w-4 h-4 inline mr-1"></i>
                            ล้าง
                        </button>
                        <button type="button" onclick="addAreaToField()" 
                            class="flex-1 py-2 bg-blue-600 text-white rounded font-bold hover:bg-blue-700 transition">
                            <i data-lucide="plus" class="w-4 h-4 inline mr-1"></i>
                            บวกเพิ่ม
                        </button>
                    </div>
                </div>
            </div>
            `;
            document.body.appendChild(areaCalculatorModal);
            lucide.createIcons();
            
            // ✅ ป้องกันการเปลี่ยนค่าโดยการหมุนเมาส์ในช่องกรอกตัวเลขของหน้าต่างคำนวณพื้นที่
            const preventWheel = (e) => e.preventDefault();
            ['calc-width', 'calc-length', 'calc-result'].forEach(id => {
                const input = document.getElementById(id);
                if (input) {
                    input.addEventListener('wheel', preventWheel, { passive: false });
                    // ✅ ป้องกันการกดปุ่มลูกศรบน/ล่างด้วย (เพิ่มเติมเพื่อความสมบูรณ์)
                    input.addEventListener('keydown', (e) => {
                        if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                            e.preventDefault();
                        }
                    });
                }
            });
            
            // โฟกัสที่ช่องกว้าง
            document.getElementById('calc-width')?.focus();
        }

        // คำนวณผลลัพธ์เรียลไทม์
        function calculateAreaResult() {
            const width = parseFloat(document.getElementById('calc-width').value) || 0;
            const length = parseFloat(document.getElementById('calc-length').value) || 0;
            const result = width * length;
            document.getElementById('calc-result').value = result.toFixed(2);
        }

        // ล้างค่า
        function clearAreaCalculator() {
            document.getElementById('calc-width').value = '';
            document.getElementById('calc-length').value = '';
            document.getElementById('calc-result').value = '0';
        }

        // บวกเพิ่มค่าในช่อง buse_area2
        function addAreaToField() {
            const result = parseFloat(document.getElementById('calc-result').value) || 0;
            const buseArea2Field = document.querySelector('input[name="buse_area2"]');
            
            if (!buseArea2Field) {
                showNotificationLeft('ไม่พบช่องกรอกพื้นที่ใช้ (2)', 'error');
                return;
            }
            
            const currentValue = parseFloat(buseArea2Field.value) || 0;
            const newValue = currentValue + result;
            
            buseArea2Field.value = newValue.toFixed(2);
            showNotificationLeft(`เพิ่มพื้นที่ ${result.toFixed(2)} ตร.ม. รวมเป็น ${newValue.toFixed(2)} ตร.ม.`, 'success');
            
            // ✅ ล้างค่าช่องกว้างและยาว แต่ไม่ปิดหน้าต่าง เพื่อให้ผู้ใช้สามารถคำนวณเพิ่มได้อีก
            document.getElementById('calc-width').value = '';
            document.getElementById('calc-length').value = '';
            document.getElementById('calc-result').value = '0';
            document.getElementById('calc-width').focus();
        }

        // ปิดหน้าต่าง
        function closeAreaCalculator() {
            if (areaCalculatorModal) {
                areaCalculatorModal.classList.add('animate-scale-out');
                setTimeout(() => {
                    if (areaCalculatorModal && areaCalculatorModal.parentNode) {
                        areaCalculatorModal.remove();
                    }
                    areaCalculatorModal = null;
                }, 200);
            }
        }

        // ============================================
        // ข้อ 1.2: คำนวณผลต่าง (b_area - buse_area2)
        // ============================================
        function calculateDeltaArea() {
            const bAreaField = document.querySelector('input[name="b_area"]');
            const buseArea2Field = document.querySelector('input[name="buse_area2"]');
            const buseAreaField = document.querySelector('input[name="buse_area"]');
            
            if (!bAreaField || !buseArea2Field || !buseAreaField) {
                showNotificationLeft('ไม่พบฟิลด์ที่ต้องการ', 'error');
                return;
            }
            
            const bArea = parseFloat(bAreaField.value) || 0;
            const buseArea2 = parseFloat(buseArea2Field.value) || 0;
            
            if (buseArea2 === 0) {
                showNotificationLeft('⚠️ ช่อง "พื้นที่ใช้ (2)" ยังไม่มีค่า', 'warning');
                return;
            }
            
            const result = bArea - buseArea2;
            
            if (result < 0) {
                showNotificationLeft('❌ ผลลัพธ์ติดลบ ตรวจสอบค่าอีกครั้ง', 'error');
                return;
            }
            
            buseAreaField.value = result.toFixed(2);
            showNotificationLeft(`คำนวณผลต่าง: ${bArea.toFixed(2)} - ${buseArea2.toFixed(2)} = ${result.toFixed(2)} ตร.ม.`, 'success');
        }

        // แปลงค่าวันที่จากชีทกลับเป็นรูปแบบ "1-1", "1-2" ฯลฯ
        function normalizeFloorValue(value) {
            // กรณีเป็นวันที่ (เช่น "2025-12-31T17:00:00.000Z")
            if (typeof value === 'string' && value.includes('T') && value.includes('Z')) {
                try {
                    const date = new Date(value);
                    const month = date.getMonth() + 1;
                    const day = date.getDate();
                    return `${day}-${month}`;
                } catch (e) {
                    return '';
                }
            }
            // กรณีเป็นตัวเลข (serial number ของชีท)
            else if (typeof value === 'number' && value > 365) {
                const baseDate = new Date('1899-12-30');
                baseDate.setDate(baseDate.getDate() + Math.floor(value));
                const month = baseDate.getMonth() + 1;
                const day = baseDate.getDate();
                return `${day}-${month}`;
            }
            // กรณีปกติ
            return value || '';
        }





        // ประยุกต์การเปลี่ยนแปลงเฉพาะจุด
        async function applyDeltaUpdates(records, type) {
            for (const record of records) {
                const id = record.id || record._row_num;
                
                // ค้นหามาร์กเกอร์ที่มีอยู่
                let existingMarker = null;
                surveyLayers.eachLayer(layer => {
                    if (layer._popupData && (layer._popupData.id === id || layer._popupData._row_num === id)) {
                        existingMarker = layer;
                    }
                });
                
                if (existingMarker) {
                    // ✅ อัปเดตมาร์กเกอร์ที่มีอยู่ (ไม่ลบรีโหลดใหม่ทั้งหมด)
                    existingMarker._popupData = { ...existingMarker._popupData, ...record };
                    setupMarkerPopup(existingMarker, existingMarker._popupData, type);
                    
                    // อัปเดตพิกัดถ้ามีการเปลี่ยนแปลง
                    if (record.lat_long && record.lat_long !== existingMarker._popupData.lat_long) {
                        const coords = record.lat_long.split(',').map(Number);
                        existingMarker.setLatLng(L.latLng(coords[0], coords[1]));
                    }
                } else {
                    // ✅ เพิ่มมาร์กเกอร์ใหม่
                    if (record.lat_long) {
                        const coords = record.lat_long.split(',').map(Number);
                        const marker = createCircleMarker(L.latLng(coords[0], coords[1]), type, isEditMode);
                        marker._popupData = record;
                        setupMarkerPopup(marker, record, type);
                        marker.addTo(surveyLayers);
                        if (isEditMode) enableMarkerDragging(marker, record);
                    }
                }
            }
            
            // อัปเดตตารางข้อมูล
            if (type === 'building') {
                allBuildings = [...allBuildings.filter(b => !records.some(r => r.id === b.id)), ...records];
                renderBuildingTable();
            } else {
                allSigns = [...allSigns.filter(s => !records.some(r => r.id === s.id)), ...records];
                renderSignTable();
            }
        }

        // ลบมาร์กเกอร์ที่ถูกลบ
        function removeDeletedMarkers(deletedIds) {
            surveyLayers.eachLayer(layer => {
                if (layer._popupData && deletedIds.includes(layer._popupData.id || layer._popupData._row_num)) {
                    surveyLayers.removeLayer(layer);
                }
            });
            
            // อัปเดตตาราง
            allBuildings = allBuildings.filter(b => !deletedIds.includes(b.id));
            allSigns = allSigns.filter(s => !deletedIds.includes(s.id));
            renderBuildingTable();
            renderSignTable();
        }

        // อัปเดตเฉพาะมาร์กเกอร์ที่เปลี่ยนแปลง
        async function updateChangedMarkers(data) {
            const currentMarkers = {};
            
            // เก็บข้อมูลมาร์กเกอร์ปัจจุบัน
            surveyLayers.eachLayer(layer => {
                if (layer._popupData && layer._popupData.id) {
                    currentMarkers[layer._popupData.id] = layer;
                }
            });
            
            // ล้างมาร์กเกอร์ทั้งหมด
            surveyLayers.clearLayers();
            
            // สร้างมาร์กเกอร์ใหม่จากข้อมูล
            const allData = [...(data.buildings || []), ...(data.signs || [])];
            
            for (const item of allData) {
                if (!item.lat_long) continue;
                
                const coords = item.lat_long.split(',').map(Number);
                if (coords.length < 2 || isNaN(coords[0]) || isNaN(coords[1])) continue;
                
                const type = item.building_c ? 'building' : 'sign';
                const latLng = L.latLng(coords[0], coords[1]);
                
                // ตรวจสอบว่ามีมาร์กเกอร์เดิมหรือไม่
                const existingMarker = currentMarkers[item.id];
                
                if (existingMarker) {
                    // อัปเดตข้อมูลในมาร์กเกอร์เดิม
                    existingMarker.setLatLng(latLng);
                    existingMarker._popupData = item;
                    setupMarkerPopup(existingMarker, item, type);
                    existingMarker.addTo(surveyLayers);
                    
                    if (isEditMode) enableMarkerDragging(existingMarker, item);
                } else {
                    // สร้างมาร์กเกอร์ใหม่
                    const m = createCircleMarker(latLng, type, isEditMode);
                    setupMarkerPopup(m, item, type);
                    m.addTo(surveyLayers);
                    
                    if (isEditMode) enableMarkerDragging(m, item);
                }
            }
        }


        // ใช้ MarkerCluster สำหรับมาร์กเกอร์จำนวนมาก
        let markerCluster = null;

        function initMarkerClustering() {
            // สร้าง MarkerCluster Group
            markerCluster = L.markerClusterGroup({
                maxClusterRadius: 80, // ระยะห่างที่จะรวมเป็นคลัสเตอร์
                disableClusteringAtZoom: 16, // ปิดคลัสเตอร์เมื่อซูมใกล้
                chunkedLoading: true, // โหลดแบบแบ่งชิ้นส่วน
                chunkInterval: 200, // เวลาในการโหลดแต่ละชิ้น (มิลลิวินาที)
                chunkDelay: 50 // ดีเลย์ระหว่างการโหลด
            });
            
            // เพิ่มมาร์กเกอร์ลงในคลัสเตอร์แทนการเพิ่มลงแผนที่โดยตรง
            markerCluster.addTo(map);
        }

        // แปลงลิงก์ Google Drive เป็นลิงก์썸เนลที่ใช้ได้กับ <img> (วิธีที่ใช้งานได้จริง)
        function convertDriveUrlToDirect(url) {
            if (!url) return url;
            url = url.trim();
            
            // ✅ กรณีที่เป็นลิงก์썸เนลแล้ว → คืนค่าเดิม
            if (url.includes('drive.google.com/thumbnail')) {
                return url;
            }
            
            // ✅ กรณีที่เป็นลิงก์ตรงจาก Googleusercontent → คืนค่าเดิม
            if (url.includes('googleusercontent.com')) {
                return url;
            }
            
            // ✅ ดึง FILE_ID จากลิงก์รูปแบบต่างๆ
            let fileId = '';
            
            // รูปแบบที่ 1: /file/d/FILE_ID/view
            const pattern1 = /\/file\/d\/([a-zA-Z0-9_-]+)/;
            const match1 = url.match(pattern1);
            if (match1 && match1[1]) {
                fileId = match1[1];
            }
            
            // รูปแบบที่ 2: /uc?export=view&id=FILE_ID
            if (!fileId) {
                const pattern2 = /id=([a-zA-Z0-9_-]+)/;
                const match2 = url.match(pattern2);
                if (match2 && match2[1]) {
                    fileId = match2[1];
                }
            }
            
            // รูปแบบที่ 3: /open?id=FILE_ID
            if (!fileId) {
                const pattern3 = /open\?id=([a-zA-Z0-9_-]+)/;
                const match3 = url.match(pattern3);
                if (match3 && match3[1]) {
                    fileId = match3[1];
                }
            }
            
            // ✅ สร้างลิงก์썸เนล (ใช้งานได้จริงกับ <img>)
            if (fileId) {
                // sz=w1000 → ความกว้าง 1000px (ปรับอัตโนมัติ), ใช้ w2000 สำหรับความละเอียดสูงขึ้น
                return `https://drive.google.com/thumbnail?id=${fileId}&sz=w1000`;
            }
            
            // ✅ ถ้าไม่ใช่ลิงก์ Google Drive → คืนค่าเดิม
            return url;
        }

        // แสดงรูปภาพในองค์ประกอบแสดงผล
        function showImagePreview(imageUrl, fileName) {
            const container = document.getElementById('image-preview-container');
            const img = document.getElementById('image-preview');
            const placeholder = document.getElementById('image-preview-placeholder');
            
            if (!imageUrl || !imageUrl.trim()) {
                hideImagePreview();
                return;
            }
            
            // ✅ แสดงองค์ประกอบ
            container.style.display = 'flex';
            
            // ✅ แปลงลิงก์ Google Drive เป็นลิงก์ดาวน์โหลดตรง (สำคัญที่สุด!)
            const directUrl = convertDriveUrlToDirect(imageUrl);
            console.log('🖼️ ลิงก์รูปภาพ (หลังแปลง):', directUrl);
            
            // โหลดรูปภาพด้วยลิงก์ที่แปลงแล้ว
            img.src = directUrl; // ✅ ใช้ directUrl แทน imageUrl
            img.alt = fileName || 'รูปภาพ';
            img.classList.remove('hidden');
            placeholder.classList.add('hidden');
            
            // จัดการกรณีโหลดรูปภาพล้มเหลว
            img.onerror = () => {
                img.classList.add('hidden');
                placeholder.textContent = '❌ ไม่สามารถโหลดรูปภาพได้';
                placeholder.classList.remove('hidden');
                placeholder.classList.add('text-red-400');
                console.error('❌ โหลดรูปภาพล้มเหลว:', directUrl);
            };
            
            // ✅ ปรับตำแหน่งตามสถานะของตาราง
            const tablePanel = document.getElementById('data-table-panel');
            if (tablePanel && tablePanel.classList.contains('open')) {
                container.style.bottom = `calc(5px + 45vh + 10px)`;
            } else {
                container.style.bottom = '5px';
            }
            
            // ✅ สร้างไอคอน Lucide สำหรับปุ่มปิด
            lucide.createIcons();
        }

        // ซ่อนองค์ประกอบแสดงรูปภาพ (เมื่อผู้ใช้คลิกปุ่มปิด)
        function hideImagePreview() {
            const container = document.getElementById('image-preview-container');
            if (container) {
                container.style.display = 'none';
                console.log('🖼️ ซ่อนหน้าต่างรูปภาพ');
            }
        }

        // จัดการการคลิกที่ป้ายชื่อรูปภาพ
        function handleImageBadgeClick(imageUrl, fileName) {
            if (!imageUrl || imageUrl.trim() === '') {
                showNotificationLeft('ไม่มีรูปภาพให้แสดง', 'warning');
                return;
            }
            
            // แสดงรูปภาพในองค์ประกอบแสดงผล
            showImagePreview(imageUrl, fileName);
        }


        // เมื่อสร้างมาร์กเกอร์ใหม่
        function createCircleMarker(latlng, type, isDraggable = false) {
            const className = type === 'building' ? 'circle-building' : 'circle-sign';
            
            const icon = L.divIcon({
                className: `circle-marker ${className}`,
                iconSize: [14, 14],
                iconAnchor: [7, 7]
            });
            
            const marker = L.marker(latlng, {
                icon: icon,
                draggable: isDraggable, // ✅ ตั้งค่าตอนสร้าง
                zIndexOffset: 1000
            });
            
            // ✅ ลบการผูกคลิกออกทั้งหมด - Leaflet จะจัดการอัตโนมัติเมื่อใช้ bindPopup
            
            // ✅ ผูกเหตุการณ์ลากเฉพาะเมื่อเป็นโหมดแก้ไข
            if (isDraggable) {
                marker.on('dragstart', function(e) {
                    if (e.originalEvent) L.DomEvent.stopPropagation(e.originalEvent);
                    if (marker.getPopup()) marker.closePopup();
                });
                
                marker.on('dragend', async function(e) {
                    const newLatLng = e.target.getLatLng();
                    const data = e.target._popupData;
                    if (data && typeof updateMarkerPosition === 'function') {
                        await updateMarkerPosition(e.target, data, newLatLng);
                    }
                });
            }
            
            return marker;
        }

        // ============================================
        // ดาวน์โหลดรูปทั้งหมดจากสเปรดชีต
        // ============================================
        document.addEventListener('DOMContentLoaded', function() {
            const downloadBtn = document.getElementById('download-all-images');
            if (downloadBtn) {
                downloadBtn.addEventListener('click', async function() {
                    try {
                        showNotificationLeft('กำลังโหลดข้อมูลรูปภาพ...', 'info');
                        
                        // ดึงข้อมูลจากสเปรดชีต
                        const response = await fetch(CONFIG.SCRIPT_URL + '?action=getData');
                        const data = await response.json();
                        
                        // รวมรูปจากทั้งอาคารและป้าย
                        const allImages = [
                            ...data.buildings.filter(b => b.image && b.image.includes('http')),
                            ...data.signs.filter(s => s.image && s.image.includes('http'))
                        ];
                        
                        if (allImages.length === 0) {
                            showNotificationLeft('⚠️ ไม่พบรูปภาพในระบบ', 'warning');
                            return;
                        }
                        
                        showNotificationLeft(`กำลังดาวน์โหลด ${allImages.length} รูปภาพ...`, 'info');
                        
                        // ดาวน์โหลดทีละรูป
                        for (let i = 0; i < allImages.length; i++) {
                            const item = allImages[i];
                            const imageUrl = item.image;
                            const fileName = item.picture || `image_${i + 1}.jpg`;
                            
                            try {
                                // ดาวน์โหลดรูป
                                const imgResponse = await fetch(imageUrl);
                                const blob = await imgResponse.blob();
                                
                                // สร้างลิงก์ดาวน์โหลด
                                const link = document.createElement('a');
                                link.href = URL.createObjectURL(blob);
                                link.download = fileName;
                                document.body.appendChild(link);
                                link.click();
                                document.body.removeChild(link);
                                URL.revokeObjectURL(link.href);
                                
                                console.log(`✅ ดาวน์โหลด: ${fileName}`);
                                
                                // รอ 500ms ระหว่างดาวน์โหลดแต่ละรูป
                                if (i < allImages.length - 1) {
                                    await new Promise(resolve => setTimeout(resolve, 500));
                                }
                            } catch (err) {
                                console.error(`❌ ดาวน์โหลด ${fileName} ล้มเหลว:`, err);
                                showNotificationLeft(`⚠️ ดาวน์โหลด ${fileName} ล้มเหลว`, 'error');
                            }
                        }
                        
                        showNotificationLeft(`✅ ดาวน์โหลดรูปภาพทั้งหมด (${allImages.length} รูป) เสร็จสิ้น!`, 'success');
                    } catch (err) {
                        console.error('❌ ข้อผิดพลาด:', err);
                        showNotificationLeft('❌ ดาวน์โหลดล้มเหลว: ' + err.message, 'error');
                    }
                });
            }
        });

        // ============================================
        // ป้องกันการเปลี่ยนค่าช่องตัวเลขโดยไม่ตั้งใจเมื่อหมุนสกอร์ลเมาส์
        // ============================================
        document.addEventListener('DOMContentLoaded', function() {
          const surveyForm = document.getElementById('survey-form');
          if (surveyForm) {
            // ใช้ event delegation ครอบคลุมทุกช่องตัวเลขแม้สร้างแบบไดนามิก
            surveyForm.addEventListener('wheel', function(e) {
              if (e.target.tagName === 'INPUT' && e.target.type === 'number') {
                e.preventDefault(); // ป้องกันการเปลี่ยนค่าเมื่อหมุนสกอร์ล
              }
            }, { passive: false }); // ต้องตั้ง passive: false เพื่อเรียก preventDefault()
            
            console.log('✅ เปิดใช้งานการป้องกันการเปลี่ยนค่าช่องตัวเลขโดยไม่ตั้งใจ');
          }
        });

        // ฟังก์ชันโหลดมาร์กเกอร์เฉพาะที่มองเห็น + buffer
        function loadVisibleMarkers() {
            // เก็บจุดชั่วคราวทั้งหมดก่อนล้าง
            const ยังไม่สำรวจMarkers = [];
            if (markerCluster) {
                markerCluster.eachLayer(layer => {
                    if (layer._popupData) {
                        if (layer._popupData.queued || layer._popupData.tempMarker) {
                            ยังไม่สำรวจMarkers.push({
                                latlng: layer.getLatLng(),
                                data: layer._popupData,
                                type: layer._popupData.type
                            });
                        }
                    }
                });
            } else {
                surveyLayers.eachLayer(layer => {
                    if (layer._popupData) {
                        if (layer._popupData.queued || layer._popupData.tempMarker) {
                            ยังไม่สำรวจMarkers.push({
                                latlng: layer.getLatLng(),
                                data: layer._popupData,
                                type: layer._popupData.type
                            });
                        }
                    }
                });
            }
            
            const bounds = map.getBounds();
            const bufferRatio = isMobile() ? 1.5 : 2.0;
            const bufferedBounds = bounds.pad(bufferRatio);
            
            // ล้างมาร์กเกอร์ทั้งหมด
            if (markerCluster) {
                markerCluster.clearLayers();
            } else {
                surveyLayers.clearLayers();
            }
            
            // โหลดเฉพาะมาร์กเกอร์ที่อยู่ในขอบเขต + buffer
            allBuildings.forEach(r => {
                if (!r.lat_long) return;
                const coords = r.lat_long.split(',').map(Number);
                if (coords.length < 2 || isNaN(coords[0]) || isNaN(coords[1])) return;
                const latLng = L.latLng(coords[0], coords[1]);
                if (!bufferedBounds.contains(latLng)) return;
                
                // ✅ ตรวจสอบว่าจุดนี้กำลังถูกย้ายหรือไม่
                const recordKey = r._row_num || r.id;
                if (markersBeingMoved.has(recordKey)) {
                    return; // ข้ามการสร้างจุดจริง
                }
                
                const m = createCircleMarker(latLng, 'building', isEditMode);
                setupMarkerPopup(m, r, 'building');
                if (markerCluster) {
                    markerCluster.addLayer(m);
                } else {
                    m.addTo(surveyLayers);
                }
            });
            
            allSigns.forEach(r => {
                if (!r.lat_long) return;
                const coords = r.lat_long.split(',').map(Number);
                if (coords.length < 2 || isNaN(coords[0]) || isNaN(coords[1])) return;
                const latLng = L.latLng(coords[0], coords[1]);
                if (!bufferedBounds.contains(latLng)) return;
                
                // ✅ ตรวจสอบว่าจุดนี้กำลังถูกย้ายหรือไม่
                const recordKey = r._row_num || r.id; // ✅ เพิ่มบรรทัดนี้
                if (markersBeingMoved.has(recordKey)) { // ✅ แก้เป็น recordKey
                    return;
                }
                
                const m = createCircleMarker(latLng, 'sign', isEditMode);
                setupMarkerPopup(m, r, 'sign');
                if (markerCluster) {
                    markerCluster.addLayer(m);
                } else {
                    m.addTo(surveyLayers);
                }
            });
            
            // เพิ่มจุดชั่วคราวกลับเข้ามา
            ยังไม่สำรวจMarkers.forEach(marker => {
                const m = createCircleMarker(marker.latlng, marker.type, isEditMode);
                m._popupData = marker.data;
                setupMarkerPopup(m, marker.data, marker.type);
                if (markerCluster) {
                    markerCluster.addLayer(m);
                } else {
                    m.addTo(surveyLayers);
                }
                if (isEditMode) enableMarkerDragging(m, marker.data);
            });
        }

        // เรียกใช้เมื่อเลื่อนหรือซูมแผนที่
        map.on('moveend', loadVisibleMarkers);
        map.on('zoomend', loadVisibleMarkers);

        // ============================================
        // 1. แก้ไขฟังก์ชัน refreshData (ใช้ระบบใหม่)
        // ============================================
        function refreshData() {
            const refreshBtn = document.getElementById('btn-refresh');
            const refreshIcon = document.getElementById('refresh-icon');
            
            disableRefreshButton();
            refreshIcon.classList.add('animate-spin');
            
            // ✅ เปลี่ยนจาก smartLoadData() เป็น loadExistingData()
            loadExistingData().finally(() => {
                setTimeout(() => {
                    refreshIcon.classList.remove('animate-spin');
                    enableRefreshButton();
                }, 500);
            });
        }

        // ============================================
        // 1. วางก่อน `window.addEventListener('load')` ทั้งหมด
        // ============================================

        // หยุดระบบอัปเดตเมื่อปิดหน้าต่าง
        window.addEventListener('beforeunload', () => {
            stopRealtimeAutoUpdate();
        });

        // ตรวจจับการเชื่อมต่อออนไลน์
        window.addEventListener('online', () => {
            isOnline = true;
            updateConnectionStatus();
            // เมื่อกลับมาออนไลน์ ให้พยายามส่งข้อมูลที่ค้างอยู่
            setTimeout(processSyncQueue, 1000);
        });

        // ตรวจจับการออฟไลน์
        window.addEventListener('offline', () => {
            isOnline = false;
            updateConnectionStatus();
        });

        // ============================================
        // 2. เริ่มต้นแอป (มีเพียง 1 ครั้งเดียว)
        // ============================================
        window.addEventListener('load', async () => {
            // 1. เริ่มต้นแผนที่และไอคอน
            initMap();
            lucide.createIcons();
            
            // 2. โหลดข้อมูลและเริ่มระบบอัปเดต
            await loadExistingData();           // ← โหลดข้อมูลครั้งแรก
            startRealtimeAutoUpdate();          // ← เริ่มระบบอัปเดตอัตโนมัติ (สำคัญที่สุด!)
            
            // 3. ตรวจสอบและซิงค์ข้อมูลที่ค้างอยู่
            await checkAndSyncOnStartup();
            
            // 4. อัปเดตจุดแจ้งเตือนจำนวนข้อมูลที่รอซิงค์
            setInterval(updateSyncBadge, 1000);
            
            // 5. ลงทะเบียน Service Worker
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => console.log('Service Worker registered:', registration.scope))
                    .catch(error => console.log('Service Worker registration failed:', error));
            }
        });

        // ฟังก์ชันแสดงชื่อไฟล์ที่เลือก
        function updateFileName(input, fieldId) {
        const filenameSpan = document.getElementById(`filename-${fieldId}`);
        if (!filenameSpan) return;
        if (input.files && input.files[0]) {
        const filename = input.files[0].name;
        filenameSpan.textContent = filename;
        filenameSpan.classList.remove('hidden');
        filenameSpan.classList.add('bg-blue-100', 'text-blue-800');
        } else {
        filenameSpan.classList.add('hidden');
        }
        }

    </script>
</body>

</html>

